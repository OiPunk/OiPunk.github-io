<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Spring Cloud,框架,微服务,注册中心," />










<meta name="description" content="Eureka原理源码，集群搭建">
<meta property="og:type" content="article">
<meta property="og:title" content="Eureka注册中心详解">
<meta property="og:url" content="http://yoursite.com/2020/08/13/Eureka%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E8%AF%A6%E8%A7%A3/index.html">
<meta property="og:site_name" content="JavaCode">
<meta property="og:description" content="Eureka原理源码，集群搭建">
<meta property="og:image" content="http://yoursite.com/2020/08/13/Eureka%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E8%AF%A6%E8%A7%A3/image-20200823173543002.png">
<meta property="og:image" content="http://yoursite.com/2020/08/13/Eureka%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E8%AF%A6%E8%A7%A3/image-20200823173700162.png">
<meta property="og:image" content="http://yoursite.com/2020/08/13/Eureka%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E8%AF%A6%E8%A7%A3/image-20200823173713961.png">
<meta property="og:image" content="http://yoursite.com/2020/08/13/Eureka%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E8%AF%A6%E8%A7%A3/image-20200823173728290.png">
<meta property="og:image" content="http://yoursite.com/2020/08/13/Eureka%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E8%AF%A6%E8%A7%A3/image-20200823173914337.png">
<meta property="og:image" content="http://yoursite.com/2020/%E5%8F%AA%E8%A6%81%E5%AD%A6%E4%B8%8D%E6%AD%BB%20%E5%B0%B1%E5%BE%80%E6%AD%BB%E9%87%8C%E5%AD%A6/note/%E7%BD%91%E7%BA%A6%E8%BD%A6/online-taxi-file-master/%E4%BA%8C%E6%9C%9F/%E8%AF%BE%E7%A8%8Bmd/%E6%8C%89%E7%BB%84%E4%BB%B6%E5%8C%BA%E5%88%86/03-%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0/image-20200823173937080.png">
<meta property="og:image" content="http://yoursite.com/2020/08/13/Eureka%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E8%AF%A6%E8%A7%A3/image-20200823174051490.png">
<meta property="og:image" content="http://yoursite.com/2020/08/13/Eureka%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E8%AF%A6%E8%A7%A3/image-20200823174202817.png">
<meta property="article:published_time" content="2020-08-13T09:44:34.000Z">
<meta property="article:modified_time" content="2020-08-23T19:39:03.276Z">
<meta property="article:author" content="OiPunk">
<meta property="article:tag" content="Spring Cloud">
<meta property="article:tag" content="框架">
<meta property="article:tag" content="微服务">
<meta property="article:tag" content="注册中心">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/2020/08/13/Eureka%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E8%AF%A6%E8%A7%A3/image-20200823173543002.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '作者'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2020/08/13/Eureka注册中心详解/"/>





  <title>Eureka注册中心详解 | JavaCode</title>
  








<meta name="generator" content="Hexo 4.2.1"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>
    
    <a href="https://github.com/OiPunk" target="_blank" rel="noopener" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>    
    
    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">JavaCode</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Oi!</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            日志
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/13/Eureka%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="OiPunk">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/oi.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JavaCode">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Eureka注册中心详解</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-08-13T17:44:34+08:00">
                2020-08-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i>
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
            </span>
          

          

          
              <div class="post-description">
                  Eureka原理源码，集群搭建
              </div>
          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="1-Eureka-单节点搭建"><a href="#1-Eureka-单节点搭建" class="headerlink" title="1 Eureka 单节点搭建"></a>1 Eureka 单节点搭建</h2><ol>
<li><p>pom.xml</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">有的教程中还引入spring-boot-starter-web，其实不用。因为上面的依赖已经包含了它。在pom中点此依赖进去，一共点4次spring-cloud-netflix-eureka-server，发现web的依赖。</span><br></pre></td></tr></table></figure>
</li>
<li><p>application.yml</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">eureka: </span><br><span class="line">  client:</span><br><span class="line">    <span class="comment">#是否将自己注册到Eureka Server,默认为true，由于当前就是server，故而设置成false，表明该服务不会向eureka注册自己的信息</span></span><br><span class="line">    register-with-eureka: <span class="literal">false</span></span><br><span class="line">    <span class="comment">#是否从eureka server获取注册信息，由于单节点，不需要同步其他节点数据，用false</span></span><br><span class="line">    fetch-registry: <span class="literal">false</span></span><br><span class="line">    <span class="comment">#设置服务注册中心的URL，用于client和server端交流</span></span><br><span class="line">    service-url:                      </span><br><span class="line">      defaultZone: http://root:root@eureka-7901:7901/eureka/</span><br></pre></td></tr></table></figure>
</li>
<li><p>代码</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">启动类上添加此注解标识该服务为配置中心</span><br><span class="line">@EnableEurekaServer</span><br></pre></td></tr></table></figure>
</li>
<li><p>PS：Eureka会暴露一些端点。端点用于Eureka Client注册自身，获取注册表，发送心跳。</p>
</li>
<li><p>简单看一下eureka server控制台，实例信息区，运行环境信息区，Eureka Server自身信息区。</p>
</li>
</ol>
<h2 id="2-整体介绍"><a href="#2-整体介绍" class="headerlink" title="2 整体介绍"></a>2 整体介绍</h2><ol>
<li>背景：在传统应用中，组件之间的调用，通过有规范的约束的接口来实现，从而实现不同模块间良好的协作。但是被拆分成微服务后，每个微服务实例的网络地址都可能动态变化，数量也会变化，使得原来硬编码的地址失去了作用。需要一个中心化的组件来进行服务的登记和管理。</li>
<li>概念：实现服务治理，即管理所有的服务信息和状态。</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注册中心相当于买票乘车，只看有没有票（有没有服务），有就去买票（获取注册列表），然后乘车（调用）。不必关心有多少火车在运行。</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>注册中心好处：不用关心有多少提供方。</p>
</li>
<li><p>注册中心有哪些:Eureka，Nacos，Consul，Zookeeper等。</p>
</li>
<li><p>服务注册与发现包括两部分，一个是服务器端，另一个是客户端。</p>
<p>Server是一个公共服务，为Client提供服务注册和发现的功能，维护注册到自身的Client的相关信息，同时提供接口给Client获取注册表中其他服务的信息，使得动态变化的Client能够进行服务间的相互调用。</p>
<p>Client将自己的服务信息通过一定的方式登记到Server上，并在正常范围内维护自己信息一致性，方便其他服务发现自己，同时可以通过Server获取到自己依赖的其他服务信息，完成服务调用，还内置了负载均衡器，用来进行基本的负载均衡。</p>
</li>
<li><p>我们课程的Spring Cloud是用Eureka作为服务注册中心。</p>
</li>
<li><p>Eureka：是一个RESTful风格的服务，是一个用于服务发现和注册的基础组件，是搭建Spring Cloud微服务的前提之一，它屏蔽了Server和client的交互细节，使得开发者将精力放到业务上。</p>
</li>
<li><p>serverA从serverB同步信息，则serverB是serverA的peer。</p>
</li>
<li><p>上面例子中如果service-url为空，且register-with-eureka，fetch-registry为true，则会报错，Cannot execute request on any known server，因为server同时也是一个client，他会尝试注册自己，所以要有一个注册中心url去注册。</p>
</li>
<li><p>Netflix开源的组件。包括server和client两部分。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/Netflix/Eureka</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="3-注册中心和微服务间的关系"><a href="#3-注册中心和微服务间的关系" class="headerlink" title="3 注册中心和微服务间的关系"></a>3 注册中心和微服务间的关系</h2><p><img src="/2020/08/13/Eureka%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E8%AF%A6%E8%A7%A3/image-20200823173543002.png" alt="image-20200823173543002"></p>
<h3 id="11-3-1-client功能"><a href="#11-3-1-client功能" class="headerlink" title="11.3.1 client功能"></a>11.3.1 client功能</h3><ol>
<li>注册：每个微服务启动时，将自己的网络地址等信息注册到注册中心，注册中心会存储（内存中）这些信息。</li>
<li>获取服务注册表：服务消费者从注册中心，查询服务提供者的网络地址，并使用该地址调用服务提供者，为了避免每次都查注册表信息，所以client会定时去server拉取注册表信息到缓存到client本地。</li>
<li>心跳：各个微服务与注册中心通过某种机制（心跳）通信，若注册中心长时间和服务间没有通信，就会注销该实例。</li>
<li>调用：实际的服务调用，通过注册表，解析服务名和具体地址的对应关系，找到具体服务的地址，进行实际调用。</li>
</ol>
<h3 id="11-3-2-server注册中心功能"><a href="#11-3-2-server注册中心功能" class="headerlink" title="11.3.2 server注册中心功能"></a>11.3.2 server注册中心功能</h3><ol>
<li><p>服务注册表：记录各个微服务信息，例如服务名称，ip，端口等。</p>
<p>注册表提供 查询API（查询可用的微服务实例）和管理API（用于服务的注册和注销）。</p>
</li>
<li><p>服务注册与发现：注册：将微服务信息注册到注册中心。发现：查询可用微服务列表及其网络地址。</p>
</li>
<li><p>服务检查：定时检测已注册的服务，如发现某实例长时间无法访问，就从注册表中移除。</p>
</li>
</ol>
<p>组件：Eureka , Consul , ZooKeeper，nacos等。</p>
<h2 id="4-服务注册"><a href="#4-服务注册" class="headerlink" title="4 服务注册"></a>4 服务注册</h2><p>例子：api-listen-order</p>
<ol>
<li>pom.xml</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>application.yml</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#注册中心</span></span><br><span class="line">eureka: </span><br><span class="line">  client:</span><br><span class="line">    <span class="comment">#设置服务注册中心的URL</span></span><br><span class="line">    service-url:                      </span><br><span class="line">      defaultZone: http://root:root@localhost:7900/eureka/</span><br></pre></td></tr></table></figure>

<p>ps:不想注册，设置成false即可，实例演示结果：注册中心没有实例信息。找控制台204信息也没有找到。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">spring: </span><br><span class="line">  cloud:</span><br><span class="line">    service-registry:</span><br><span class="line">      auto-registration:</span><br><span class="line">        enabled: <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>注册成功：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DiscoveryClient_API-LISTEN-ORDER/api-listen-order:30.136.133.9:port - registration status: 204</span><br></pre></td></tr></table></figure>

<p>后面源码讲手动注册。</p>
<p>PS:</p>
<p>Eureka Server与Eureka Client之间的联系主要通过心跳的方式实现。心跳(Heartbeat)即Eureka Client定时向Eureka Server汇报本服务实例当前的状态，维护本服务实例在注册表中租约的有效性。</p>
<p>Eureka Client将定时从Eureka Server中拉取注册表中的信息，并将这些信息缓存到本地，用于服务发现。</p>
<h2 id="5-Eureka高可用"><a href="#5-Eureka高可用" class="headerlink" title="5 Eureka高可用"></a>5 Eureka高可用</h2><p>高可用：可以通过运行多个Eureka server实例并相互注册的方式实现。Server节点之间会彼此增量地同步信息，从而确保节点中数据一致。</p>
<ol>
<li>注册中心改造</li>
</ol>
<p>application.yml</p>
<p>参考：#高可用2个节点的yml</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#高可用2个节点</span></span><br><span class="line"><span class="comment">#应用名称及验证账号</span></span><br><span class="line">spring: </span><br><span class="line">  application: </span><br><span class="line">    name: eureka</span><br><span class="line">    </span><br><span class="line">  security: </span><br><span class="line">    user: </span><br><span class="line">      name: root</span><br><span class="line">      password: root</span><br><span class="line"></span><br><span class="line">logging:</span><br><span class="line">  level:</span><br><span class="line">    root: debug</span><br><span class="line">    </span><br><span class="line">---</span><br><span class="line">spring:</span><br><span class="line">  profiles: 7901</span><br><span class="line">server: </span><br><span class="line">  port: 7901</span><br><span class="line">eureka:</span><br><span class="line">  instance:</span><br><span class="line">    hostname: eureka-7901  </span><br><span class="line">  client:</span><br><span class="line">    <span class="comment">#设置服务注册中心的URL</span></span><br><span class="line">    service-url:                      </span><br><span class="line">      defaultZone: http://root:root@eureka-7902:7902/eureka/</span><br><span class="line">---    </span><br><span class="line">spring:</span><br><span class="line">  profiles: 7902</span><br><span class="line">server: </span><br><span class="line">  port: 7902</span><br><span class="line">eureka:</span><br><span class="line">  instance:</span><br><span class="line">    hostname: eureka-7902  </span><br><span class="line">  client:</span><br><span class="line">       <span class="comment">#设置服务注册中心的URL</span></span><br><span class="line">    service-url:                      </span><br><span class="line">      defaultZone: http://root:root@eureka-7901:7901/eureka/</span><br></pre></td></tr></table></figure>

<p>—将配置文件分成2段，每段指定spring.profiles。第一段没有指定，所以共用。</p>
<ol start="2">
<li><p>服务注册改造</p>
<p>api-listen-order</p>
</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">eureka: </span><br><span class="line">  client:</span><br><span class="line">    <span class="comment">#设置服务注册中心的URL</span></span><br><span class="line">    service-url:                      </span><br><span class="line">      defaultZone: http://root:root@eureka-7901:7901/eureka/,http://root:root@eureka-7902:7902/eureka/</span><br></pre></td></tr></table></figure>

<p>写一个地址也行（但是server得互相注册），EurekaServer会自动同步，但为了避免极端情况，还是写多个。</p>
<p>集群PS:</p>
<p>集群中各个server会从其他server同步注册表信息。</p>
<h2 id="6-Eureka-端点"><a href="#6-Eureka-端点" class="headerlink" title="6 Eureka 端点"></a>6 Eureka 端点</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">看官网：</span><br><span class="line">https://github.com/Netflix/eureka/wiki/Eureka-REST-operations</span><br><span class="line"></span><br><span class="line">body:</span><br><span class="line">&lt;instance&gt;</span><br><span class="line">&lt;instanceId&gt;instanceid-2019&lt;/instanceId&gt;</span><br><span class="line">&lt;hostName&gt;eureka-7900&lt;/hostName&gt;</span><br><span class="line">&lt;app&gt;EUREKA-custom&lt;/app&gt;</span><br><span class="line">&lt;ipAddr&gt;127.0.0.1&lt;/ipAddr&gt;</span><br><span class="line">&lt;status&gt;UP&lt;/status&gt;</span><br><span class="line">&lt;overriddenstatus&gt;UNKNOWN&lt;/overriddenstatus&gt;</span><br><span class="line">&lt;port enabled=<span class="string">"true"</span>&gt;1900&lt;/port&gt;</span><br><span class="line">&lt;securePort enabled=<span class="string">"false"</span>&gt;443&lt;/securePort&gt;</span><br><span class="line">&lt;countryId&gt;1&lt;/countryId&gt;</span><br><span class="line">&lt;dataCenterInfo class=<span class="string">"com.netflix.appinfo.InstanceInfo<span class="variable">$DefaultDataCenterInfo</span>"</span>&gt;</span><br><span class="line">&lt;name&gt;MyOwn&lt;/name&gt;</span><br><span class="line">&lt;/dataCenterInfo&gt;</span><br><span class="line"></span><br><span class="line">&lt;/instance&gt;</span><br><span class="line"></span><br><span class="line">地址：localhost:7900/eureka/apps/&#123;applicaitonName&#125;</span><br><span class="line"></span><br><span class="line">yapi：http://yapi.demo.qunar.com/</span><br></pre></td></tr></table></figure>

<p>例子：手写注册服务</p>
<p>步骤：</p>
<ol>
<li>启动单节点eureka，7900。</li>
<li>打开yapi。yapi-&gt;Spring Cloud学习-&gt;测试集合-&gt;Eureka-&gt;向EurekaServer注册服务。</li>
<li>执行访问，查看eureka server控制台。</li>
</ol>
<p>ps：一些语言也有Eureka Client的开源实现，比如node.JS</p>
<hr>
<p>2020-01-12 第一节课完。</p>
<p>课下问题：</p>
<ol>
<li><p>eureka无用。其实只是2.0不更新了。1.0还在更新，也在大量的用。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/Netflix/eureka/wiki</span><br></pre></td></tr></table></figure>

<p>即使它以后都不用了 eureka 的思路也是值得学习的。毕竟服务注册中心，就这些东西。</p>
</li>
<li><p>lombok使用</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- lombok --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">	&lt;version&gt;1.18.8&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">ide安装插件</span><br><span class="line"></span><br><span class="line">getter/setter</span><br></pre></td></tr></table></figure>
</li>
<li><p>域名问题</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">域名在 物理机的host文件配置，只是为了好区分，不是必须的。只要能访问到机器就行，用localhost，ip均可。</span><br></pre></td></tr></table></figure>
</li>
<li><p>多节点注意事项</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">问题：eureka server间 设置peer。A-&gt;B,B-&gt;C,C-&gt;A，结果注册信息并不同步。</span><br><span class="line">看例子:</span><br><span class="line">依次启动7901,7902,7903。</span><br><span class="line">启动成功，注册api-driver -&gt;7901</span><br><span class="line">发现只有7901和7902有 api-driver而 7903没有。</span><br><span class="line"></span><br><span class="line">简单说：api-driver向 7901注册，7902将api-driver同步到7902，但是不会同步到7903。后面源码会讲到。</span><br><span class="line">多节点建议：设置A-&gt;B,A-&gt;C其他类似。尽量不要跨 eureka节点。一对多，面面对到。</span><br><span class="line"></span><br><span class="line">讲解下图。前置概念peer。清除流程。</span><br><span class="line"></span><br><span class="line">功能点：</span><br><span class="line">peer启动：</span><br><span class="line">1、拉取它的peer的注册表。</span><br><span class="line">2、把自己注册到peer上。</span><br><span class="line">3、完成2之后，2中的peer会把它同步到，2中peer的peer。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>为什么有时候3个实例，后来都变成2个实例了。</p>
</blockquote>
<p><img src="/2020/08/13/Eureka%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E8%AF%A6%E8%A7%A3/image-20200823173700162.png" alt="image-20200823173700162"></p>
</li>
<li><p>yml配置文件分段。</p>
</li>
<li><p>可以独立使用，利用它的各种端点做开发，甚至可以自己做个服务注册中心。</p>
</li>
</ol>
<hr>
<h2 id="7-Eureka-原理"><a href="#7-Eureka-原理" class="headerlink" title="7 Eureka 原理"></a>7 Eureka 原理</h2><ol>
<li><p>本质：存储了每个客户端的注册信息。EurekaClient从EurekaServer同步获取服务注册列表。通过一定的规则选择一个服务进行调用。</p>
</li>
<li><p>Eureka架构图</p>
<p><img src="/2020/08/13/Eureka%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E8%AF%A6%E8%A7%A3/image-20200823173713961.png" alt="image-20200823173713961"></p>
</li>
<li><p>详解</p>
</li>
</ol>
<ul>
<li>服务提供者：是一个eureka client，向Eureka Server注册和更新自己的信息，同时能从Eureka Server注册表中获取到其他服务的信息。</li>
<li>服务注册中心：提供服务注册和发现的功能。每个Eureka Cient向Eureka Server注册自己的信息，也可以通过Eureka Server获取到其他服务的信息达到发现和调用其他服务的目的。</li>
<li>服务消费者：是一个eureka client，通过Eureka Server获取注册到其上其他服务的信息，从而根据信息找到所需的服务发起远程调用。</li>
<li>同步复制：Eureka Server之间注册表信息的同步复制，使Eureka Server集群中不同注册表中服务实例信息保持一致。</li>
<li>远程调用：服务客户端之间的远程调用。</li>
<li>注册：Client端向Server端注册自身的元数据以供服务发现。</li>
<li>续约：通过发送心跳到Server以维持和更新注册表中服务实例元数据的有效性。当在一定时长内，Server没有收到Client的心跳信息，将默认服务下线，会把服务实例的信息从注册表中删除。</li>
<li>下线：Client在关闭时主动向Server注销服务实例元数据，这时Client的服务实例数据将从Server的注册表中删除。</li>
<li>获取注册表：Client向Server请求注册表信息，用于服务发现，从而发起服务间远程调用。</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">让我们自己做：如何做。？</span><br><span class="line"></span><br><span class="line">客户端：</span><br><span class="line">拉取注册表</span><br><span class="line">从注册表选一个</span><br><span class="line">调用</span><br><span class="line"></span><br><span class="line">服务端：</span><br><span class="line">写个web server。</span><br><span class="line">功能：</span><br><span class="line">1、定义注册表：</span><br><span class="line">Map&lt;name,Map&lt;id,InstanceInfo&gt;&gt;。</span><br><span class="line">2、别人可以向我注册自己的信息。</span><br><span class="line">3、别人可以从我这里拉取他人的注册信息。</span><br><span class="line">4、我和我的同类可以共享注册表。</span><br><span class="line"></span><br><span class="line">eureka是用：jersey实现，也是个mvc框架。</span><br><span class="line">我们可以自己写个spring boot web实现。</span><br></pre></td></tr></table></figure>



<h2 id="8-Eureka-Client源码"><a href="#8-Eureka-Client源码" class="headerlink" title="8 Eureka Client源码"></a>8 Eureka Client源码</h2><ol>
<li><p>功能复习</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/Netflix/eureka/wiki/Eureka-REST-operations</span><br><span class="line">注意地址中的v2 是没有的。</span><br><span class="line"></span><br><span class="line">查询所有实例信息：http://localhost:7900/eureka/apps</span><br><span class="line"></span><br><span class="line">注册服务：http://localhost:7900/eureka/apps/&#123;applicationName&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/13/Eureka%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E8%AF%A6%E8%A7%A3/image-20200823173728290.png" alt="image-20200823173728290"></p>
</li>
<li><p>源码解读</p>
<p>下面的讲解按照顺序进行。</p>
<ul>
<li><p>spring boot项目引入eureka-client依赖，并注入spring 容器。</p>
<p>在spring-boot项目中pom文件里面添加的依赖中的bean。是如何注册到spring-boot项目的spring容器中的呢？spring.factories文件是帮助spring-boot项目包以外的bean（即在pom文件中添加依赖中的bean）注册到spring-boot项目的spring容器的。</p>
<p>由于@ComponentScan注解只能扫描spring-boot项目包内的bean并注册到spring容器中，因此需要@EnableAutoConfiguration（在SpringBootApplication下），注解来注册项目包外的bean。而spring.factories文件，则是用来记录项目包外需要注册的bean类名。</p>
</li>
</ul>
</li>
</ol>
<pre><code>点进去@SpringBootApplication注解，发现@EnableAutoConfiguration。点@EnableAutoConfiguration进去。

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Import(AutoConfigurationImportSelector.class)</span><br><span class="line">public @interface EnableAutoConfiguration &#123;</span><br></pre></td></tr></table></figure>

点AutoConfigurationImportSelector进去

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">发现下面代码</span><br><span class="line">	@Override</span><br><span class="line">	public String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!isEnabled(annotationMetadata)) &#123;</span><br><span class="line">			<span class="built_in">return</span> NO_IMPORTS;</span><br><span class="line">		&#125;</span><br><span class="line">		AutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader</span><br><span class="line">				.loadMetadata(this.beanClassLoader);</span><br><span class="line">		AutoConfigurationEntry autoConfigurationEntry = getAutoConfigurationEntry(autoConfigurationMetadata,</span><br><span class="line">				annotationMetadata);</span><br><span class="line">		<span class="built_in">return</span> StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

此方法时，向spring ioc容器注入bean。selectImports，返回bean全名。import将bean全名注入。而注入的bean都是些什么呢？

点：getAutoConfigurationEntry进去，有一句

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes);</span><br></pre></td></tr></table></figure>

点getCandidateConfigurations进去：

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(getSpringFactoriesLoaderFactoryClass(),</span><br><span class="line">				getBeanClassLoader());</span><br></pre></td></tr></table></figure>

点SpringFactoriesLoader进去：

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static final String FACTORIES_RESOURCE_LOCATION = <span class="string">"META-INF/spring.factories"</span>;</span><br></pre></td></tr></table></figure></code></pre><ul>
<li><p>找eureka client 配置相关类</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">在api-listen-order(其他eureka client项目均可)项目中，找到</span><br><span class="line">spring-cloud-netflix-eureka-client-2.1.2.RELEASE下META-INF下spring.factories。此文件中，有如下配置信息：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">EurekaClientAutoConfiguration（Eureka client自动配置类，负责Eureka client中关键beans的配置和初始化），</span><br><span class="line">RibbonEurekaAutoConfiguration（Ribbon负载均衡相关配置）	</span><br><span class="line">EurekaDiscoveryClientConfiguration（配置自动注册和应用的健康检查器）。</span><br></pre></td></tr></table></figure>
</li>
<li><p>EurekaDiscoveryClientConfiguration介绍</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">找到此类：org.springframework.cloud.netflix.eureka.EurekaDiscoveryClientConfiguration中的注解@ConditionalOnClass(EurekaClientConfig.class)，</span><br></pre></td></tr></table></figure>
</li>
<li><p>EurekaClientConfig介绍</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">点击进去查看EurekaClientConfig是个接口，查看其实现类EurekaClientConfigBean。此类里封装了Eureka Client和Eureka Server交互所需要的配置信息。看此类代码：</span><br><span class="line"></span><br><span class="line">  public static final String PREFIX = <span class="string">"eureka.client"</span>;</span><br><span class="line">     表示在配置文件中用eureka.client.属性名配置。</span><br></pre></td></tr></table></figure>
</li>
<li><p>Eureka 实例相关配置</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">从org.springframework.cloud.client.discovery.DiscoveryClient顶级接口入手，前面介绍过spring common。看其在Eureka中的实现类org.springframework.cloud.netflix.eureka.EurekaDiscoveryClient。有一个属性：</span><br><span class="line"> private final EurekaClient eurekaClient，查看其实现类：com.netflix.discovery.DiscoveryClient。</span><br><span class="line">有一个属性：</span><br><span class="line"> private final ApplicationInfoManager applicationInfoManager（应用信息管理器，点进去此类，发现此类总有两个属性:</span><br><span class="line"> private InstanceInfo instanceInfo;</span><br><span class="line">private EurekaInstanceConfig config;</span><br><span class="line"> 服务实例的信息类InstanceInfo和服务实例配置信息类EurekaInstanceConfig）。</span><br></pre></td></tr></table></figure>
</li>
<li><p>InstanceInfo介绍</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">打开InstanceInfo里面有instanceId等服务实例信息。</span><br><span class="line"> InstanceInfo封装了将被发送到Eureka Server进行注册的服务实例元数据。它在Eureka Server列表中代表一个服务实例，其他服务可以通过instanceInfo了解到该服务的实例相关信息，包括地址等，从而发起请求。</span><br></pre></td></tr></table></figure>
</li>
<li><p>EurekaInstanceConfig介绍</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EurekaInstanceConfig是个接口，找到它的实现类org.springframework.cloud.netflix.eureka.EurekaInstanceConfigBean。</span><br><span class="line"> 此类封装了EurekaClient自身服务实例的配置信息，主要用于构建InstanceInfo。看到此类有一段代码：@ConfigurationProperties(<span class="string">"eureka.instance"</span>)，</span><br><span class="line"> 在配置文件中用eureka.instance.属性配置。EurekaInstanceConfigBean提供了默认值。</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过EurekaInstanceConfig构建instanceInfo</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在ApplicationInfoManager中有一个方法</span><br><span class="line">public void initComponent(EurekaInstanceConfig config)中有一句：</span><br><span class="line">this.instanceInfo &#x3D; new EurekaConfigBasedInstanceInfoProvider(config).get();</span><br><span class="line">通过EurekaInstanceConfig构造instanceInfo。</span><br></pre></td></tr></table></figure>
</li>
<li><p>顶级接口DiscoveryClient介绍</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">介绍一下spring-cloud-commons-2.2.1.realease包下，org.springframework.cloud.client.discovery.DiscoveryClient接口。定义用来服务发现的客户端接口，是客户端进行服务发现的核心接口，是spring cloud用来进行服务发现的顶级接口，在common中可以看到其地位。在Netflix Eureka和Consul中都有具体的实现类。</span><br><span class="line">org.springframework.cloud.client.discovery.DiscoveryClient的类注释:</span><br><span class="line">	Represents read operations commonly available to discovery services such as Netflix Eureka or consul.io。</span><br><span class="line">	代表通用于服务发现的读操作，例如在 eureka或consul中。</span><br><span class="line">	有</span><br><span class="line">	String description();&#x2F;&#x2F;获取实现类的描述。</span><br><span class="line">	List&lt;String&gt; getServices();&#x2F;&#x2F;获取所有服务实例id。</span><br><span class="line">	List&lt;ServiceInstance&gt; getInstances(String serviceId);&#x2F;&#x2F;通过服务id查询服务实例信息列表。</span><br></pre></td></tr></table></figure>
</li>
<li><p>Eureka 的实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">接下来我们找Eureka的实现类。org.springframework.cloud.netflix.eureka.EurekaDiscoveryClient。</span><br><span class="line">查看方法。</span><br><span class="line">public List&lt;ServiceInstance&gt; getInstances(String serviceId)，</span><br><span class="line">组合了com.netflix.discovery.EurekaClient来实现。</span><br></pre></td></tr></table></figure>
</li>
<li><p>EurekaClient的实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EurekaClient有一个注解@ImplementedBy(DiscoveryClient.class)，此类的默认实现类：com.netflix.discovery.DiscoveryClient。提供了:</span><br><span class="line">服务注册到server方法register().</span><br><span class="line">续约boolean renew().</span><br><span class="line">下线public synchronized void shutdown().</span><br><span class="line">查询服务列表 功能。</span><br><span class="line">想想前面的图中client的功能。提供了于Eureka Server交互的关键逻辑。</span><br></pre></td></tr></table></figure>
</li>
<li><p>com.netflix.discovery.DiscoveryClient</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.netflix.discovery.DiscoveryClient实现了EurekaClient（继承了LookupService）</span><br></pre></td></tr></table></figure>
</li>
<li><p>com.netflix.discovery.shared.LookupService</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">LookupService作用：发现活跃的服务实例。</span><br><span class="line">根据服务实例注册的appName来获取封装有相同appName的服务实例信息容器： </span><br><span class="line">Application getApplication(String appName)。</span><br><span class="line">获取所有的服务实例信息：</span><br><span class="line">Applications getApplications();</span><br><span class="line">根据实例id，获取服务实例信息：</span><br><span class="line">List&lt;InstanceInfo&gt; getInstancesById(String id);</span><br><span class="line"></span><br><span class="line">上面提到一个Application，它持有服务实例信息列表。它是同一个服务的集群信息。比如api-passenger的所有服务信息，这些服务都在api-passenger服务名下面。</span><br><span class="line"></span><br><span class="line">而instanceInfo代表一个服务实例的信息。为了保证原子性，比如对某个instanceInfo的操作，使用了大量同步的代码。比如下面代码：</span><br><span class="line">public void addInstance(InstanceInfo i) &#123;</span><br><span class="line">	instancesMap.put(i.getId(), i);</span><br><span class="line">	synchronized (instances) &#123;</span><br><span class="line">		instances.remove(i);</span><br><span class="line">		instances.add(i);</span><br><span class="line">		isDirty &#x3D; true;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Applications是注册表中，所有服务实例信息的集合。</span><br></pre></td></tr></table></figure>
</li>
<li><p>健康检测器和事件监听器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">EurekaClient在LookupService上做了扩充。提供了更丰富的获取服务实例的方法。按住不表。我们看一下另外两个方法：</span><br><span class="line"></span><br><span class="line">public void registerHealthCheck(HealthCheckHandler healthCheckHandler),向client注册 健康检查处理器，client存在一个定时任务通过HealthCheckHandler检查当前client状态，当client状态发生变化时，将会触发新的注册事件，去更新eureka server的注册表中的服务实例信息。</span><br><span class="line">通过HealthCheckHandler 实现应用状态检测。HealthCheckHandler的实现类org.springframework.cloud.netflix.eureka.EurekaHealthCheckHandler，看其构造函数：</span><br><span class="line">public EurekaHealthCheckHandler(HealthAggregator healthAggregator) &#123;</span><br><span class="line">		Assert.notNull(healthAggregator, &quot;HealthAggregator must not be null&quot;);</span><br><span class="line">		this.healthIndicator &#x3D; new CompositeHealthIndicator(healthAggregator);</span><br><span class="line">&#125;</span><br><span class="line">private final CompositeHealthIndicator healthIndicator;此类事属于org.springframework.boot.actuate.health包下，可以得出，是通过actuator来实现对应用的检测的。</span><br><span class="line"></span><br><span class="line">public void registerEventListener(EurekaEventListener eventListener)注册事件监听器，当实例信息有变时，触发对应的处理事件。</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>找到com.netflix.discovery.DiscoveryClient</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">在api-listen-order项目中，找到spring-cloud-netflix-eureka-client-2.1.2.RELEASE下META-INF下spring.factories。此文件中org.springframework.cloud.bootstrap.BootstrapConfiguration&#x3D;\</span><br><span class="line">org.springframework.cloud.netflix.eureka.config.EurekaDiscoveryClientConfigServiceBootstrapConfiguration，此类有个注解：</span><br><span class="line">@Import(&#123; EurekaDiscoveryClientConfiguration.class, &#x2F;&#x2F; this emulates</span><br><span class="line">		&#x2F;&#x2F; @EnableDiscoveryClient, the import</span><br><span class="line">		&#x2F;&#x2F; selector doesn&#39;t run before the</span><br><span class="line">		&#x2F;&#x2F; bootstrap phase</span><br><span class="line">		EurekaClientAutoConfiguration.class &#125;)</span><br><span class="line">注解中有个类：	EurekaClientAutoConfiguration，此类中有如下代码：</span><br><span class="line">CloudEurekaClient cloudEurekaClient &#x3D; new CloudEurekaClient(appManager,</span><br><span class="line">					config, this.optionalArgs, this.context);</span><br><span class="line">（debug可以调试到）</span><br><span class="line">通过CloudEurekaClient找到：public class CloudEurekaClient extends DiscoveryClient。</span><br></pre></td></tr></table></figure>
</li>
<li><p>com.netflix.discovery.DiscoveryClient构造函数-不注册不拉取</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">DiscoveryClient的构造函数：</span><br><span class="line">DiscoveryClient(ApplicationInfoManager applicationInfoManager, EurekaClientConfig config, AbstractDiscoveryClientOptionalArgs args,Provider&lt;BackupRegistry&gt; backupRegistryProvider, EndpointRandomizer endpointRandomizer) </span><br><span class="line">此方法中依次执行了 从eureka server中拉取注册表，服务注册，初始化发送心跳，缓存刷新（定时拉取注册表信息），按需注册定时任务等，贯穿了Eureka Client启动阶段的各项工作。</span><br><span class="line"></span><br><span class="line">构造函数353行：</span><br><span class="line">if (config.shouldFetchRegistry()) &#123;</span><br><span class="line">  	this.registryStalenessMonitor &#x3D; new ThresholdLevelsMetric(this, METRIC_REGISTRY_PREFIX + &quot;lastUpdateSec_&quot;, new long[]&#123;15L, 30L, 60L, 120L, 240L, 480L&#125;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  	this.registryStalenessMonitor &#x3D; ThresholdLevelsMetric.NO_OP_METRIC;</span><br><span class="line">&#125;</span><br><span class="line">  shouldFetchRegistry，点其实现类EurekaClientConfigBean，找到它其实对应于：eureka.client.fetch-register，true：表示client从server拉取注册表信息。</span><br><span class="line"></span><br><span class="line">下面：</span><br><span class="line">if (config.shouldRegisterWithEureka()) &#123;</span><br><span class="line">  	this.heartbeatStalenessMonitor &#x3D; new ThresholdLevelsMetric(this, METRIC_REGISTRATION_PREFIX + &quot;lastHeartbeatSec_&quot;, new long[]&#123;15L, 30L, 60L, 120L, 240L, 480L&#125;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  	this.heartbeatStalenessMonitor &#x3D; ThresholdLevelsMetric.NO_OP_METRIC;</span><br><span class="line">&#125;</span><br><span class="line">  shouldRegisterWithEureka，点其实现类EurekaClientConfigBean，找到它其实对应于：</span><br><span class="line">  eureka.client.register-with-eureka：true：表示client将注册到server。</span><br><span class="line"></span><br><span class="line">  if (!config.shouldRegisterWithEureka() &amp;&amp; !config.shouldFetchRegistry()) &#123;</span><br><span class="line">  如果以上两个都为false，则直接返回，构造方法执行结束，既不服务注册，也不服务发现。</span><br></pre></td></tr></table></figure>
</li>
<li><p>com.netflix.discovery.DiscoveryClient构造函数-两个定时任务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">顺着上面代码往下看：</span><br><span class="line">  scheduler &#x3D; Executors.newScheduledThreadPool(2,</span><br><span class="line">                      new ThreadFactoryBuilder()</span><br><span class="line">                              .setNameFormat(&quot;DiscoveryClient-%d&quot;)</span><br><span class="line">                              .setDaemon(true)</span><br><span class="line">                              .build());</span><br><span class="line">  定义了一个基于线程池的定时器线程池，大小为2。</span><br><span class="line">  往下：</span><br><span class="line">  heartbeatExecutor：用于发送心跳，</span><br><span class="line">  cacheRefreshExecutor：用于刷新缓存。</span><br></pre></td></tr></table></figure>
</li>
<li><p>com.netflix.discovery.DiscoveryClient构造函数-client和server交互的Jersey客户端</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">接着构建eurekaTransport &#x3D; new EurekaTransport();它是eureka Client和eureka server进行http交互jersey客户端。点开EurekaTransport，看到许多httpclient相关的属性。</span><br></pre></td></tr></table></figure>
</li>
<li><p>com.netflix.discovery.DiscoveryClient构造函数-拉取注册信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (clientConfig.shouldFetchRegistry() &amp;&amp; !fetchRegistry(false)) &#123;</span><br><span class="line">            fetchRegistryFromBackup();</span><br><span class="line">&#125;</span><br><span class="line">如果判断的前部分为true，执行后半部分fetchRegistry。此时会从eureka server拉取注册表中的信息，将注册表缓存到本地，可以就近获取其他服务信息，减少于server的交互。</span><br></pre></td></tr></table></figure>
</li>
<li><p>com.netflix.discovery.DiscoveryClient构造函数-服务注册</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">if (clientConfig.shouldRegisterWithEureka() &amp;&amp; clientConfig.shouldEnforceRegistrationAtInit()) &#123;</span><br><span class="line">             try &#123;</span><br><span class="line">                 if (!register() ) &#123;</span><br><span class="line">                     throw new IllegalStateException(&quot;Registration error at startup. Invalid server response.&quot;);</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125; catch (Throwable th) &#123;</span><br><span class="line">                 logger.error(&quot;Registration error at startup: &#123;&#125;&quot;, th.getMessage());</span><br><span class="line">                 throw new IllegalStateException(th);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;注册失败抛异常。</span><br></pre></td></tr></table></figure>
</li>
<li><p>com.netflix.discovery.DiscoveryClient构造函数-启动定时任务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在构造方法的最后initScheduledTasks();此方法中，启动3个定时任务。方法内有statusChangeListener，按需注册是一个事件StatusChangeEvent，状态改变，则向server注册。</span><br></pre></td></tr></table></figure>
</li>
<li><p>com.netflix.discovery.DiscoveryClient构造函数-总结</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">总结DiscoveryClient构造关键过程：</span><br><span class="line">  初始化一堆信息。</span><br><span class="line">  从拉取注册表信息。</span><br><span class="line">  向server注册自己。</span><br><span class="line">  初始化3个任务。</span><br><span class="line">  详细后面继续讲。源码就是这样，得层层拨开。</span><br></pre></td></tr></table></figure>
</li>
<li><p>拉取注册表信息详解</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">上面的fetchRegistry(false)，点进去，看注释：</span><br><span class="line">  &#x2F;&#x2F; If the delta is disabled or if it is the first time, get all  applications。</span><br><span class="line">  如果增量式拉取被禁止或第一次拉取注册表，则进行全量拉取：getAndStoreFullRegistry()。</span><br><span class="line">  否则进行增量拉取注册表信息getAndUpdateDelta(applications)。</span><br><span class="line">  一般情况，在Eureka client第一次启动，会进行全量拉取。之后的拉取都尽量尝试只进行增量拉取。</span><br><span class="line"></span><br><span class="line">  拉取服务注册表：</span><br><span class="line">  全量拉取：getAndStoreFullRegistry();</span><br><span class="line">  增量拉取：getAndUpdateDelta(applications);</span><br></pre></td></tr></table></figure>
</li>
<li><p>全量拉取</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">进入getAndStoreFullRegistry() 方法，有一方法：eurekaTransport.queryClient.getApplications。</span><br><span class="line">  通过debug发现 实现类是AbstractJerseyEurekaHttpClient，点开，debug出 </span><br><span class="line">  webResource地址为：http:&#x2F;&#x2F;root:root@eureka-7900:7900&#x2F;eureka&#x2F;apps&#x2F;，此端点用于获取server中所有的注册表信息。</span><br><span class="line">  getAndStoreFullRegistry()可能被多个线程同时调用，导致新拉取的注册表被旧的覆盖(如果新拉取的动作设置apps阻塞的情况下）。</span><br><span class="line">  此时用了AutomicLong来进行版本管理，如果更新时版本不一致，不保存apps。</span><br><span class="line">  通过这个判断fetchRegistryGeneration.compareAndSet(currentUpdateGeneration, currentUpdateGeneration + 1)，如果版本一致，并设置新版本（+1），</span><br><span class="line">  接着执行localRegionApps.set(this.filterAndShuffle(apps));过滤并洗牌apps。点开this.filterAndShuffle(apps)实现，继续点apps.shuffleAndIndexInstances，继续点shuffleInstances，继续点application.shuffleAndStoreInstances，继续点_shuffleAndStoreInstances，发现if (filterUpInstances &amp;&amp; InstanceStatus.UP !&#x3D; instanceInfo.getStatus())。只保留状态为UP的服务。</span><br></pre></td></tr></table></figure>
</li>
<li><p>增量拉取</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">回到刚才的fetchRegistry方法中，getAndUpdateDelta，增量拉取。通过getDelta方法，看到实际拉取的地址是：apps&#x2F;delta，如果获取到的delta为空，则全量拉取。</span><br><span class="line">  通常来讲是3分钟之内注册表的信息变化（在server端判断），获取到delta后，会更新本地注册表。</span><br><span class="line">  增量式拉取是为了维护client和server端 注册表的一致性，防止本地数据过久，而失效，采用增量式拉取的方式，减少了client和server的通信量。</span><br><span class="line">  client有一个注册表缓存刷新定时器，专门负责维护两者之间的信息同步，但是当增量出现意外时，定时器将执行，全量拉取以更新本地缓存信息。更新本地注册表方法updateDelta，有一个细节。</span><br><span class="line">  if (ActionType.ADDED.equals(instance.getActionType())) ，public enum ActionType &#123;</span><br><span class="line">          ADDED, &#x2F;&#x2F; Added in the discovery server</span><br><span class="line">          MODIFIED, &#x2F;&#x2F; Changed in the discovery server</span><br><span class="line">          DELETED</span><br><span class="line">          &#x2F;&#x2F; Deleted from the discovery server</span><br><span class="line">      &#125;，</span><br><span class="line">  在InstanceInfo instance中有一个instance.getActionType()，ADDED和MODIFIED状态的将更新本地注册表applications.addApplication，DELETED将从本地剔除掉existingApp.removeInstance(instance)。</span><br></pre></td></tr></table></figure>
</li>
<li><p>服务注册</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">好了拉取完eureka server中的注册表了，接着进行服务注册。回到DiscoveryClient构造函数。</span><br><span class="line">  拉取fetchRegistry完后进行register注册。由于构造函数开始时已经将服务实例元数据封装好了instanceInfo，所以此处之间向server发送instanceInfo，</span><br><span class="line">  通过方法httpResponse &#x3D; eurekaTransport.registrationClient.register(instanceInfo);看到String urlPath &#x3D; &quot;apps&#x2F;&quot; + info.getAppName();又是一个server端点，退上去f7，httpResponse.getStatusCode() &#x3D;&#x3D; Status.NO_CONTENT.getStatusCode();204状态码，则注册成功。</span><br></pre></td></tr></table></figure>
</li>
<li><p>初始化3个定时任务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line">接着</span><br><span class="line">  &#x2F;&#x2F; finally, init the schedule tasks (e.g. cluster resolvers, heartbeat, instanceInfo replicator, fetch</span><br><span class="line">  initScheduledTasks();看注释初始化3个定时任务。</span><br><span class="line">  题外话：</span><br><span class="line">  client会定时向server发送心跳，维持自己服务租约的有效性，用心跳定时任务实现;</span><br><span class="line">  而server中会有不同的服务实例注册进来，一进一出，就需要数据的同步。所以client需要定时从server拉取注册表信息，用缓存定时任务实现;</span><br><span class="line">  client如果有变化，也会及时更新server中自己的信息，用按需注册定时任务实现。</span><br><span class="line"></span><br><span class="line">  就是这三个定时任务。	</span><br><span class="line"></span><br><span class="line">进 initScheduledTasks()方法中，clientConfig.shouldFetchRegistry()，</span><br><span class="line">从server拉取注册表信息。</span><br><span class="line">int registryFetchIntervalSeconds &#x3D; clientConfig.getRegistryFetchIntervalSeconds()拉取的时间间隔，eureka.client.registry-fetch-interval-seconds进行设置。</span><br><span class="line"></span><br><span class="line">int renewalIntervalInSecs &#x3D; nstanceInfo.getLeaseInfo().getRenewalIntervalInSecs();心跳定时器，默认30秒。</span><br><span class="line"></span><br><span class="line">心跳定时任务和缓存刷新定时任务是有scheduler 的 schedule提交的，鼠标放到scheduler上，看到一句话 A scheduler to be used for the following 3 tasks:- updating service urls- scheduling a TimedSuperVisorTask。</span><br><span class="line">知道循环逻辑是由TimedSuperVisorTask实现的。</span><br><span class="line">  new TimedSupervisorTask(</span><br><span class="line">                              &quot;heartbeat&quot;,</span><br><span class="line">                              scheduler,</span><br><span class="line">                              heartbeatExecutor,</span><br><span class="line">                              renewalIntervalInSecs,</span><br><span class="line">                              TimeUnit.SECONDS,</span><br><span class="line">                              expBackOffBound,</span><br><span class="line">                              new HeartbeatThread()看到HeartbeatThread线程。</span><br><span class="line">点进去public void run() &#123;</span><br><span class="line">              if (renew()) &#123;</span><br><span class="line">                  lastSuccessfulHeartbeatTimestamp &#x3D; System.currentTimeMillis();</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">  里面是renew（）方法。</span><br><span class="line">  </span><br><span class="line">  scheduler.schedule(</span><br><span class="line">                      new TimedSupervisorTask(</span><br><span class="line">                              &quot;cacheRefresh&quot;,</span><br><span class="line">                              scheduler,</span><br><span class="line">                              cacheRefreshExecutor,</span><br><span class="line">                              registryFetchIntervalSeconds,</span><br><span class="line">                              TimeUnit.SECONDS,</span><br><span class="line">                              expBackOffBound,</span><br><span class="line">                              new CacheRefreshThread()</span><br><span class="line">                      ),</span><br><span class="line">  看到CacheRefreshThread，进去，发现 class CacheRefreshThread implements Runnable &#123;</span><br><span class="line">          public void run() &#123;</span><br><span class="line">              refreshRegistry();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;是用的refreshRegistry，进去发现fetchRegistry。回到原来讲过的地方。</span><br><span class="line">      </span><br><span class="line">  boolean renew() &#123;</span><br><span class="line">          EurekaHttpResponse&lt;InstanceInfo&gt; httpResponse;</span><br><span class="line">          try &#123;</span><br><span class="line">              httpResponse &#x3D; eurekaTransport.registrationClient.sendHeartBeat(instanceInfo.getAppName(), instanceInfo.getId(), instanceInfo, null);</span><br><span class="line">              logger.debug(PREFIX + &quot;&#123;&#125; - Heartbeat status: &#123;&#125;&quot;, appPathIdentifier, httpResponse.getStatusCode());</span><br><span class="line">              if (httpResponse.getStatusCode() &#x3D;&#x3D; Status.NOT_FOUND.getStatusCode()) &#123;</span><br><span class="line">                  REREGISTER_COUNTER.increment();</span><br><span class="line">                  logger.info(PREFIX + &quot;&#123;&#125; - Re-registering apps&#x2F;&#123;&#125;&quot;, appPathIdentifier, instanceInfo.getAppName());</span><br><span class="line">                  long timestamp &#x3D; instanceInfo.setIsDirtyWithTime();</span><br><span class="line">                  boolean success &#x3D; register();</span><br><span class="line">                  if (success) &#123;</span><br><span class="line">                      instanceInfo.unsetIsDirty(timestamp);</span><br><span class="line">                  &#125;</span><br><span class="line">                  return success;</span><br><span class="line">              &#125;</span><br><span class="line">              return httpResponse.getStatusCode() &#x3D;&#x3D; Status.OK.getStatusCode();</span><br><span class="line">          &#125; catch (Throwable e) &#123;</span><br><span class="line">              logger.error(PREFIX + &quot;&#123;&#125; - was unable to send heartbeat!&quot;, appPathIdentifier, e);</span><br><span class="line">              return false;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;看到如果遇到404，server没有此实例，则重新发起注册。如果续约成功返回 200.</span><br><span class="line">      点sendHeartBeat进去String urlPath &#x3D; &quot;apps&#x2F;&quot; + appName + &#39;&#x2F;&#39; + id;</span><br><span class="line">      </span><br><span class="line">还有一个定时任务，按需注册。当instanceinfo和status发生变化时，需要向server同步，去更新自己在server中的实例信息。保证server注册表中服务实例信息的有效和可用。</span><br><span class="line">  &#x2F;&#x2F; InstanceInfo replicator</span><br><span class="line">          instanceInfoReplicator &#x3D; new InstanceInfoReplicator(</span><br><span class="line">                  this,</span><br><span class="line">                  instanceInfo,</span><br><span class="line">                  clientConfig.getInstanceInfoReplicationIntervalSeconds(),</span><br><span class="line">                  2); &#x2F;&#x2F; burstSize</span><br><span class="line">  </span><br><span class="line">          statusChangeListener &#x3D; new ApplicationInfoManager.StatusChangeListener() &#123;</span><br><span class="line">              @Override</span><br><span class="line">              public String getId() &#123;</span><br><span class="line">                  return &quot;statusChangeListener&quot;;</span><br><span class="line">              &#125;</span><br><span class="line">  </span><br><span class="line">           @Override</span><br><span class="line">              public void notify(StatusChangeEvent statusChangeEvent) &#123;</span><br><span class="line">                  if (InstanceStatus.DOWN &#x3D;&#x3D; statusChangeEvent.getStatus() ||</span><br><span class="line">                          InstanceStatus.DOWN &#x3D;&#x3D; statusChangeEvent.getPreviousStatus()) &#123;</span><br><span class="line">                      &#x2F;&#x2F; log at warn level if DOWN was involved</span><br><span class="line">                      logger.warn(&quot;Saw local status change event &#123;&#125;&quot;, statusChangeEvent);</span><br><span class="line">                  &#125; else &#123;</span><br><span class="line">                      logger.info(&quot;Saw local status change event &#123;&#125;&quot;, statusChangeEvent);</span><br><span class="line">                  &#125;</span><br><span class="line">                  instanceInfoReplicator.onDemandUpdate();</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;;</span><br><span class="line">          if (clientConfig.shouldOnDemandUpdateStatusChange()) &#123;</span><br><span class="line">              applicationInfoManager.registerStatusChangeListener(statusChangeListener);</span><br><span class="line">          &#125;</span><br><span class="line">      instanceInfoReplicator.start(clientConfig.getInitialInstanceInfoReplicationIntervalSeconds());    </span><br><span class="line">      </span><br><span class="line">此定时任务有2个部分，</span><br><span class="line">  1：定时刷新服务实例信息和检查应用状态的变化，在服务实例信息发生改变的情况下向server重新发起注册。InstanceInfoReplicator点进去。看到一个方法    </span><br><span class="line">  public void run() &#123;</span><br><span class="line">          try &#123;</span><br><span class="line">              discoveryClient.refreshInstanceInfo();&#x2F;&#x2F;刷新instanceinfo。</span><br><span class="line">  			&#x2F;&#x2F;如果实例信息有变，返回数据更新时间。</span><br><span class="line">              Long dirtyTimestamp &#x3D; instanceInfo.isDirtyWithTime();</span><br><span class="line">              if (dirtyTimestamp !&#x3D; null) &#123;</span><br><span class="line">                  discoveryClient.register();&#x2F;&#x2F;注册服务实例。</span><br><span class="line">                  instanceInfo.unsetIsDirty(dirtyTimestamp);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125; catch (Throwable t) &#123;</span><br><span class="line">              logger.warn(&quot;There was a problem with the instance info replicator&quot;, t);</span><br><span class="line">          &#125; finally &#123;</span><br><span class="line">          &#x2F;&#x2F;延时执行下一个检查任务。用于再次调用run方法，继续检查服务实例信息和状态的变化。</span><br><span class="line">              Future next &#x3D; scheduler.schedule(this, replicationIntervalSeconds, TimeUnit.SECONDS);</span><br><span class="line">              scheduledPeriodicRef.set(next);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;      </span><br><span class="line"></span><br><span class="line">refreshInstanceInfo点进去，看方法注释：如果有变化，在下次心跳时，同步向server。</span><br><span class="line"></span><br><span class="line">2.注册状态改变监听器，在应用状态发生变化时，刷新服务实例信息，在服务实例信息发生改变时向server注册。  看这段            </span><br><span class="line">   statusChangeListener &#x3D; new ApplicationInfoManager.StatusChangeListener() &#123;</span><br><span class="line">                  @Override</span><br><span class="line">                  public String getId() &#123;</span><br><span class="line">                      return &quot;statusChangeListener&quot;;</span><br><span class="line">                  &#125;</span><br><span class="line"> @Override</span><br><span class="line">              public void notify(StatusChangeEvent statusChangeEvent) &#123;</span><br><span class="line">                  if (InstanceStatus.DOWN &#x3D;&#x3D; statusChangeEvent.getStatus() ||</span><br><span class="line">                          InstanceStatus.DOWN &#x3D;&#x3D; statusChangeEvent.getPreviousStatus()) &#123;</span><br><span class="line">                      &#x2F;&#x2F; log at warn level if DOWN was involved</span><br><span class="line">                      logger.warn(&quot;Saw local status change event &#123;&#125;&quot;, statusChangeEvent);</span><br><span class="line">                  &#125; else &#123;</span><br><span class="line">                      logger.info(&quot;Saw local status change event &#123;&#125;&quot;, statusChangeEvent);</span><br><span class="line">                  &#125;</span><br><span class="line">                  instanceInfoReplicator.onDemandUpdate();</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;;如果状态发生改变，调用onDemandUpdate（），点onDemandUpdate进去，看到InstanceInfoReplicator.this.run();     </span><br><span class="line">          </span><br><span class="line">总结：两部分，一部分自己去检查，一部分等待状态监听事件。</span><br><span class="line"></span><br><span class="line">初始化定时任务完成，最后一步启动步骤完成。接下来就是正常服务于业务。然后消亡。</span><br></pre></td></tr></table></figure>

</li>
</ul>
<ul>
<li><p>服务下线</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">服务下线：在应用关闭时，client会向server注销自己，在Discoveryclient销毁前，会执行下面清理方法。 </span><br><span class="line">@PreDestroy</span><br><span class="line">@Override</span><br><span class="line">public synchronized void shutdown() ，看此方法上有一个注解，表示：在销毁前执行此方法。unregisterStatusChangeListener注销监听器。cancelScheduledTasks取消定时任务。unregister服务下线。eurekaTransport.shutdown关闭jersy客户端 等。</span><br><span class="line"></span><br><span class="line">unregister点进去。cancel点进去。AbstractJerseyEurekaHttpClient。String urlPath &#x3D; &quot;apps&#x2F;&quot; + appName + &#39;&#x2F;&#39; + id;看到url和http请求delete方法。</span><br></pre></td></tr></table></figure>

<ul>
<li><p>client源码总结</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">总结：源码其实两部分内容：</span><br><span class="line">1、client自身的操作。</span><br><span class="line">2、server的配合。（https:&#x2F;&#x2F;github.com&#x2F;Netflix&#x2F;eureka&#x2F;wiki&#x2F;Eureka-REST-operations）。</span><br><span class="line">  一切尽在：《Eureka Client工作流程图》</span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ul>
<h2 id="9-Eureka-Server源码"><a href="#9-Eureka-Server源码" class="headerlink" title="9 Eureka Server源码"></a>9 Eureka Server源码</h2><ol>
<li><p>Eureka Server功能复习</p>
<p>接受服务注册<br>接受服务心跳<br>服务剔除<br>服务下线<br>集群同步<br>获取注册表中服务实例信息</p>
</li>
</ol>
<p>   需要注意的是，Eureka Server同时也是一个Eureka Client，在不禁止Eureka Server的客户端行为时，它会向它配置文件中的其他Eureka Server进行拉取注册表、服务注册和发送心跳等操作。</p>
<ol start="2">
<li><p>源码解读</p>
<ul>
<li><p>启动server注册相关bean</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">注册外部的配置类</span><br><span class="line">spring-cloud-netflix-eureka-server-2.1.2.REALEASE.jar</span><br><span class="line">中</span><br><span class="line">META-INF&#x2F;spring.factories</span><br><span class="line">中</span><br><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration&#x3D;\</span><br><span class="line">  org.springframework.cloud.netflix.eureka.server.EurekaServerAutoConfiguration</span><br><span class="line">启动时会自动加载：EurekaServerAutoConfiguration</span><br><span class="line">功能：向spring的bean工厂添加eureka-server相关功能的bean。</span><br><span class="line"> </span><br><span class="line">但是EurekaServerAutoConfiguration的生效时有条件的。</span><br><span class="line"> EurekaServerAutoConfiguration上有一个注解：@ConditionalOnBean(EurekaServerMarkerConfiguration.Marker.class)，意思是：只有在Spring容器里有Marker这个类的实例时，才会加载EurekaServerAutoConfiguration，这个就是控制是否开启Eureka Server的关键。</span><br></pre></td></tr></table></figure>
</li>
<li><p>开启eureka server</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> 开关：</span><br><span class="line">而在@EnableEurekaServer中，@Import(EurekaServerMarkerConfiguration.class)，意思是：动态注入此bean到spring 容器。引入了EurekaServerMarkerConfiguration.class。所以开启了Server服务。所以注册了前面说的：EurekaServerAutoConfiguration</span><br></pre></td></tr></table></figure>
</li>
<li><p>开启注册</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在EurekaServerMarkerConfiguration上有@Import(EurekaServerInitializerConfiguration.class)，导入了EurekaServerInitializerConfiguration，</span><br><span class="line">EurekaServerInitializerConfiguration</span><br><span class="line">		implements ServletContextAware, SmartLifecycle，SmartLifecycle的作用是：初始化完之后，</span><br><span class="line">执行public void start()方法。</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>在public void start()中，启动一个线程。看注释：log.info(“Started Eureka Server”);发布事件：publish(new EurekaRegistryAvailableEvent(getEurekaServerConfig()))，<br>  告诉client，可以来注册了。</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">上面提到的 log.info(&quot;Started Eureka Server&quot;) 的上面一行。eurekaServerBootstrap.contextInitialized(EurekaServerInitializerConfiguration.this.servletContext);</span><br><span class="line">点contextInitialized进去，看到initEurekaServerContext，初始化eureka 上下文，点initEurekaServerContext进去，看到		</span><br><span class="line">		&#x2F;&#x2F; Copy registry from neighboring eureka node</span><br><span class="line">		int registryCount &#x3D; this.registry.syncUp();从相邻的eureka 节点复制注册表，</span><br><span class="line">下一行openForTraffic（主要是和client 交换信息，traffic），查看实现，PeerAwareInstanceRegistryImpl，开启任务postInit，进去之后发现剔除功能（剔除 没有续约的服务）。postInit，点进去，发现new EvictionTask()，点进去，看到run方法中，evict(compensationTimeMs)，点进去就到了，具体剔除逻辑，下面剔除的时候讲。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- PeerAwareInstanceRegistry接口</span><br></pre></td></tr></table></figure>

<p>  在EurekaServerAutoConfiguration中 有 public EurekaServerContext eurekaServerContext，中有DefaultEurekaServerContext，点进去找到<br>      @PostConstruct<br>      @Override<br>      public void initialize() {<br>          logger.info(“Initializing …”);<br>       peerEurekaNodes.start();<br>          try {<br>           registry.init(peerEurekaNodes);<br>          } catch (Exception e) {<br>              throw new RuntimeException(e);<br>          }<br>          logger.info(“Initialized”);<br>      }，其中peerEurekaNodes.start();启动一个只拥有一个线程的线程池，第一次进去会更新一下集群其他节点信息。registry.init(peerEurekaNodes);鼠标放在registry上，发现是PeerAwareInstanceRegistryImpl ， 的 注册信息管理类里面的init方法。PeerAwareInstanceRegistry是个接口，实现类是：PeerAwareInstanceRegistryImpl。PeerAwareInstanceRegistry接口，实现了com.netflix.eureka.registry.InstanceRegistry。    </p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- 服务实例注册表</span><br></pre></td></tr></table></figure>

<p>  Server是围绕注册表管理的。有两个InstanceRegistry。<br>  com.netflix.eureka.registry.InstanceRegistry是euraka server中注册表管理的核心接口。职责是在内存中管理注册到Eureka Server中的服务实例信息。实现类有PeerAwareInstanceRegistryImpl。</p>
<p>  org.springframework.cloud.netflix.eureka.server.InstanceRegistry对PeerAwareInstanceRegistryImpl进行了继承和扩展，使其适配Spring cloud的使用环境，主要的实现由PeerAwareInstanceRegistryImpl提供。</p>
<p>  com.netflix.eureka.registry.InstanceRegistry extends LeaseManager<InstanceInfo>, LookupService<String> 。LeaseManager<InstanceInfo>是对注册到server中的服务实例租约进行管理。LookupService<String>是提供服务实例的检索查询功能。</String></InstanceInfo></String></InstanceInfo></p>
<p>  LeaseManager<InstanceInfo>接口的作用是对注册到Eureka Server中的服务实例租约进行管理，方法有：服务注册，下线，续约，剔除。此接口管理的类目前是InstanceInfo。InstanceInfo代表服务实例信息。</InstanceInfo></p>
<p>  PeerAwareInstanceRegistryImpl 增加了对peer节点的同步复制操作。使得eureka server集群中注册表信息保持一致。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 接受服务注册</span><br><span class="line"></span><br><span class="line">  &gt; 《eureka服务端注册》</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/13/Eureka%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E8%AF%A6%E8%A7%A3/image-20200823173914337.png" alt="image-20200823173914337"></p>
<p>  我们学过Eureka Client在发起服务注册时会将自身的服务实例元数据封装在InstanceInfo中，然后将InstanceInfo发送到Eureka Server。Eureka Server在接收到Eureka Client发送的InstanceInfo后将会尝试将其放到本地注册表中以供其他Eureka Client进行服务发现。<br>  我们学过：通过 eureka/apps/{服务名}注册</p>
<p>  在EurekaServerAutoConfiguration中定义了 public FilterRegistrationBean jerseyFilterRegistration ，表名了 表明eureka-server使用了Jersey实现 对外的 restFull接口。注册一个 Jersey 的 filter ，配置好相应的Filter 和 url映射。</p>
<hr>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>public javax.ws.rs.core.Application jerseyApplication(方法：中。<br> provider.addIncludeFilter(new AnnotationTypeFilter(Path.class));<br>        provider.addIncludeFilter(new AnnotationTypeFilter(Provider.class));<br> 添加一些过滤器，类似于过滤请求地址，Path类似于@RequestMapping，Provider类似于@Controller        </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">------</span><br></pre></td></tr></table></figure>

<p> 在com.netflix.eureka.resources包下，是Eureka Server对于Eureka client的REST请求的定义。看ApplicationResource类（这是一类请求，应用类的请求），类似于应用@Controller注解：@Produces({“application/xml”, “application/json”})，接受xml和json。见名识意 public Response addInstance。添加实例instanceinfo。 方法中，有一句：<br> registry.register(info, “true”.equals(isReplication));鼠标放在registry上PeerAwareInstanceRegistry接口，点击void register方法。发现 是PeerAwareInstanceRegistryImpl 的方法：public void register(final InstanceInfo info, final boolean isReplication) ，中有一句：super.register(info, leaseDuration, isReplication);<br> 进入下面正题：<br> com.netflix.eureka.registry.AbstractInstanceRegistry<br> register方法</p>
<p> 在register中，服务实例的InstanceInfo保存在Lease中，Lease在AbstractInstanceRegistry中统一通过ConcurrentHashMap保存在内存中。在服务注册过程中，会先获取一个读锁，防止其他线程对registry注册表进行数据操作，避免数据的不一致。然后从resgitry查询对应的InstanceInfo租约是否已经存在注册表中，根据appName划分服务集群，使用InstanceId唯一标记服务实例。如果租约存在，比较两个租约中的InstanceInfo的最后更新时间lastDirtyTimestamp，保留时间戳大的服务实例信息InstanceInfo。如果租约不存在，意味这是一次全新的服务注册，将会进行自我保护的统计，创建新的租约保存InstanceInfo。接着将租约放到resgitry注册表中。<br> 之后将进行一系列缓存操作并根据覆盖状态规则设置服务实例的状态，缓存操作包括将InstanceInfo加入用于统计Eureka Client增量式获取注册表信息的recentlyChangedQueue和失效responseCache中对应的缓存。最后设置服务实例租约的上线时间用于计算租约的有效时间，释放读锁并完成服务注册。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     </span><br><span class="line"></span><br><span class="line">- 接受心跳 续租，renew</span><br><span class="line"></span><br><span class="line">  &gt; 《Eureka服务端接收心跳》</span><br></pre></td></tr></table></figure>

<img src="/2020/08/13/Eureka%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E8%AF%A6%E8%A7%A3/../../../只要学不死 就往死里学/note/网约车/online-taxi-file-master/二期/课程md/按组件区分/03-服务注册与发现/image-20200823173937080.png" alt="image-20200823173937080">

<p>  在Eureka Client完成服务注册之后，它需要定时向Eureka Server发送心跳请求(默认30秒一次)，维持自己在Eureka Server中租约的有效性。</p>
<p>  看另一类请求com.netflix.eureka.resources.InstanceResource。下public Response renewLease(方法。看到一行boolean isSuccess = registry.renew(app.getName(), id, isFromReplicaNode);<br>  点击renew的实现。<br>  进入下面正题：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Eureka Server处理心跳请求的核心逻辑位于AbstractInstanceRegistry#renew方法中。renew方法是对Eureka Client位于注册表中的租约的续租操作，不像register方法需要服务实例信息，仅根据服务实例的服务名和服务实例id即可更新对应租约的有效时间。<br> com.netflix.eureka.registry.AbstractInstanceRegistry<br>renew<br> //根据appName获取服务集群的租约集合<br>  Map&lt;String, Lease<InstanceInfo>&gt; gMap = registry.get(appName);<br>  //查看服务实例状态<br>   InstanceStatus overriddenInstanceStatus = this.getOverriddenInstanceStatus(<br>                         instanceInfo, leaseToRenew, isReplication);<br>                 if (overriddenInstanceStatus == InstanceStatus.UNKNOWN) {<br> //统计每分钟续租次数<br> renewsLastMin.increment();<br> //更新租约<br> leaseToRenew.renew();</InstanceInfo></p>
<p> 此方法中不关注InstanceInfo，仅关注于租约本身以及租约的服务实例状态。如果根据服务实例的appName和instanceInfoId查询出服务实例的租约，并且根据#getOverriddenInstanceStatus方法得到的instanceStatus不为InstanceStatus.UNKNOWN，那么更新租约中的有效时间，即更新租约Lease中的lastUpdateTimestamp，达到续约的目的；如果租约不存在，那么返回续租失败的结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- 服务剔除</span><br></pre></td></tr></table></figure>

<p>  如果Eureka Client在注册后，既没有续约，也没有下线(服务崩溃或者网络异常等原因)，那么服务的状态就处于不可知的状态，不能保证能够从该服务实例中获取到回馈，所以需要服务剔除此方法定时清理这些不稳定的服务，该方法会批量将注册表中所有过期租约剔除。</p>
<p>  剔除是定时任务，默认60秒执行一次。延时60秒，间隔60秒<br>          evictionTimer.schedule(evictionTaskRef.get(),<br>                  serverConfig.getEvictionIntervalTimerInMs(),<br>                  serverConfig.getEvictionIntervalTimerInMs());</p>
<p>  从上面eureka server启动来看，剔除的任务，是线程启动的，执行的是下面的方法。<br>  com.netflix.eureka.registry.AbstractInstanceRegistry<br>  evict</p>
<p>  判断是否开启自我保护<br>  if (!isLeaseExpirationEnabled()) {<br>  如果开启自我保护，不剔除。点进去isLeaseExpirationEnabled，查看实现类，有一个isSelfPreservationModeEnabled，点进去    @Override<br>      public boolean isSelfPreservationModeEnabled() {<br>          return serverConfig.shouldEnableSelfPreservation();<br>      }，发现EurekaServerConfig，的方法shouldEnableSelfPreservation，看其实现中有EurekaServerConfigBean，发现属性：enableSelfPreservation。</p>
<p>  紧接着一个大的for循环，便利注册表register，依次判断租约是否过期。一次性获取所有的过期租约。</p>
<p>  //获取注册表租约总数<br>  int registrySize = (int) getLocalRegistrySize();<br>  计算注册表租约的阈值 （总数乘以 续租百分比），得出要续租的数量<br>  int registrySizeThreshold = (int) (registrySize *    serverConfig.getRenewalPercentThreshold());</p>
<p>  总数减去要续租的数量，就是理论要剔除的数量<br>  int evictionLimit = registrySize - registrySizeThreshold;</p>
<p>  //求 上面理论剔除数量，和过期租约总数的最小值。就是最终要提出的数量。<br>  int toEvict = Math.min(expiredLeases.size(), evictionLimit);</p>
<p>  然后剔除。用internalCancel(appName, id, false);执行 服务下线将服务从注册表清除掉。</p>
<p>  剔除的限制：<br>  1.自我保护期间不清除。<br>  2.分批次清除。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>3.服务是逐个随机剔除，剔除均匀分布在所有应用中，防止在同一时间内同一服务集群中的服务全部过期被剔除，造成在大量剔除服务时，并在进行自我保护时，促使程序崩溃。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">EurekaServerInitializerConfiguration的 eurekaServerBootstrap.contextInitialized(方法，中initEurekaServerContext();点进去this.registry.openForTraffic(this.applicationInfoManager, registryCount);点进去，super.postInit();点进去evictionTaskRef.set(new EvictionTask());</span><br><span class="line">           evictionTimer.schedule(evictionTaskRef.get(),</span><br><span class="line">                serverConfig.getEvictionIntervalTimerInMs(),</span><br><span class="line">                   serverConfig.getEvictionIntervalTimerInMs());</span><br><span class="line">   发现 定时任务。</span><br></pre></td></tr></table></figure>

<p> 剔除服务是个定时任务，用EvictionTask执行，默认60秒执行一次，延时60秒执行。定时剔除过期服务。</p>
<p> 服务剔除将会遍历registry注册表，找出其中所有的过期租约，然后根据配置文件中续租百分比阀值和当前注册表的租约总数量计算出最大允许的剔除租约的数量(当前注册表中租约总数量减去当前注册表租约阀值)，分批次剔除过期的服务实例租约。对过期的服务实例租约调用AbstractInstanceRegistry#internalCancel服务下线的方法将其从注册表中清除掉。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">     自我保护机制主要在Eureka Client和Eureka Server之间存在网络分区的情况下发挥保护作用，在服务器端和客户端都有对应实现。假设在某种特定的情况下(如网络故障)，Eureka Client和Eureka Server无法进行通信，此时Eureka Client无法向Eureka Server发起注册和续约请求，Eureka Server中就可能因注册表中的服务实例租约出现大量过期而面临被剔除的危险，然而此时的Eureka Client可能是处于健康状态的(可接受服务访问)，如果直接将注册表中大量过期的服务实例租约剔除显然是不合理的。</span><br><span class="line">​     针对这种情况，Eureka设计了“自我保护机制”。在Eureka Server处，如果出现大量的服务实例过期被剔除的现象，那么该Server节点将进入自我保护模式，保护注册表中的信息不再被剔除，在通信稳定后再退出该模式；在Eureka Client处，如果向Eureka Server注册失败，将快速超时并尝试与其他的Eureka Server进行通信。“自我保护机制”的设计大大提高了Eureka的可用性。</span><br><span class="line">​     </span><br><span class="line"></span><br><span class="line">- 服务下线</span><br><span class="line"></span><br><span class="line">  &gt; 《Eureka服务下线》</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/13/Eureka%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E8%AF%A6%E8%A7%A3/image-20200823174051490.png" alt="image-20200823174051490"></p>
<p>  Eureka Client在应用销毁时，会向Eureka Server发送服务下线请求，清除注册表中关于本应用的租约，避免无效的服务调用。在服务剔除的过程中，也是通过服务下线的逻辑完成对单个服务实例过期租约的清除工作。</p>
<p>  在InstanceResource中，    public Response cancelLease(<br>              @HeaderParam(PeerEurekaNode.HEADER_REPLICATION) String isReplication)<br>  一行代码：boolean isSuccess = registry.cancel(app.getName(), id,<br>                  “true”.equals(isReplication));点进去cancel，发现：internalCancel(appName, id, isReplication); 查看实现：        </p>
<p>  先获取读锁，防止被其他线程修改<br>  read.lock();<br>  根据appName获取服务实力集群。<br>  Map&lt;String, Lease<InstanceInfo>&gt; gMap = registry.get(appName);<br>  在内存中取消实例 id的服务<br>  if (gMap != null) {<br>                  leaseToCancel = gMap.remove(id);<br>              }</InstanceInfo></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>添加到最近下线服务的统计队列<br> synchronized (recentCanceledQueue) {<br>              recentCanceledQueue.add(new Pair&lt;Long, String&gt;(System.currentTimeMillis(), appName + “(“ + id + “)”));<br>             }</p>
<p> 往下判断leaseToCancel是否为空，租约不存在，返回false，<br> 如果存在，<br> 设置租约下线时间。 leaseToCancel.cancel();<br> InstanceInfo instanceInfo = leaseToCancel.getHolder();<br> 获取持有租约的服务信息，标记服务实例为instanceInfo.setActionType(ActionType.DELETED);<br> 添加到租约变更记录队列<br>  recentlyChangedQueue.add(new RecentlyChangedItem(leaseToCancel));用于eureka client的增量拉取注册表信息。<br> 释放锁。</p>
<p> 首先通过registry根据服务名和服务实例id查询关于服务实例的租约Lease是否存在，统计最近请求下线的服务实例用于Eureka Server主页展示。如果租约不存在，返回下线失败；如果租约存在，从registry注册表中移除，设置租约的下线时间，同时在最近租约变更记录队列中添加新的下线记录，以用于Eureka Client的增量式获取注册表信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- 集群同步</span><br></pre></td></tr></table></figure>

<p>  如果Eureka Server是通过集群的方式进行部署，那么为了维护整个集群中Eureka Server注册表数据的一致性，势必需要一个机制同步Eureka Server集群中的注册表数据。</p>
<p>  Eureka Server集群同步包含两个部分，<br>  一部分是Eureka Server在启动过程中从它的peer节点中拉取注册表信息，并将这些服务实例的信息注册到本地注册表中；<br>  另一部分是Eureka Server每次对本地注册表进行操作时，同时会将操作同步到它的peer节点中，达到集群注册表数据统一的目的。</p>
<p>  1.启动拉取别的peer<br>  在Eureka Server启动类中：EurekaServerInitializerConfiguration位于EurekaServerAutoConfiguration 的import注解中。一行：eurekaServerBootstrap.contextInitialized(<br>  进去：initEurekaServerContext();，点进去，一行：int registryCount = this.registry.syncUp();<br>  看注释：拉取注册表从邻近节点。点击syncUp()的实现方法进去：<br>  看循环：意思是，如果是i第一次进来，为0，不够等待的代码，直接执行下面的拉取服务实例。<br>  将自己作为一个eureka client，拉取注册表。并通过register(instance, instance.getLeaseInfo().getDurationInSecs(), true)注册到自身的注册表中。</p>
<p>  Eureka Server也是一个Eureka Client，在启动的时候也会进行DiscoveryClient的初始化，会从其对应的Eureka Server中拉取全量的注册表信息。在Eureka Server集群部署的情况下，Eureka Server从它的peer节点中拉取到注册表信息后，将遍历这个Applications，将所有的服务实例通过AbstractRegistry#register方法注册到自身注册表中。</p>
<pre><code>int registryCount = this.registry.syncUp();
this.registry.openForTraffic(this.applicationInfoManager, registryCount);</code></pre><p>  当执行完上面的syncUp逻辑后，在下面的openForTraffic，开启此server接受别的client注册，拉取注册表等操作。而在它首次拉取其他peer节点时，是不允许client的通信请求的。</p>
<p>  在openForTraffic中，初始化期望client发送过来的服务数量，即上面获取到的服务数量this.expectedNumberOfClientsSendingRenews = count;<br>  updateRenewsPerMinThreshold点进去，是计算自我保护的统计参数：<br>  this.numberOfRenewsPerMinThreshold = (int) (this.expectedNumberOfClientsSendingRenews<br>                  * (60.0 / serverConfig.getExpectedClientRenewalIntervalSeconds())<br>                  * serverConfig.getRenewalPercentThreshold());<br>  服务数<em>（每个服务每分钟续约次数）</em>阈值<br>  if (count &gt; 0) {<br>              this.peerInstancesTransferEmptyOnStartup = false;<br>          }<br>  如果count=0，没有拉取到注册表信息，将此值设为true，表示其他peer来取空的实例信息，意味着，将不允许client从此server获取注册表信息。如果count&gt;0，将此值设置为false，允许client来获取注册表。</p>
<p>  后面将服务置为上线，并开启剔除的定时任务。</p>
<p>  当Server的状态不为UP时，将拒绝所有的请求。在Client请求获取注册表信息时，Server会判断此时是否允许获取注册表中的信息。上述做法是为了避免Eureka Server在#syncUp方法中没有获取到任何服务实例信息时(Eureka Server集群部署的情况下)，Eureka Server注册表中的信息影响到Eureka Client缓存的注册表中的信息。因为是全量同步，如果server什么也没同步过来，会导致client清空注册表。导致服务调用出问题。</p>
<p>  2.Server之间注册表信息的同步复制<br>  为了保证Eureka Server集群运行时注册表信息的一致性，每个Eureka Server在对本地注册表进行管理操作时，会将相应的操作同步到所有peer节点中。</p>
<p>  在外部调用server的restful方法时，在com.netflix.eureka.resources包下的ApplicationResource资源中，查看每个服务的操作。比如服务注册public Response addInstance(，此方法中有<br>  registry.register(info, “true”.equals(isReplication));点进去实现类：replicateToPeers(Action.Register, info.getAppName(), info.getId(), info, null, isReplication);这是一种情况。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在PeerAwareInstanceRegistryImpl类中，看其他操作，cancel，renew等中都有replicateToPeers，<br> 此方法中有个peerEurekaNodes，代表一个可同步数据的eureka Server的集合，如果注册表有变化，向此中的peer节点同步。</p>
<p> replicateToPeers方法，它将遍历Eureka Server中peer节点，向每个peer节点发送同步请求。<br>             for (final PeerEurekaNode node : peerEurekaNodes.getPeerEurekaNodes()) {<br>                 // If the url represents this host, do not replicate to yourself.<br>                 if (peerEurekaNodes.isThisMyUrl(node.getServiceUrl())) {<br>                     continue;<br>                 }<br>                 replicateInstanceActionsToPeers(action, appName, id, info, newStatus, node);<br>             }<br> 此replicateInstanceActionsToPeers方法中，类PeerEurekaNode的实例node的各种方法，cancel，register，等，用了batchingDispatcher.process(，作用是将同一时间段内，相同服务实例的相同操作将使用相同的任务编号，在进行同步复制的时候，将根据任务编号合并操作，减少同步操作的数量和网络消耗，但是同时也造成了同步复制的延时性，不满足CAP中的C（强一致性）。<br> 所以Eureka，只满足AP。</p>
<p> 通过Eureka Server在启动过程中初始化本地注册表信息和Eureka Server集群间的同步复制操作，最终达到了集群中Eureka Server注册表信息一致的目的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- 获取注册表中服务实例信息</span><br></pre></td></tr></table></figure>

<p>Eureka Server中获取注册表的服务实例信息主要通过两个方法实现：AbstractInstanceRegistry#getApplicationsFromMultipleRegions从多地区获取全量注册表数据，AbstractInstanceRegistry#getApplicationDeltasFromMultipleRegions从多地区获取增量式注册表数据。</p>
<p> 1、全量：<br> 上面讲到从节点复制注册信息的时候，用方法public int syncUp() ，一行Applications apps = eurekaClient.getApplications();点进去实现类，有一行getApplicationsFromAllRemoteRegions(); 下面getApplicationsFromMultipleRegions，作用从多个地区中获取全量注册表信息，并封装成Applications返回，它首先会将本地注册表registry中的所有服务实例信息提取出来封装到Applications中，再根据是否需要拉取Region的注册信息，将远程拉取过来的Application放到上面的Applications中。最后得到一个全量的Applications。<br> 2、在前面提到接受服务注册，接受心跳等方法中，都有recentlyChangedQueue.add(new RecentlyChangedItem(lease));作用是将新变动的服务放到最近变化的服务实例信息队列中，用于记录增量是注册表信息。getApplicationDeltasFromMultipleRegions，实现了从远处eureka server中获取增量式注册表信息的能力。</p>
<p> 在EurekaServer对外restful中，在com.netflix.eureka.resources下，<br> @GET<br>     public Response getApplication(@PathParam(“version”) String version,<br>                                    @HeaderParam(“Accept”) final String acceptHeader,<br>                                    @HeaderParam(EurekaAccept.HTTP_X_EUREKA_ACCEPT) String eurekaAccept) {</p>
<p> 其中有一句：String payLoad = responseCache.get(cacheKey);在responseCache初始化的时候，它的构造方法ResponseCacheImpl(EurekaServerConfig serverConfig, ServerCodecs serverCodecs, AbstractInstanceRegistry registry) {中，Value value = generatePayload(key);点进去有一句：registry.getApplicationDeltasFromMultipleRegions(key.getRegions()));从远程获取delta增量注册信息。但是这个只是向client提供，不向server提供，因为server可以通过每次变更自动同步到peer。</p>
<p> 获取增量式注册表信息将会从recentlyChangedQueue中获取最近变化的服务实例信息。recentlyChangedQueue中统计了近3分钟内进行注册、修改和剔除的服务实例信息，在服务注册AbstractInstanceRegistry#registry、接受心跳请求AbstractInstanceRegistry#renew和服务下线AbstractInstanceRegistry#internalCancel等方法中均可见到recentlyChangedQueue对这些服务实例进行登记，用于记录增量式注册表信息。#getApplicationsFromMultipleRegions方法同样提供了从远程Region的Eureka Server获取增量式注册表信息的能力。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">------</span><br><span class="line"></span><br><span class="line">2020-01-19 第二节课完。</span><br><span class="line"></span><br><span class="line">eureka源码总结：</span><br><span class="line"></span><br><span class="line">1. client</span><br><span class="line"></span><br><span class="line">- 拉取server注册表到本地。</span><br><span class="line">- 注册服务。</span><br><span class="line">- 初始化3个定时任务：心跳续约，定时拉取注册表，按需注册（InstanceInfoReplicator#run）。</span><br><span class="line">- 发送下线。</span><br><span class="line"></span><br><span class="line">2. server</span><br><span class="line"></span><br><span class="line">- 接受服务注册</span><br><span class="line">- 接受服务心跳</span><br><span class="line">- 服务剔除</span><br><span class="line">- 服务下线</span><br><span class="line">- 集群同步（1.启动时从peer拉取信息，2.将注册到自己的服务同步到peer）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">画了些图：</span><br><span class="line"></span><br><span class="line">《Eureka服务端注册》</span><br><span class="line">《Eureka服务端接收心跳》</span><br><span class="line">《Eureka服务下线》</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 11.9 Eureka元数据</span><br><span class="line"></span><br><span class="line">获取元数据信息</span><br><span class="line"></span><br><span class="line">1. 从Eureka Server获取：</span><br><span class="line"></span><br><span class="line">   启动eureka-7900。</span><br><span class="line"></span><br><span class="line">   启动一个service-sms（8002）</span><br><span class="line"></span><br><span class="line">   访问：http:&#x2F;&#x2F;localhost:7900&#x2F;eureka&#x2F;apps&#x2F;service-sms</span><br><span class="line">   看到如下结果：</span><br><span class="line"></span><br><span class="line">   &#96;&#96;&#96;sh</span><br><span class="line">   &lt;application&gt;</span><br><span class="line">   &lt;name&gt;SERVICE-SMS&lt;&#x2F;name&gt;</span><br><span class="line">   &lt;instance&gt;</span><br><span class="line">   &lt;instanceId&gt;30.136.133.11:service-sms:8002&lt;&#x2F;instanceId&gt;</span><br><span class="line">   &lt;hostName&gt;30.136.133.11&lt;&#x2F;hostName&gt;</span><br><span class="line">   &lt;app&gt;SERVICE-SMS&lt;&#x2F;app&gt;</span><br><span class="line">   &lt;ipAddr&gt;30.136.133.11&lt;&#x2F;ipAddr&gt;</span><br><span class="line">   &lt;status&gt;UP&lt;&#x2F;status&gt;</span><br><span class="line">   &lt;overriddenstatus&gt;UNKNOWN&lt;&#x2F;overriddenstatus&gt;</span><br><span class="line">   &lt;port enabled&#x3D;&quot;true&quot;&gt;8002&lt;&#x2F;port&gt;</span><br><span class="line">   &lt;securePort enabled&#x3D;&quot;false&quot;&gt;443&lt;&#x2F;securePort&gt;</span><br><span class="line">   &lt;countryId&gt;1&lt;&#x2F;countryId&gt;</span><br><span class="line">   &lt;dataCenterInfo class&#x3D;&quot;com.netflix.appinfo.InstanceInfo$DefaultDataCenterInfo&quot;&gt;</span><br><span class="line">   &lt;name&gt;MyOwn&lt;&#x2F;name&gt;</span><br><span class="line">   &lt;&#x2F;dataCenterInfo&gt;</span><br><span class="line">   &lt;leaseInfo&gt;</span><br><span class="line">   &lt;renewalIntervalInSecs&gt;1&lt;&#x2F;renewalIntervalInSecs&gt;</span><br><span class="line">   &lt;durationInSecs&gt;1&lt;&#x2F;durationInSecs&gt;</span><br><span class="line">   &lt;registrationTimestamp&gt;1579673388471&lt;&#x2F;registrationTimestamp&gt;</span><br><span class="line">   &lt;lastRenewalTimestamp&gt;1579673470319&lt;&#x2F;lastRenewalTimestamp&gt;</span><br><span class="line">   &lt;evictionTimestamp&gt;0&lt;&#x2F;evictionTimestamp&gt;</span><br><span class="line">   &lt;serviceUpTimestamp&gt;1579673387755&lt;&#x2F;serviceUpTimestamp&gt;</span><br><span class="line">   &lt;&#x2F;leaseInfo&gt;</span><br><span class="line">   &lt;metadata&gt;</span><br><span class="line">   &lt;user.password&gt;root&lt;&#x2F;user.password&gt;</span><br><span class="line">   &lt;management.port&gt;8002&lt;&#x2F;management.port&gt;</span><br><span class="line">   &lt;jmx.port&gt;62449&lt;&#x2F;jmx.port&gt;</span><br><span class="line">   &lt;user.name&gt;root&lt;&#x2F;user.name&gt;</span><br><span class="line">   &lt;&#x2F;metadata&gt;</span><br><span class="line">   &lt;homePageUrl&gt;http:&#x2F;&#x2F;30.136.133.11:8002&#x2F;&lt;&#x2F;homePageUrl&gt;</span><br><span class="line">   &lt;statusPageUrl&gt;http:&#x2F;&#x2F;30.136.133.11:8002&#x2F;actuator&#x2F;info&lt;&#x2F;statusPageUrl&gt;</span><br><span class="line">   &lt;healthCheckUrl&gt;http:&#x2F;&#x2F;30.136.133.11:8002&#x2F;actuator&#x2F;health&lt;&#x2F;healthCheckUrl&gt;</span><br><span class="line">   &lt;vipAddress&gt;service-sms&lt;&#x2F;vipAddress&gt;</span><br><span class="line">   &lt;secureVipAddress&gt;service-sms&lt;&#x2F;secureVipAddress&gt;</span><br><span class="line">   &lt;isCoordinatingDiscoveryServer&gt;false&lt;&#x2F;isCoordinatingDiscoveryServer&gt;</span><br><span class="line">   &lt;lastUpdatedTimestamp&gt;1579673388471&lt;&#x2F;lastUpdatedTimestamp&gt;</span><br><span class="line">   &lt;lastDirtyTimestamp&gt;1579673387301&lt;&#x2F;lastDirtyTimestamp&gt;</span><br><span class="line">   &lt;actionType&gt;ADDED&lt;&#x2F;actionType&gt;</span><br><span class="line">   &lt;&#x2F;instance&gt;</span><br><span class="line">   &lt;&#x2F;application&gt;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>手写获取元数据。</p>
<p>在一个eureka client（api-listen-order）中，写一个controller</p>
</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import org.springframework.cloud.client.discovery.DiscoveryClient;</span><br><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(<span class="string">"/service-instance"</span>)</span><br><span class="line">public class ServiceInstanceController &#123;</span><br><span class="line">	</span><br><span class="line">	@Autowired</span><br><span class="line">	private DiscoveryClient discoveryClient;</span><br><span class="line">	</span><br><span class="line">	@GetMapping(<span class="string">"/query-by-application-name/&#123;applicationName&#125;"</span>)</span><br><span class="line">	public List&lt;ServiceInstance&gt; getInstance(@PathVariable String applicationName)&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="built_in">return</span> discoveryClient.getInstances(applicationName);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>演示</p>
<p>启动eureka（7900）单节点</p>
<p>启动api-listen-order</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">实例演示：</span><br><span class="line">获取服务元数据：</span><br><span class="line"></span><br><span class="line">访问地址：</span><br><span class="line">自己开发：</span><br><span class="line">http:&#x2F;&#x2F;localhost:8084&#x2F;service-instance&#x2F;query-by-application-name&#x2F;api-listen-order</span><br><span class="line"></span><br><span class="line">http:&#x2F;&#x2F;localhost:8084&#x2F;service-instance&#x2F;query-by-application-name&#x2F;service-sms</span><br><span class="line"></span><br><span class="line">结果看到一堆json信息，</span><br><span class="line"></span><br><span class="line">表示api-listen-order在eureka server中的实例信息。</span><br></pre></td></tr></table></figure>

<ol>
<li><p>标准元数据和自定义元数据</p>
</li>
<li><p>标准元数据：主机名，ip，端口，健康检查等信息。会被发布到注册表中，用于服务间调用。</p>
</li>
<li><p>自定义元数据：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">eureka.instance.metadata-map：</span><br><span class="line">  自定义key:自定义value</span><br></pre></td></tr></table></figure>

<p>远程客户端访问。自定义属性。</p>
<p>api-listen-order中ServiceInstanceController，读取instance信息。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">启动eureka，api-listen-order,</span><br><span class="line"></span><br><span class="line">http://localhost:8084/service-instance/query-by-application-name/api-listen-order</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">&#123;</span><br><span class="line">	<span class="string">"host"</span>: <span class="string">"127.0.0.1"</span>,</span><br><span class="line">	<span class="string">"port"</span>: 8084,</span><br><span class="line">	<span class="string">"metadata"</span>: &#123;</span><br><span class="line">		<span class="string">"yueyi"</span>: <span class="string">"2019"</span>,</span><br><span class="line">		<span class="string">"user.password"</span>: <span class="string">"root"</span>,</span><br><span class="line">		<span class="string">"management.port"</span>: <span class="string">"8084"</span>,</span><br><span class="line">		<span class="string">"jmx.port"</span>: <span class="string">"61378"</span>,</span><br><span class="line">		<span class="string">"user.name"</span>: <span class="string">"root"</span></span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="string">"secure"</span>: <span class="literal">false</span>,</span><br><span class="line">	<span class="string">"uri"</span>: <span class="string">"http://127.0.0.1:8084"</span>,</span><br><span class="line">	<span class="string">"instanceId"</span>: <span class="string">"api-listen-order:30.136.133.11:port"</span>,</span><br><span class="line">	<span class="string">"serviceId"</span>: <span class="string">"API-LISTEN-ORDER"</span>,</span><br><span class="line">	<span class="string">"instanceInfo"</span>: &#123;</span><br><span class="line">		<span class="string">"instanceId"</span>: <span class="string">"api-listen-order:30.136.133.11:port"</span>,</span><br><span class="line">		<span class="string">"app"</span>: <span class="string">"API-LISTEN-ORDER"</span>,</span><br><span class="line">		<span class="string">"appGroupName"</span>: null,</span><br><span class="line">		<span class="string">"ipAddr"</span>: <span class="string">"127.0.0.1"</span>,</span><br><span class="line">		<span class="string">"sid"</span>: <span class="string">"na"</span>,</span><br><span class="line">		<span class="string">"homePageUrl"</span>: <span class="string">"http://127.0.0.1:8084/"</span>,</span><br><span class="line">		<span class="string">"statusPageUrl"</span>: <span class="string">"http://127.0.0.1:8084/actuator/info"</span>,</span><br><span class="line">		<span class="string">"healthCheckUrl"</span>: <span class="string">"http://127.0.0.1:8084/actuator/health"</span>,</span><br><span class="line">		<span class="string">"secureHealthCheckUrl"</span>: null,</span><br><span class="line">		<span class="string">"vipAddress"</span>: <span class="string">"api-listen-order"</span>,</span><br><span class="line">		<span class="string">"secureVipAddress"</span>: <span class="string">"api-listen-order"</span>,</span><br><span class="line">		<span class="string">"countryId"</span>: 1,</span><br><span class="line">		<span class="string">"dataCenterInfo"</span>: &#123;</span><br><span class="line">			<span class="string">"@class"</span>: <span class="string">"com.netflix.appinfo.InstanceInfo<span class="variable">$DefaultDataCenterInfo</span>"</span>,</span><br><span class="line">			<span class="string">"name"</span>: <span class="string">"MyOwn"</span></span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="string">"hostName"</span>: <span class="string">"127.0.0.1"</span>,</span><br><span class="line">		<span class="string">"status"</span>: <span class="string">"UP"</span>,</span><br><span class="line">		<span class="string">"overriddenStatus"</span>: <span class="string">"UNKNOWN"</span>,</span><br><span class="line">		<span class="string">"leaseInfo"</span>: &#123;</span><br><span class="line">			<span class="string">"renewalIntervalInSecs"</span>: 1,</span><br><span class="line">			<span class="string">"durationInSecs"</span>: 1,</span><br><span class="line">			<span class="string">"registrationTimestamp"</span>: 1579489514655,</span><br><span class="line">			<span class="string">"lastRenewalTimestamp"</span>: 1579489524146,</span><br><span class="line">			<span class="string">"evictionTimestamp"</span>: 0,</span><br><span class="line">			<span class="string">"serviceUpTimestamp"</span>: 1579489514147</span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="string">"isCoordinatingDiscoveryServer"</span>: <span class="literal">false</span>,</span><br><span class="line">		<span class="string">"metadata"</span>: &#123;</span><br><span class="line">			<span class="string">"yueyi"</span>: <span class="string">"2019"</span>,</span><br><span class="line">			<span class="string">"user.password"</span>: <span class="string">"root"</span>,</span><br><span class="line">			<span class="string">"management.port"</span>: <span class="string">"8084"</span>,</span><br><span class="line">			<span class="string">"jmx.port"</span>: <span class="string">"61378"</span>,</span><br><span class="line">			<span class="string">"user.name"</span>: <span class="string">"root"</span></span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="string">"lastUpdatedTimestamp"</span>: 1579489514655,</span><br><span class="line">		<span class="string">"lastDirtyTimestamp"</span>: 1579489514111,</span><br><span class="line">		<span class="string">"actionType"</span>: <span class="string">"ADDED"</span>,</span><br><span class="line">		<span class="string">"asgName"</span>: null</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="string">"scheme"</span>: null</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>自定义元数据，可以结合ribbon 分发规则使用。网关 做 分发规则 选择 服务时，可以作为依据。灰度发布。有作用。后面负载均衡有例子。此时只认识元数据。基于元数据做的例子，后面有。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">灰度发布例子：</span><br><span class="line"></span><br><span class="line">client端：</span><br><span class="line">eureka:</span><br><span class="line">  instance:</span><br><span class="line">    metadataMap:</span><br><span class="line">      tag: pre-prd</span><br><span class="line"></span><br><span class="line">调用方：</span><br><span class="line">List&lt;ServiceInstance&gt; instances =  discoveryClient.getInstances(applicationName);</span><br><span class="line">		<span class="keyword">for</span> (ServiceInstance serviceInstance : instances) &#123;</span><br><span class="line">			Map&lt;String, String&gt; metadata = serviceInstance.getMetadata();</span><br><span class="line">			String metaValue = metadata.get(<span class="string">"yueyi"</span>);</span><br><span class="line">			log.info(<span class="string">"元数据："</span>+metaValue);</span><br><span class="line">		&#125;</span><br><span class="line">获取到元数据。</span><br><span class="line"></span><br><span class="line">分发的时候，根据app客户端传过来的参数：比如加tag=pre,只分发到pre-prd的eureka client。</span><br><span class="line">在新发布的app版本带tag参数。就可以实现灰度测试。</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h2 id="10-自我保护计算"><a href="#10-自我保护计算" class="headerlink" title="10 自我保护计算"></a>10 自我保护计算</h2><ol>
<li><p>红色警告</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EMERGENCY! EUREKA MAY BE INCORRECTLY CLAIMING INSTANCES ARE UP WHEN THEY<span class="string">'RE NOT. RENEWALS ARE LESSER THAN THRESHOLD AND HENCE THE INSTANCES ARE NOT BEING EXPIRED JUST TO BE SAFE.</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>默认情况下，Eureka Server在一定时间内，没有接收到某个微服务心跳，会将某个微服务注销（90S）。但是当网络故障时，微服务与Server之间无法正常通信，上述行为就非常危险，因为微服务正常，不应该注销。</p>
<p>Eureka Server通过自我保护模式来解决整个问题，当Server在短时间内丢失过多客户端时，那么Server会进入自我保护模式，会保护注册表中的微服务不被注销掉。当网络故障恢复后，退出自我保护模式。</p>
</li>
<li><p>思想：宁可保留健康的和不健康的，也不盲目注销任何健康的服务。</p>
</li>
<li><p>关闭自我保护。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">eureka:</span><br><span class="line">  server: </span><br><span class="line">    <span class="built_in">enable</span>-self-preservation: <span class="literal">false</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>自我保护触发</p>
<p>自我保护机制的触发条件：<br>（当每分钟心跳次数( renewsLastMin ) 小于 numberOfRenewsPerMinThreshold 时，并且开启自动保护模式开关( eureka.server.enable-self-preservation = true ) 时，触发自我保护机制，不再自动过期租约。）<br>numberOfRenewsPerMinThreshold = expectedNumberOfRenewsPerMin * 续租百分比( eureka.server.renewalPercentThreshold, 默认0.85 )<br>expectedNumberOfRenewsPerMin = 当前注册的应用实例数 x 2<br>为什么乘以 2：<br>默认情况下，注册的应用实例每半分钟续租一次，那么一分钟心跳两次，因此 x 2 。</p>
<p>服务实例数：10个，期望每分钟续约数：10 * 2=20，期望阈值：20*0.85=17，自我保护少于17时 触发。</p>
<p>剔除：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">AbstractInstanceRegistry</span><br><span class="line"></span><br><span class="line">public void evict(long additionalLeaseMs) &#123;</span><br><span class="line">    logger.debug(<span class="string">"Running the evict task"</span>);</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">if</span> (!isLeaseExpirationEnabled()) &#123;</span><br><span class="line">        logger.debug(<span class="string">"DS: lease expiration is currently disabled."</span>);</span><br><span class="line">        <span class="built_in">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">此代码意思：<span class="keyword">if</span>中判断为<span class="literal">true</span>，不走此逻辑，走下面的剔除。如果<span class="keyword">if</span>为<span class="literal">false</span>。走此逻辑，不剔除。</span><br></pre></td></tr></table></figure>



</li>
</ol>
   <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">PeerAwareInstanceRegistryImpl</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean <span class="function"><span class="title">isLeaseExpirationEnabled</span></span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isSelfPreservationModeEnabled()) &#123;</span><br><span class="line">        //如果打开自我保护，不进入此逻辑。</span><br><span class="line">            // The self preservation mode is disabled, hence allowing the instances to expire.</span><br><span class="line">            <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> numberOfRenewsPerMinThreshold &gt; 0 &amp;&amp; getNumOfRenewsInLastMin() &gt; numberOfRenewsPerMinThreshold;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>《自我保护流程图》</p>
</blockquote>
<p>   <img src="/2020/08/13/Eureka%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E8%AF%A6%E8%A7%A3/image-20200823174202817.png" alt="image-20200823174202817"></p>
<h2 id="11-多网卡选择"><a href="#11-多网卡选择" class="headerlink" title="11 多网卡选择"></a>11 多网卡选择</h2><ol>
<li>ip注册</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">eureka:</span><br><span class="line">  instance:</span><br><span class="line">    prefer-ip-address: <span class="literal">true</span></span><br><span class="line">表示将自己的ip注册到EurekaServer上。不配置或<span class="literal">false</span>，表示将操作系统的hostname注册到server</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>服务器有多个网卡，eh0，eh1，eh2，只有eh0可以让外部其他服务访问进来，而Eureka client将eh1和eh2注册到Eureka server上，这样其他服务就无法访问该微服务了。</p>
</li>
<li><p>指定Ip</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">eureka:</span><br><span class="line">  instance:</span><br><span class="line">    prefer-ip-address: <span class="literal">true</span></span><br><span class="line">    ip-address: 实际能访问到的Ip</span><br></pre></td></tr></table></figure>

<p>如果设置了此时的ip-address，在元数据查看到就是此ip，其他服务也通过此ip来调用。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="string">"host"</span>: <span class="string">"127.0.0.1"</span>,</span><br><span class="line">	<span class="string">"port"</span>: 8084,</span><br><span class="line">	<span class="string">"metadata"</span>: &#123;</span><br><span class="line">		<span class="string">"yueyi"</span>: <span class="string">"2019"</span>,</span><br><span class="line">		<span class="string">"user.password"</span>: <span class="string">"root"</span>,</span><br><span class="line">		<span class="string">"management.port"</span>: <span class="string">"8084"</span>,</span><br><span class="line">		<span class="string">"jmx.port"</span>: <span class="string">"61378"</span>,</span><br><span class="line">		<span class="string">"user.name"</span>: <span class="string">"root"</span></span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="string">"secure"</span>: <span class="literal">false</span>,</span><br><span class="line">	<span class="string">"uri"</span>: <span class="string">"http://127.0.0.1:8084"</span>,</span><br><span class="line">	<span class="string">"instanceId"</span>: <span class="string">"api-listen-order:30.136.133.11:port"</span>,</span><br><span class="line">	<span class="string">"serviceId"</span>: <span class="string">"API-LISTEN-ORDER"</span>,</span><br><span class="line">	<span class="string">"instanceInfo"</span>: &#123;</span><br><span class="line">		<span class="string">"instanceId"</span>: <span class="string">"api-listen-order:30.136.133.11:port"</span>,</span><br><span class="line">		<span class="string">"app"</span>: <span class="string">"API-LISTEN-ORDER"</span>,</span><br><span class="line">		<span class="string">"appGroupName"</span>: null,</span><br><span class="line">		<span class="string">"ipAddr"</span>: <span class="string">"127.0.0.1"</span>,</span><br><span class="line">		<span class="string">"sid"</span>: <span class="string">"na"</span>,</span><br><span class="line">		<span class="string">"homePageUrl"</span>: <span class="string">"http://127.0.0.1:8084/"</span>,</span><br><span class="line">		<span class="string">"statusPageUrl"</span>: <span class="string">"http://127.0.0.1:8084/actuator/info"</span>,</span><br><span class="line">		<span class="string">"healthCheckUrl"</span>: <span class="string">"http://127.0.0.1:8084/actuator/health"</span>,</span><br><span class="line">		<span class="string">"secureHealthCheckUrl"</span>: null,</span><br><span class="line">		<span class="string">"vipAddress"</span>: <span class="string">"api-listen-order"</span>,</span><br><span class="line">		<span class="string">"secureVipAddress"</span>: <span class="string">"api-listen-order"</span>,</span><br><span class="line">		<span class="string">"countryId"</span>: 1,</span><br><span class="line">		<span class="string">"dataCenterInfo"</span>: &#123;</span><br><span class="line">			<span class="string">"@class"</span>: <span class="string">"com.netflix.appinfo.InstanceInfo<span class="variable">$DefaultDataCenterInfo</span>"</span>,</span><br><span class="line">			<span class="string">"name"</span>: <span class="string">"MyOwn"</span></span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="string">"hostName"</span>: <span class="string">"127.0.0.1"</span>,</span><br><span class="line">		<span class="string">"status"</span>: <span class="string">"UP"</span>,</span><br><span class="line">		<span class="string">"overriddenStatus"</span>: <span class="string">"UNKNOWN"</span>,</span><br><span class="line">		<span class="string">"leaseInfo"</span>: &#123;</span><br><span class="line">			<span class="string">"renewalIntervalInSecs"</span>: 1,</span><br><span class="line">			<span class="string">"durationInSecs"</span>: 1,</span><br><span class="line">			<span class="string">"registrationTimestamp"</span>: 1579489514655,</span><br><span class="line">			<span class="string">"lastRenewalTimestamp"</span>: 1579489524146,</span><br><span class="line">			<span class="string">"evictionTimestamp"</span>: 0,</span><br><span class="line">			<span class="string">"serviceUpTimestamp"</span>: 1579489514147</span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="string">"isCoordinatingDiscoveryServer"</span>: <span class="literal">false</span>,</span><br><span class="line">		<span class="string">"metadata"</span>: &#123;</span><br><span class="line">			<span class="string">"yueyi"</span>: <span class="string">"2019"</span>,</span><br><span class="line">			<span class="string">"user.password"</span>: <span class="string">"root"</span>,</span><br><span class="line">			<span class="string">"management.port"</span>: <span class="string">"8084"</span>,</span><br><span class="line">			<span class="string">"jmx.port"</span>: <span class="string">"61378"</span>,</span><br><span class="line">			<span class="string">"user.name"</span>: <span class="string">"root"</span></span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="string">"lastUpdatedTimestamp"</span>: 1579489514655,</span><br><span class="line">		<span class="string">"lastDirtyTimestamp"</span>: 1579489514111,</span><br><span class="line">		<span class="string">"actionType"</span>: <span class="string">"ADDED"</span>,</span><br><span class="line">		<span class="string">"asgName"</span>: null</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="string">"scheme"</span>: null</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h2 id="12-Eureka-健康检查"><a href="#12-Eureka-健康检查" class="headerlink" title="12 Eureka 健康检查"></a>12 Eureka 健康检查</h2><blockquote>
<p>《健康检查效果》</p>
</blockquote>
<p>由于server和client通过心跳保持 服务状态，而只有状态为UP的服务才能被访问。看eureka界面中的status。</p>
<p>比如心跳一直正常，服务一直UP，但是此服务DB连不上了，无法正常提供服务。</p>
<p>此时，我们需要将 微服务的健康状态也同步到server。只需要启动eureka的健康检查就行。这样微服务就会将自己的健康状态同步到eureka。配置如下即可。</p>
<p>在client端配置：将自己的健康状态传播到server。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    healthcheck:</span><br><span class="line">      enabled: <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>健康检查组件</p>
<h2 id="13-Eureka-配置"><a href="#13-Eureka-配置" class="headerlink" title="13 Eureka 配置"></a>13 Eureka 配置</h2><p>​    EurekaServerConfigBean：Eureka Server配置。</p>
<p>​    EurekaInstanceConfigBean：Eureka Client实例配置。</p>
<p>​    EurekaClientConfigBean：Eureka Client 客户端和服务端交互配置。</p>
<ol>
<li>instanceId。</li>
<li>通过ip注册。</li>
<li>配置服务快速下线。</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">eureka:</span><br><span class="line">  server: </span><br><span class="line">  	<span class="comment">#关闭自我保护</span></span><br><span class="line">    <span class="built_in">enable</span>-self-preservation: <span class="literal">false</span></span><br><span class="line">    <span class="comment">#清理服务间隔时间，毫秒</span></span><br><span class="line">    eviction-interval-timer-in-ms: 5000</span><br><span class="line">    </span><br><span class="line">client：</span><br><span class="line">eureka: </span><br><span class="line">  client:</span><br><span class="line">    healthcheck:</span><br><span class="line">      <span class="comment">#开启健康检查，需要引入actuator</span></span><br><span class="line">      enabled: <span class="literal">true</span></span><br><span class="line">  instance: </span><br><span class="line">    <span class="comment">#发送心跳给server的频率，每隔这个时间会主动心跳一次</span></span><br><span class="line">    lease-renewal-interval-in-seconds: 1      </span><br><span class="line">    <span class="comment">#Server从收到client后，下一次收到心跳的间隔时间。超过这个时间没有接收到心跳EurekaServer就会将这个实例剔除</span></span><br><span class="line">    lease-expiration-duration-in-seconds: 1</span><br></pre></td></tr></table></figure>



<p>其他配置：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"homePageUrl"</span>: <span class="string">"http://127.0.0.1:8084/"</span>,</span><br><span class="line"><span class="string">"statusPageUrl"</span>: <span class="string">"http://127.0.0.1:8084/actuator/info"</span>,</span><br><span class="line"><span class="string">"healthCheckUrl"</span>: <span class="string">"http://127.0.0.1:8084/actuator/health"</span>,</span><br><span class="line"></span><br><span class="line">如果设置了</span><br><span class="line"></span><br><span class="line">server:</span><br><span class="line">    servlet:</span><br><span class="line">        path: /path</span><br><span class="line"></span><br><span class="line">需要：</span><br><span class="line"></span><br><span class="line">eureka:</span><br><span class="line">    instance:</span><br><span class="line">        statusPageUrlPath: <span class="variable">$&#123;server.servlet.path&#125;</span>/actuator/info</span><br><span class="line">        healthCheckUrlPath: <span class="variable">$&#123;server.servlet.path&#125;</span>/actuator/health</span><br></pre></td></tr></table></figure>



<h2 id="14-Eureka监听事件"><a href="#14-Eureka监听事件" class="headerlink" title="14 Eureka监听事件"></a>14 Eureka监听事件</h2><p>EurekaInstanceCanceledEvent 服务下线事件</p>
<p>EurekaInstanceRegisteredEvent 服务注册事件</p>
<p>EurekaInstanceRenewedEvent 服务续约事件</p>
<p>EurekaRegistryAvailableEvent 注册中心可用事件</p>
<p>EurekaServerStartedEvent  注册中心启动</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import org.springframework.cloud.netflix.eureka.server.event.EurekaInstanceCanceledEvent;</span><br><span class="line">import org.springframework.context.event.EventListener;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line">public class CustomEvent &#123;</span><br><span class="line">	</span><br><span class="line">	@EventListener</span><br><span class="line">	public void listen(EurekaInstanceCanceledEvent e) &#123;</span><br><span class="line">		System.out.println(e.getServerId()+<span class="string">"下线事件"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">将Eureka Client停止后打印：</span><br><span class="line">api-listen-order:30.136.133.9:port下线事件</span><br></pre></td></tr></table></figure>



<h2 id="15-Eureka缺陷"><a href="#15-Eureka缺陷" class="headerlink" title="15 Eureka缺陷"></a>15 Eureka缺陷</h2><p>由于集群间的同步复制是通过HTTP的方式进行，基于网络的不可靠性，集群中的Eureka Server间的注册表信息难免存在不同步的时间节点，不满足CAP中的C(数据一致性)。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Spring-Cloud/" rel="tag"># Spring Cloud</a>
          
            <a href="/tags/%E6%A1%86%E6%9E%B6/" rel="tag"># 框架</a>
          
            <a href="/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" rel="tag"># 微服务</a>
          
            <a href="/tags/%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/" rel="tag"># 注册中心</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/08/13/MySQL%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%E8%AF%A6%E8%A7%A3/" rel="next" title="MySQL执行计划详解">
                <i class="fa fa-chevron-left"></i> MySQL执行计划详解
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/08/24/Spring%E5%8E%9F%E7%90%86%E8%AE%B2%E8%A7%A3/" rel="prev" title="Spring原理讲解">
                Spring原理讲解 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/oi.jpg"
                alt="OiPunk" />
            
              <p class="site-author-name" itemprop="name">OiPunk</p>
              <p class="site-description motion-element" itemprop="description">跑到前面那棵小树再休息</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">50</span>
                  <span class="site-state-item-name">文章</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">39</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/OiPunk" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:oipunk@foxmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-Eureka-单节点搭建"><span class="nav-number">1.</span> <span class="nav-text">1 Eureka 单节点搭建</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-整体介绍"><span class="nav-number">2.</span> <span class="nav-text">2 整体介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-注册中心和微服务间的关系"><span class="nav-number">3.</span> <span class="nav-text">3 注册中心和微服务间的关系</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#11-3-1-client功能"><span class="nav-number">3.1.</span> <span class="nav-text">11.3.1 client功能</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-3-2-server注册中心功能"><span class="nav-number">3.2.</span> <span class="nav-text">11.3.2 server注册中心功能</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-服务注册"><span class="nav-number">4.</span> <span class="nav-text">4 服务注册</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-Eureka高可用"><span class="nav-number">5.</span> <span class="nav-text">5 Eureka高可用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-Eureka-端点"><span class="nav-number">6.</span> <span class="nav-text">6 Eureka 端点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-Eureka-原理"><span class="nav-number">7.</span> <span class="nav-text">7 Eureka 原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-Eureka-Client源码"><span class="nav-number">8.</span> <span class="nav-text">8 Eureka Client源码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-Eureka-Server源码"><span class="nav-number">9.</span> <span class="nav-text">9 Eureka Server源码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-自我保护计算"><span class="nav-number">10.</span> <span class="nav-text">10 自我保护计算</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-多网卡选择"><span class="nav-number">11.</span> <span class="nav-text">11 多网卡选择</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-Eureka-健康检查"><span class="nav-number">12.</span> <span class="nav-text">12 Eureka 健康检查</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13-Eureka-配置"><span class="nav-number">13.</span> <span class="nav-text">13 Eureka 配置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14-Eureka监听事件"><span class="nav-number">14.</span> <span class="nav-text">14 Eureka监听事件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#15-Eureka缺陷"><span class="nav-number">15.</span> <span class="nav-text">15 Eureka缺陷</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">OiPunk</span>

  
</div>









        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "./public/search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
