<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Java SE,多线程,JUC,并发编程," />










<meta name="description" content="详解Java中的锁机制，并发容器，线程通信，线程池的原理及使用">
<meta property="og:type" content="article">
<meta property="og:title" content="Java并发编程">
<meta property="og:url" content="http://yoursite.com/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/index.html">
<meta property="og:site_name" content="为了明天！">
<meta property="og:description" content="详解Java中的锁机制，并发容器，线程通信，线程池的原理及使用">
<meta property="og:image" content="http://yoursite.com/2020/%E5%8F%AA%E8%A6%81%E5%AD%A6%E4%B8%8D%E6%AD%BB%20%E5%B0%B1%E5%BE%80%E6%AD%BB%E9%87%8C%E5%AD%A6/note/JUC/image/image-20200331171617504.png">
<meta property="og:image" content="http://yoursite.com/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/01_02.jpg">
<meta property="og:image" content="http://yoursite.com/2020/%E5%8F%AA%E8%A6%81%E5%AD%A6%E4%B8%8D%E6%AD%BB%20%E5%B0%B1%E5%BE%80%E6%AD%BB%E9%87%8C%E5%AD%A6/note/JUC/image/SE%E7%AC%94%E8%AE%B0/image-20200522121553190.png">
<meta property="og:image" content="http://yoursite.com/2020/%E5%8F%AA%E8%A6%81%E5%AD%A6%E4%B8%8D%E6%AD%BB%20%E5%B0%B1%E5%BE%80%E6%AD%BB%E9%87%8C%E5%AD%A6/note/JUC/image/SE%E7%AC%94%E8%AE%B0/image-20200522121725120.png">
<meta property="og:image" content="http://yoursite.com/2020/%E5%8F%AA%E8%A6%81%E5%AD%A6%E4%B8%8D%E6%AD%BB%20%E5%B0%B1%E5%BE%80%E6%AD%BB%E9%87%8C%E5%AD%A6/note/JUC/image/%E7%AC%94%E8%AE%B0/image-20200526060941085.png">
<meta property="og:image" content="http://yoursite.com/2020/%E5%8F%AA%E8%A6%81%E5%AD%A6%E4%B8%8D%E6%AD%BB%20%E5%B0%B1%E5%BE%80%E6%AD%BB%E9%87%8C%E5%AD%A6/note/JUC/image/%E7%AC%94%E8%AE%B0/image-20200526061909808.png">
<meta property="og:image" content="http://yoursite.com/2020/%E5%8F%AA%E8%A6%81%E5%AD%A6%E4%B8%8D%E6%AD%BB%20%E5%B0%B1%E5%BE%80%E6%AD%BB%E9%87%8C%E5%AD%A6/note/JUC/image/SE%E7%AC%94%E8%AE%B0/image-20200522122259623.png">
<meta property="og:image" content="http://yoursite.com/2020/%E5%8F%AA%E8%A6%81%E5%AD%A6%E4%B8%8D%E6%AD%BB%20%E5%B0%B1%E5%BE%80%E6%AD%BB%E9%87%8C%E5%AD%A6/note/JUC/image/image-20200331201536720.png">
<meta property="og:image" content="http://yoursite.com/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20200526061523926.png">
<meta property="og:image" content="http://yoursite.com/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20200331201905775.png">
<meta property="og:image" content="http://yoursite.com/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Users/Anarchism/AppData/Roaming/Typora/typora-user-images/image-20200331201926560.png">
<meta property="og:image" content="http://yoursite.com/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Users/Anarchism/AppData/Roaming/Typora/typora-user-images/image-20200331202023954.png">
<meta property="og:image" content="http://yoursite.com/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Users/Anarchism/AppData/Roaming/Typora/typora-user-images/image-20200331202137156.png">
<meta property="og:image" content="http://yoursite.com/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Users/Anarchism/AppData/Roaming/Typora/typora-user-images/image-20200331202109191.png">
<meta property="og:image" content="http://yoursite.com/2020/%E5%8F%AA%E8%A6%81%E5%AD%A6%E4%B8%8D%E6%AD%BB%20%E5%B0%B1%E5%BE%80%E6%AD%BB%E9%87%8C%E5%AD%A6/note/JUC/image/%E7%AC%94%E8%AE%B0/image-20200526063943625.png">
<meta property="og:image" content="http://yoursite.com/2020/%E5%8F%AA%E8%A6%81%E5%AD%A6%E4%B8%8D%E6%AD%BB%20%E5%B0%B1%E5%BE%80%E6%AD%BB%E9%87%8C%E5%AD%A6/note/JUC/image/%E7%AC%94%E8%AE%B0/image-20200526063846222.png">
<meta property="og:image" content="http://yoursite.com/2020/%E5%8F%AA%E8%A6%81%E5%AD%A6%E4%B8%8D%E6%AD%BB%20%E5%B0%B1%E5%BE%80%E6%AD%BB%E9%87%8C%E5%AD%A6/note/JUC/image/%E7%AC%94%E8%AE%B0/image-20200526064256437.png">
<meta property="og:image" content="http://yoursite.com/2020/%E5%8F%AA%E8%A6%81%E5%AD%A6%E4%B8%8D%E6%AD%BB%20%E5%B0%B1%E5%BE%80%E6%AD%BB%E9%87%8C%E5%AD%A6/note/JUC/image/%E7%AC%94%E8%AE%B0/image-20200526064338898.png">
<meta property="og:image" content="http://yoursite.com/2020/%E5%8F%AA%E8%A6%81%E5%AD%A6%E4%B8%8D%E6%AD%BB%20%E5%B0%B1%E5%BE%80%E6%AD%BB%E9%87%8C%E5%AD%A6/note/JUC/image/%E7%AC%94%E8%AE%B0/image-20200526064456019.png">
<meta property="og:image" content="http://yoursite.com/2020/%E5%8F%AA%E8%A6%81%E5%AD%A6%E4%B8%8D%E6%AD%BB%20%E5%B0%B1%E5%BE%80%E6%AD%BB%E9%87%8C%E5%AD%A6/note/JUC/image/%E7%AC%94%E8%AE%B0/image-20200526065140791.png">
<meta property="og:image" content="http://yoursite.com/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Users/Anarchism/AppData/Roaming/Typora/typora-user-images/image-20200331202636319.png">
<meta property="og:image" content="http://yoursite.com/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/01_04.jpg">
<meta property="og:image" content="http://yoursite.com/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Users/Anarchism/AppData/Roaming/Typora/typora-user-images/image-20200331202023954.png">
<meta property="og:image" content="http://yoursite.com/2020/%E5%8F%AA%E8%A6%81%E5%AD%A6%E4%B8%8D%E6%AD%BB%20%E5%B0%B1%E5%BE%80%E6%AD%BB%E9%87%8C%E5%AD%A6/note/JUC/image/%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20200526234924652.png">
<meta property="og:image" content="http://yoursite.com/2020/%E5%8F%AA%E8%A6%81%E5%AD%A6%E4%B8%8D%E6%AD%BB%20%E5%B0%B1%E5%BE%80%E6%AD%BB%E9%87%8C%E5%AD%A6/note/JUC/image/%E7%AC%94%E8%AE%B0/image-20200526064113021.png">
<meta property="og:image" content="http://yoursite.com/2020/%E5%8F%AA%E8%A6%81%E5%AD%A6%E4%B8%8D%E6%AD%BB%20%E5%B0%B1%E5%BE%80%E6%AD%BB%E9%87%8C%E5%AD%A6/note/JUC/image/%E7%AC%94%E8%AE%B0/image-20200527055724201.png">
<meta property="og:image" content="http://yoursite.com/2020/%E5%8F%AA%E8%A6%81%E5%AD%A6%E4%B8%8D%E6%AD%BB%20%E5%B0%B1%E5%BE%80%E6%AD%BB%E9%87%8C%E5%AD%A6/note/JUC/image/%E7%AC%94%E8%AE%B0/image-20200527061309216.png">
<meta property="og:image" content="http://yoursite.com/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Users/Anarchism/AppData/Roaming/Typora/typora-user-images/image-20200331210227033.png">
<meta property="og:image" content="http://yoursite.com/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20200527062720639.png">
<meta property="og:image" content="http://yoursite.com/2020/%E5%8F%AA%E8%A6%81%E5%AD%A6%E4%B8%8D%E6%AD%BB%20%E5%B0%B1%E5%BE%80%E6%AD%BB%E9%87%8C%E5%AD%A6/note/JUC/image/%E7%AC%94%E8%AE%B0/image-20200527062234223.png">
<meta property="og:image" content="http://yoursite.com/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Users/Anarchism/AppData/Roaming/Typora/typora-user-images/image-20200331230925283.png">
<meta property="og:image" content="http://yoursite.com/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Users/Anarchism/AppData/Roaming/Typora/typora-user-images/image-20200401054224292.png">
<meta property="og:image" content="http://yoursite.com/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Users/Anarchism/AppData/Roaming/Typora/typora-user-images/image-20200331231024356.png">
<meta property="og:image" content="http://yoursite.com/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20200527124006570.png">
<meta property="og:image" content="http://yoursite.com/2020/%E5%8F%AA%E8%A6%81%E5%AD%A6%E4%B8%8D%E6%AD%BB%20%E5%B0%B1%E5%BE%80%E6%AD%BB%E9%87%8C%E5%AD%A6/note/JUC/image/%E7%AC%94%E8%AE%B0/image-20200527124346716.png">
<meta property="og:image" content="http://yoursite.com/2020/%E5%8F%AA%E8%A6%81%E5%AD%A6%E4%B8%8D%E6%AD%BB%20%E5%B0%B1%E5%BE%80%E6%AD%BB%E9%87%8C%E5%AD%A6/note/JUC/image/%E7%AC%94%E8%AE%B0/image-20200527124231381.png">
<meta property="og:image" content="http://yoursite.com/2020/%E5%8F%AA%E8%A6%81%E5%AD%A6%E4%B8%8D%E6%AD%BB%20%E5%B0%B1%E5%BE%80%E6%AD%BB%E9%87%8C%E5%AD%A6/note/JUC/image/%E7%AC%94%E8%AE%B0/image-20200527130123437.png">
<meta property="og:image" content="http://yoursite.com/2020/%E5%8F%AA%E8%A6%81%E5%AD%A6%E4%B8%8D%E6%AD%BB%20%E5%B0%B1%E5%BE%80%E6%AD%BB%E9%87%8C%E5%AD%A6/note/JUC/md/image/image-20200401153822854.png">
<meta property="og:image" content="http://yoursite.com/2020/%E5%8F%AA%E8%A6%81%E5%AD%A6%E4%B8%8D%E6%AD%BB%20%E5%B0%B1%E5%BE%80%E6%AD%BB%E9%87%8C%E5%AD%A6/note/JUC/image/%E7%AC%94%E8%AE%B0/image-20200527132511607.png">
<meta property="og:image" content="http://yoursite.com/2020/%E5%8F%AA%E8%A6%81%E5%AD%A6%E4%B8%8D%E6%AD%BB%20%E5%B0%B1%E5%BE%80%E6%AD%BB%E9%87%8C%E5%AD%A6/note/JUC/image/image-20200401153718039.png">
<meta property="og:image" content="http://yoursite.com/2020/%E5%8F%AA%E8%A6%81%E5%AD%A6%E4%B8%8D%E6%AD%BB%20%E5%B0%B1%E5%BE%80%E6%AD%BB%E9%87%8C%E5%AD%A6/note/JUC/image/%E7%AC%94%E8%AE%B0/image-20200527134243634.png">
<meta property="og:image" content="http://yoursite.com/2020/%E5%8F%AA%E8%A6%81%E5%AD%A6%E4%B8%8D%E6%AD%BB%20%E5%B0%B1%E5%BE%80%E6%AD%BB%E9%87%8C%E5%AD%A6/note/JUC/image/image-20200401163248555.png">
<meta property="og:image" content="http://yoursite.com/2020/%E5%8F%AA%E8%A6%81%E5%AD%A6%E4%B8%8D%E6%AD%BB%20%E5%B0%B1%E5%BE%80%E6%AD%BB%E9%87%8C%E5%AD%A6/note/JUC/image/image-20200401164647991.png">
<meta property="og:image" content="http://yoursite.com/2020/%E5%8F%AA%E8%A6%81%E5%AD%A6%E4%B8%8D%E6%AD%BB%20%E5%B0%B1%E5%BE%80%E6%AD%BB%E9%87%8C%E5%AD%A6/note/JUC/image/%E7%AC%94%E8%AE%B0/image-20200527204622726.png">
<meta property="og:image" content="http://yoursite.com/2020/%E5%8F%AA%E8%A6%81%E5%AD%A6%E4%B8%8D%E6%AD%BB%20%E5%B0%B1%E5%BE%80%E6%AD%BB%E9%87%8C%E5%AD%A6/note/JUC/md/image/image-20200402065727531.png">
<meta property="og:image" content="http://yoursite.com/2020/%E5%8F%AA%E8%A6%81%E5%AD%A6%E4%B8%8D%E6%AD%BB%20%E5%B0%B1%E5%BE%80%E6%AD%BB%E9%87%8C%E5%AD%A6/note/JUC/md/image/image-20200402065940538.png">
<meta property="og:image" content="http://yoursite.com/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20200527224948564.png">
<meta property="og:image" content="http://yoursite.com/2020/%E5%8F%AA%E8%A6%81%E5%AD%A6%E4%B8%8D%E6%AD%BB%20%E5%B0%B1%E5%BE%80%E6%AD%BB%E9%87%8C%E5%AD%A6/note/JUC/image/%E7%AC%94%E8%AE%B0/image-20200527230919030.png">
<meta property="og:image" content="http://yoursite.com/2020/%E5%8F%AA%E8%A6%81%E5%AD%A6%E4%B8%8D%E6%AD%BB%20%E5%B0%B1%E5%BE%80%E6%AD%BB%E9%87%8C%E5%AD%A6/note/JUC/image/%E7%AC%94%E8%AE%B0/image-20200527231134651.png">
<meta property="og:image" content="http://yoursite.com/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20200527231438271.png">
<meta property="og:image" content="http://yoursite.com/2020/%E5%8F%AA%E8%A6%81%E5%AD%A6%E4%B8%8D%E6%AD%BB%20%E5%B0%B1%E5%BE%80%E6%AD%BB%E9%87%8C%E5%AD%A6/note/JUC/image/%E7%AC%94%E8%AE%B0/image-20200527232418283.png">
<meta property="og:image" content="http://yoursite.com/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20200527213938929.png">
<meta property="og:image" content="http://yoursite.com/2020/%E5%8F%AA%E8%A6%81%E5%AD%A6%E4%B8%8D%E6%AD%BB%20%E5%B0%B1%E5%BE%80%E6%AD%BB%E9%87%8C%E5%AD%A6/note/JUC/image/image-20200402065631929.png">
<meta property="og:image" content="http://yoursite.com/2020/%E5%8F%AA%E8%A6%81%E5%AD%A6%E4%B8%8D%E6%AD%BB%20%E5%B0%B1%E5%BE%80%E6%AD%BB%E9%87%8C%E5%AD%A6/note/JUC/image/image-20200402063557639.png">
<meta property="og:image" content="http://yoursite.com/2020/%E5%8F%AA%E8%A6%81%E5%AD%A6%E4%B8%8D%E6%AD%BB%20%E5%B0%B1%E5%BE%80%E6%AD%BB%E9%87%8C%E5%AD%A6/note/JUC/image/%E7%AC%94%E8%AE%B0/image-20200528235029593.png">
<meta property="og:image" content="http://yoursite.com/2020/%E5%8F%AA%E8%A6%81%E5%AD%A6%E4%B8%8D%E6%AD%BB%20%E5%B0%B1%E5%BE%80%E6%AD%BB%E9%87%8C%E5%AD%A6/note/JUC/image/%E7%AC%94%E8%AE%B0/image-20200527234707313.png">
<meta property="og:image" content="http://yoursite.com/2020/%E5%8F%AA%E8%A6%81%E5%AD%A6%E4%B8%8D%E6%AD%BB%20%E5%B0%B1%E5%BE%80%E6%AD%BB%E9%87%8C%E5%AD%A6/note/JUC/image/%E7%AC%94%E8%AE%B0/image-20200527234813608.png">
<meta property="og:image" content="http://yoursite.com/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20200528125043817.png">
<meta property="og:image" content="http://yoursite.com/2020/%E5%8F%AA%E8%A6%81%E5%AD%A6%E4%B8%8D%E6%AD%BB%20%E5%B0%B1%E5%BE%80%E6%AD%BB%E9%87%8C%E5%AD%A6/note/JUC/md/image/image-20200402113830722.png">
<meta property="og:image" content="http://yoursite.com/2020/%E5%8F%AA%E8%A6%81%E5%AD%A6%E4%B8%8D%E6%AD%BB%20%E5%B0%B1%E5%BE%80%E6%AD%BB%E9%87%8C%E5%AD%A6/note/JUC/image/%E7%AC%94%E8%AE%B0/image-20200528124442712.png">
<meta property="og:image" content="http://yoursite.com/2020/%E5%8F%AA%E8%A6%81%E5%AD%A6%E4%B8%8D%E6%AD%BB%20%E5%B0%B1%E5%BE%80%E6%AD%BB%E9%87%8C%E5%AD%A6/note/JUC/md/image/image-20200402120531506.png">
<meta property="og:image" content="http://yoursite.com/2020/%E5%8F%AA%E8%A6%81%E5%AD%A6%E4%B8%8D%E6%AD%BB%20%E5%B0%B1%E5%BE%80%E6%AD%BB%E9%87%8C%E5%AD%A6/note/JUC/image/%E7%AC%94%E8%AE%B0/image-20200528125305588.png">
<meta property="og:image" content="http://yoursite.com/2020/%E5%8F%AA%E8%A6%81%E5%AD%A6%E4%B8%8D%E6%AD%BB%20%E5%B0%B1%E5%BE%80%E6%AD%BB%E9%87%8C%E5%AD%A6/note/JUC/image/%E7%AC%94%E8%AE%B0/image-20200528125402186.png">
<meta property="og:image" content="http://yoursite.com/2020/%E5%8F%AA%E8%A6%81%E5%AD%A6%E4%B8%8D%E6%AD%BB%20%E5%B0%B1%E5%BE%80%E6%AD%BB%E9%87%8C%E5%AD%A6/note/JUC/image/%E7%AC%94%E8%AE%B0/image-20200528131123856.png">
<meta property="og:image" content="http://yoursite.com/2020/%E5%8F%AA%E8%A6%81%E5%AD%A6%E4%B8%8D%E6%AD%BB%20%E5%B0%B1%E5%BE%80%E6%AD%BB%E9%87%8C%E5%AD%A6/note/JUC/md/image/image-20200402124801164.png">
<meta property="og:image" content="http://yoursite.com/2020/%E5%8F%AA%E8%A6%81%E5%AD%A6%E4%B8%8D%E6%AD%BB%20%E5%B0%B1%E5%BE%80%E6%AD%BB%E9%87%8C%E5%AD%A6/note/JUC/md/image/image-20200402172620123.png">
<meta property="og:image" content="http://yoursite.com/2020/%E5%8F%AA%E8%A6%81%E5%AD%A6%E4%B8%8D%E6%AD%BB%20%E5%B0%B1%E5%BE%80%E6%AD%BB%E9%87%8C%E5%AD%A6/note/JUC/md/image/image-20200402172209626.png">
<meta property="og:image" content="http://yoursite.com/2020/%E5%8F%AA%E8%A6%81%E5%AD%A6%E4%B8%8D%E6%AD%BB%20%E5%B0%B1%E5%BE%80%E6%AD%BB%E9%87%8C%E5%AD%A6/note/JUC/image/%E7%AC%94%E8%AE%B0/image-20200528134414349.png">
<meta property="og:image" content="http://yoursite.com/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20200528220820441.png">
<meta property="og:image" content="http://yoursite.com/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20200528220924869.png">
<meta property="og:image" content="http://yoursite.com/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20200528221154743.png">
<meta property="og:image" content="http://yoursite.com/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20200528221314448.png">
<meta property="og:image" content="http://yoursite.com/2020/%E5%8F%AA%E8%A6%81%E5%AD%A6%E4%B8%8D%E6%AD%BB%20%E5%B0%B1%E5%BE%80%E6%AD%BB%E9%87%8C%E5%AD%A6/note/JUC/image/%E7%AC%94%E8%AE%B0/image-20200528222832446.png">
<meta property="og:image" content="http://yoursite.com/2020/%E5%8F%AA%E8%A6%81%E5%AD%A6%E4%B8%8D%E6%AD%BB%20%E5%B0%B1%E5%BE%80%E6%AD%BB%E9%87%8C%E5%AD%A6/note/JUC/image/%E7%AC%94%E8%AE%B0/image-20200528230935451.png">
<meta property="og:image" content="http://yoursite.com/2020/%E5%8F%AA%E8%A6%81%E5%AD%A6%E4%B8%8D%E6%AD%BB%20%E5%B0%B1%E5%BE%80%E6%AD%BB%E9%87%8C%E5%AD%A6/note/JUC/image/%E7%AC%94%E8%AE%B0/image-20200529064306360.png">
<meta property="og:image" content="http://yoursite.com/2020/%E5%8F%AA%E8%A6%81%E5%AD%A6%E4%B8%8D%E6%AD%BB%20%E5%B0%B1%E5%BE%80%E6%AD%BB%E9%87%8C%E5%AD%A6/note/JUC/image/%E7%AC%94%E8%AE%B0/image-20200522221235180.png">
<meta property="og:image" content="http://yoursite.com/2020/%E5%8F%AA%E8%A6%81%E5%AD%A6%E4%B8%8D%E6%AD%BB%20%E5%B0%B1%E5%BE%80%E6%AD%BB%E9%87%8C%E5%AD%A6/note/JUC/md/image/image-20200403195118211.png">
<meta property="og:image" content="http://yoursite.com/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20200531072858642.png">
<meta property="og:image" content="http://yoursite.com/2020/%E5%8F%AA%E8%A6%81%E5%AD%A6%E4%B8%8D%E6%AD%BB%20%E5%B0%B1%E5%BE%80%E6%AD%BB%E9%87%8C%E5%AD%A6/note/JUC/image/%E7%AC%94%E8%AE%B0/image-20200529125814455.png">
<meta property="og:image" content="http://yoursite.com/2020/%E5%8F%AA%E8%A6%81%E5%AD%A6%E4%B8%8D%E6%AD%BB%20%E5%B0%B1%E5%BE%80%E6%AD%BB%E9%87%8C%E5%AD%A6/note/JUC/md/image/image-20200403201506150.png">
<meta property="og:image" content="http://yoursite.com/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20200529125137980.png">
<meta property="og:image" content="http://yoursite.com/2020/%E5%8F%AA%E8%A6%81%E5%AD%A6%E4%B8%8D%E6%AD%BB%20%E5%B0%B1%E5%BE%80%E6%AD%BB%E9%87%8C%E5%AD%A6/note/JUC/image/%E7%AC%94%E8%AE%B0/image-20200529130051594.png">
<meta property="og:image" content="http://yoursite.com/2020/%E5%8F%AA%E8%A6%81%E5%AD%A6%E4%B8%8D%E6%AD%BB%20%E5%B0%B1%E5%BE%80%E6%AD%BB%E9%87%8C%E5%AD%A6/note/JUC/image/%E7%AC%94%E8%AE%B0/image-20200529130142044.png">
<meta property="og:image" content="http://yoursite.com/2020/%E5%8F%AA%E8%A6%81%E5%AD%A6%E4%B8%8D%E6%AD%BB%20%E5%B0%B1%E5%BE%80%E6%AD%BB%E9%87%8C%E5%AD%A6/note/JUC/image/%E7%AC%94%E8%AE%B0/image-20200529130307731.png">
<meta property="og:image" content="http://yoursite.com/2020/%E5%8F%AA%E8%A6%81%E5%AD%A6%E4%B8%8D%E6%AD%BB%20%E5%B0%B1%E5%BE%80%E6%AD%BB%E9%87%8C%E5%AD%A6/note/JUC/md/image/image-20200403203015066.png">
<meta property="og:image" content="http://yoursite.com/2020/%E5%8F%AA%E8%A6%81%E5%AD%A6%E4%B8%8D%E6%AD%BB%20%E5%B0%B1%E5%BE%80%E6%AD%BB%E9%87%8C%E5%AD%A6/note/JUC/md/image/image-20200403195118211.png">
<meta property="og:image" content="http://yoursite.com/2020/%E5%8F%AA%E8%A6%81%E5%AD%A6%E4%B8%8D%E6%AD%BB%20%E5%B0%B1%E5%BE%80%E6%AD%BB%E9%87%8C%E5%AD%A6/note/JUC/md/image/image-20200403201544155.png">
<meta property="og:image" content="http://yoursite.com/2020/%E5%8F%AA%E8%A6%81%E5%AD%A6%E4%B8%8D%E6%AD%BB%20%E5%B0%B1%E5%BE%80%E6%AD%BB%E9%87%8C%E5%AD%A6/note/JUC/image/SE%E7%AC%94%E8%AE%B0/image-20200522120920520.png">
<meta property="og:image" content="http://yoursite.com/2020/%E5%8F%AA%E8%A6%81%E5%AD%A6%E4%B8%8D%E6%AD%BB%20%E5%B0%B1%E5%BE%80%E6%AD%BB%E9%87%8C%E5%AD%A6/note/JUC/image/SE%E7%AC%94%E8%AE%B0/image-20200522120855575.png">
<meta property="og:image" content="http://yoursite.com/2020/%E5%8F%AA%E8%A6%81%E5%AD%A6%E4%B8%8D%E6%AD%BB%20%E5%B0%B1%E5%BE%80%E6%AD%BB%E9%87%8C%E5%AD%A6/note/JUC/image/%E7%AC%94%E8%AE%B0/image-20200522121506135.png">
<meta property="og:image" content="http://yoursite.com/2020/%E5%8F%AA%E8%A6%81%E5%AD%A6%E4%B8%8D%E6%AD%BB%20%E5%B0%B1%E5%BE%80%E6%AD%BB%E9%87%8C%E5%AD%A6/note/JUC/image/SE%E7%AC%94%E8%AE%B0/image-20200522120956504.png">
<meta property="og:image" content="http://yoursite.com/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20200530071412193.png">
<meta property="og:image" content="http://yoursite.com/2020/%E5%8F%AA%E8%A6%81%E5%AD%A6%E4%B8%8D%E6%AD%BB%20%E5%B0%B1%E5%BE%80%E6%AD%BB%E9%87%8C%E5%AD%A6/note/JUC/image/%E7%AC%94%E8%AE%B0/image-20200522121038785.png">
<meta property="og:image" content="http://yoursite.com/2020/%E5%8F%AA%E8%A6%81%E5%AD%A6%E4%B8%8D%E6%AD%BB%20%E5%B0%B1%E5%BE%80%E6%AD%BB%E9%87%8C%E5%AD%A6/note/JUC/image/%E7%AC%94%E8%AE%B0/image-20200522121055638.png">
<meta property="og:image" content="http://yoursite.com/2020/%E5%8F%AA%E8%A6%81%E5%AD%A6%E4%B8%8D%E6%AD%BB%20%E5%B0%B1%E5%BE%80%E6%AD%BB%E9%87%8C%E5%AD%A6/note/JUC/image/SE%E7%AC%94%E8%AE%B0/image-20200522121106590.png">
<meta property="og:image" content="http://yoursite.com/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20200529132654110.png">
<meta property="og:image" content="http://yoursite.com/2020/%E5%8F%AA%E8%A6%81%E5%AD%A6%E4%B8%8D%E6%AD%BB%20%E5%B0%B1%E5%BE%80%E6%AD%BB%E9%87%8C%E5%AD%A6/note/JUC/md/image/image-20200403190747668.png">
<meta property="og:image" content="http://yoursite.com/2020/%E5%8F%AA%E8%A6%81%E5%AD%A6%E4%B8%8D%E6%AD%BB%20%E5%B0%B1%E5%BE%80%E6%AD%BB%E9%87%8C%E5%AD%A6/note/JUC/image/%E7%AC%94%E8%AE%B0/image-20200529133742585.png">
<meta property="og:image" content="http://yoursite.com/2020/%E5%8F%AA%E8%A6%81%E5%AD%A6%E4%B8%8D%E6%AD%BB%20%E5%B0%B1%E5%BE%80%E6%AD%BB%E9%87%8C%E5%AD%A6/note/JUC/image/%E7%AC%94%E8%AE%B0/image-20200529133303945.png">
<meta property="og:image" content="http://yoursite.com/2020/%E5%8F%AA%E8%A6%81%E5%AD%A6%E4%B8%8D%E6%AD%BB%20%E5%B0%B1%E5%BE%80%E6%AD%BB%E9%87%8C%E5%AD%A6/note/JUC/image/%E7%AC%94%E8%AE%B0/image-20200529133426122.png">
<meta property="og:image" content="http://yoursite.com/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/20151202163536892">
<meta property="og:image" content="http://yoursite.com/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/20151202163634814">
<meta property="og:image" content="http://yoursite.com/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20200530065410475.png">
<meta property="og:image" content="http://yoursite.com/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20200530065629729.png">
<meta property="og:image" content="http://yoursite.com/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20200530073303210.png">
<meta property="og:image" content="http://yoursite.com/2020/%E5%8F%AA%E8%A6%81%E5%AD%A6%E4%B8%8D%E6%AD%BB%20%E5%B0%B1%E5%BE%80%E6%AD%BB%E9%87%8C%E5%AD%A6/note/JUC/image/%E7%AC%94%E8%AE%B0/image-20200530075537742.png">
<meta property="og:image" content="http://yoursite.com/2020/%E5%8F%AA%E8%A6%81%E5%AD%A6%E4%B8%8D%E6%AD%BB%20%E5%B0%B1%E5%BE%80%E6%AD%BB%E9%87%8C%E5%AD%A6/note/JUC/image/%E7%AC%94%E8%AE%B0/image-20200530075137625.png">
<meta property="og:image" content="http://yoursite.com/2020/%E5%8F%AA%E8%A6%81%E5%AD%A6%E4%B8%8D%E6%AD%BB%20%E5%B0%B1%E5%BE%80%E6%AD%BB%E9%87%8C%E5%AD%A6/note/JUC/image/%E7%AC%94%E8%AE%B0/image-20200530074810921.png">
<meta property="og:image" content="http://yoursite.com/2020/%E5%8F%AA%E8%A6%81%E5%AD%A6%E4%B8%8D%E6%AD%BB%20%E5%B0%B1%E5%BE%80%E6%AD%BB%E9%87%8C%E5%AD%A6/note/JUC/image/%E7%AC%94%E8%AE%B0/image-20200530093103697.png">
<meta property="og:image" content="http://yoursite.com/2020/%E5%8F%AA%E8%A6%81%E5%AD%A6%E4%B8%8D%E6%AD%BB%20%E5%B0%B1%E5%BE%80%E6%AD%BB%E9%87%8C%E5%AD%A6/note/JUC/image/%E7%AC%94%E8%AE%B0/image-20200530092942647.png">
<meta property="og:image" content="http://yoursite.com/2020/%E5%8F%AA%E8%A6%81%E5%AD%A6%E4%B8%8D%E6%AD%BB%20%E5%B0%B1%E5%BE%80%E6%AD%BB%E9%87%8C%E5%AD%A6/note/JUC/image/%E7%AC%94%E8%AE%B0/image-20200530093324219.png">
<meta property="og:image" content="http://yoursite.com/2020/%E5%8F%AA%E8%A6%81%E5%AD%A6%E4%B8%8D%E6%AD%BB%20%E5%B0%B1%E5%BE%80%E6%AD%BB%E9%87%8C%E5%AD%A6/note/JUC/image/%E7%AC%94%E8%AE%B0/image-20200530093513702.png">
<meta property="og:image" content="http://yoursite.com/2020/%E5%8F%AA%E8%A6%81%E5%AD%A6%E4%B8%8D%E6%AD%BB%20%E5%B0%B1%E5%BE%80%E6%AD%BB%E9%87%8C%E5%AD%A6/note/JUC/image/%E7%AC%94%E8%AE%B0/image-20200530093851923.png">
<meta property="og:image" content="http://yoursite.com/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20200530090527305.png">
<meta property="og:image" content="http://yoursite.com/2020/%E5%8F%AA%E8%A6%81%E5%AD%A6%E4%B8%8D%E6%AD%BB%20%E5%B0%B1%E5%BE%80%E6%AD%BB%E9%87%8C%E5%AD%A6/note/JUC/image/%E7%AC%94%E8%AE%B0/image-20200530092516213.png">
<meta property="og:image" content="http://yoursite.com/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image/%E7%AC%94%E8%AE%B0/image-20200730134028335.png">
<meta property="article:published_time" content="2020-05-23T12:28:49.000Z">
<meta property="article:modified_time" content="2020-08-23T13:11:47.807Z">
<meta property="article:author" content="OiPunk">
<meta property="article:tag" content="Java SE">
<meta property="article:tag" content="多线程">
<meta property="article:tag" content="JUC">
<meta property="article:tag" content="并发编程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/2020/%E5%8F%AA%E8%A6%81%E5%AD%A6%E4%B8%8D%E6%AD%BB%20%E5%B0%B1%E5%BE%80%E6%AD%BB%E9%87%8C%E5%AD%A6/note/JUC/image/image-20200331171617504.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '作者'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2020/05/23/Java并发编程/"/>





  <title>Java并发编程 | 为了明天！</title>
  








<meta name="generator" content="Hexo 4.2.1"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>
    
    <a href="https://github.com/OiPunk" target="_blank" rel="noopener" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>    
    
    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">为了明天！</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">没伞的孩子，请努力奔跑</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            日志
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="OiPunk">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/oi.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="为了明天！">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Java并发编程</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-23T20:28:49+08:00">
                2020-05-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i>
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
            </span>
          

          

          
              <div class="post-description">
                  详解Java中的锁机制，并发容器，线程通信，线程池的原理及使用
              </div>
          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><img src="/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/../../../只要学不死 就往死里学/note/JUC/image/image-20200331171617504.png" alt="image-20200331171731777" style="zoom: 67%;">

<p><img src="/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/01_02.jpg" alt="01_02"></p>
<img src="/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/../../../只要学不死 就往死里学/note/JUC/image/SE笔记/image-20200522121553190.png" alt="image-20200522121553190" style="zoom:67%;">

<p>什么是叫一个进程？ 什么叫一个线程？ </p>
<img src="/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/../../../只要学不死 就往死里学/note/JUC/image/SE笔记/image-20200522121725120.png" alt="image-20200522121725120" style="zoom: 80%;">

<ul>
<li><p>Program app -&gt;QQ.exe</p>
<p><strong>进程：</strong>做一个简单的解释，你的硬盘上有一个简单的程序，这个程序叫QQ.exe，这是一个程序，这个程序是一个静态的概念，它被扔在硬盘上也没人理他，但是当你双击它，弹出一个界面输入账号密码登录进去了，OK，这个时候叫做一个进程。进程相对于程序来说它是一个动态的概念</p>
<p><strong>线程：</strong>作为一个进程里面最小的执行单元它就叫一个线程，用简单的话讲一个程序里不同的执行路径就叫做一个线程</p>
</li>
</ul>
<h4 id="启动线程的五种方式"><a href="#启动线程的五种方式" class="headerlink" title="启动线程的五种方式"></a>启动线程的五种方式</h4><p>1: 继承Thread类    2: 实现Runnable    3: 线程池Executors.newCachedThrad</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.oi.juc.c_000;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T02_HowToCreateThread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"Hello MyThread!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRun</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"Hello MyRun!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCall</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"Hello MyCall"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//启动线程的5种方式</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 继承Thread</span></span><br><span class="line">        <span class="keyword">new</span> MyThread().start();</span><br><span class="line">        <span class="comment">// 实现Runable</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRun()).start();</span><br><span class="line">        <span class="comment">// Lambda</span></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">"Hello Lambda!"</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">		<span class="comment">// 实现Callable</span></span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> FutureTask&lt;String&gt;(<span class="keyword">new</span> MyCall()));</span><br><span class="line">        t.start();</span><br><span class="line">		<span class="comment">// 缓存线程池</span></span><br><span class="line">        ExecutorService service = Executors.newCachedThreadPool();</span><br><span class="line">        service.execute(()-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">"Hello ThreadPool"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        service.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/../../../只要学不死 就往死里学/note/JUC/image/笔记/image-20200526060941085.png" alt="image-20200526060941085" style="zoom:80%;"><img src="/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/../../../只要学不死 就往死里学/note/JUC/image/笔记/image-20200526061909808.png" alt="image-20200526061909808" style="zoom: 80%;"></p>
<h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><p>wait(), join(), LockSupport() 进入waiting状态; notify(), notifyAll(), LockSupport<br>yield() Running –&gt; Ready<br>等待过得同步代码块的锁, 进入Blocked状态, 获得后, 进入Runnale<br><img src="/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/../../../只要学不死 就往死里学/note/JUC/image/SE笔记/image-20200522122259623.png" alt="image-20200522122259623" style="zoom: 50%;"></p>
<img src="/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/../../../只要学不死 就往死里学/note/JUC/image/image-20200331201536720.png" alt="image-20200331201536720">

<p><img src="/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20200526061523926.png" alt></p>
<h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.oi.juc.c_000;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T03_Sleep_Yield_Join</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">					<span class="comment">//testSleep();</span></span><br><span class="line">					<span class="comment">//testYield();</span></span><br><span class="line">        testJoin();</span><br><span class="line">    &#125; </span><br><span class="line">		<span class="comment">/*Sleep,意思就是睡眠，当前线程暂停一段时间让给别的线程去运行。Sleep是怎么复活的？由你的睡眠时间而定，等睡眠到规定的时间自动复活*/</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testSleep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++) &#123;</span><br><span class="line">                System.out.println(<span class="string">"A"</span> + i);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                    <span class="comment">//TimeUnit.Milliseconds.sleep(500)</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">/*Yield,就是当前线程正在执行的时候停止下来进入等待队列，回到等待队列里在系统的调度算法里头呢还是依然有可能把你刚回去的这个线程拿回来继续执行，当然，更大的可能性是把原来等待的那些拿出一个来执行，所以yield的意思是我让出一下CPU，后面你们能不能抢到那我不管*/</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testYield</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++) &#123;</span><br><span class="line">                System.out.println(<span class="string">"A"</span> + i);</span><br><span class="line">                <span class="keyword">if</span>(i%<span class="number">10</span> == <span class="number">0</span>) Thread.yield();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++) &#123;</span><br><span class="line">                System.out.println(<span class="string">"------------B"</span> + i);</span><br><span class="line">                <span class="keyword">if</span>(i%<span class="number">10</span> == <span class="number">0</span>) Thread.yield();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">/*join， 意思就是在自己当前线程加入你调用Join的线程（），本线程等待。等调用的线程运行完了，自己再去执行。t1和t2两个线程，在t1的某个点上调用了t2.join,它会跑到t2去运行，t1等待t2运行完毕继续t1运行（自己join自己没有意义） */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testJoin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++) &#123;</span><br><span class="line">                System.out.println(<span class="string">"A"</span> + i);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                    <span class="comment">//TimeUnit.Milliseconds.sleep(500)</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t1.join();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++) &#123;</span><br><span class="line">                System.out.println(<span class="string">"A"</span> + i);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                    <span class="comment">//TimeUnit.Milliseconds.sleep(500)</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><img src="/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20200331201905775.png" alt="image-20200331201905775"></p>
<img src="/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Users\Anarchism\AppData\Roaming\Typora\typora-user-images\image-20200331201926560.png" alt="image-20200331201926560" style="zoom:67%;">


<img src="/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Users\Anarchism\AppData\Roaming\Typora\typora-user-images\image-20200331202023954.png" alt="image-20200331202023954" style="zoom:67%;">


<img src="/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Users\Anarchism\AppData\Roaming\Typora\typora-user-images\image-20200331202137156.png" alt="image-20200331202137156" style="zoom:67%;">


<img src="/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Users\Anarchism\AppData\Roaming\Typora\typora-user-images\image-20200331202109191.png" alt="image-20200331202109191" style="zoom: 67%;">

<h3 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h3><img src="/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/../../../只要学不死 就往死里学/note/JUC/image/笔记/image-20200526063943625.png" alt="image-20200526063943625" style="zoom:50%;">


<img src="/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/../../../只要学不死 就往死里学/note/JUC/image/笔记/image-20200526063846222.png" alt="image-20200526063846222" style="zoom:80%;">


<img src="/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/../../../只要学不死 就往死里学/note/JUC/image/笔记/image-20200526064256437.png" alt="image-20200526064256437" style="zoom: 80%;">


<img src="/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/../../../只要学不死 就往死里学/note/JUC/image/笔记/image-20200526064338898.png" alt="image-20200526064338898" style="zoom:80%;">


<img src="/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/../../../只要学不死 就往死里学/note/JUC/image/笔记/image-20200526064456019.png" alt="image-20200526064456019" style="zoom:80%;">

<p>这道题加Synchronized就没必要加volatile, synchronized既保证同步, 有保证线程可见</p>
<img src="/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/../../../只要学不死 就往死里学/note/JUC/image/笔记/image-20200526065140791.png" alt="image-20200526065140791" style="zoom:80%;">


<img src="/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Users\Anarchism\AppData\Roaming\Typora\typora-user-images\image-20200331202636319.png" alt="image-20200331202636319">

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">* synchronized关键字</span></span><br><span class="line"><span class="comment"> * 对某个对象加锁</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment"> * 面试题：模拟银行账户</span></span><br><span class="line"><span class="comment"> * 对业务写方法加锁</span></span><br><span class="line"><span class="comment"> * 对业务读方法不加锁</span></span><br><span class="line"><span class="comment"> * 这样行不行？</span></span><br><span class="line"><span class="comment"> * 容易产生脏读问题（dirtyRead）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 同步和非同步方法可以同时调用</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 一个同步方法可以调用另外一个同步方法，一个线程已经拥有某个    对象的锁，再次申请的时候仍然会得到该对象的锁.也就是说          synchronized获得的锁是可重入的</span></span><br><span class="line"><span class="comment">     举例：子类调用父类的同步方法</span></span><br><span class="line"><span class="comment">     </span></span><br><span class="line"><span class="comment"> * 程序在执行过程中，如果出现异常，默认情况锁会被释放</span></span><br><span class="line"><span class="comment"> * 所以，在并发处理的过程中，有异常要多加小心，不然可能会发生不一致的情况。</span></span><br><span class="line"><span class="comment"> * 比如，在一个web app处理过程中，多个servlet线程共同访问同一个资源，这时如果异常处理不合适，</span></span><br><span class="line"><span class="comment"> * 在第一个线程中抛出异常，其他线程就会进入同步代码区，有可能会访问到异常产生时的数据。</span></span><br><span class="line"><span class="comment"> * 因此要非常小心的处理同步业务逻辑中的异常</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">·业务逻辑中只有下面这句需要sync，这时不应该给整个方法上锁</span></span><br><span class="line"><span class="comment">·采用细粒度的锁，可以使线程争用时间变短，从而提高效率</span></span><br><span class="line"><span class="comment">·不要以字符串常量作为锁定对象，比如你用到了一个类库，在该类库中代码锁定了字符串“Hello”，可能发生非常诡异的死锁阻塞</span></span><br><span class="line"><span class="comment">·锁定某对象o，如果o的属性发生改变，不影响锁的使用，但是如果o变成另外一个对象，则锁定的对象发生改变，应该避免将锁定对象的引用变成另外的对象</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">synchronized的底层实现</span></span><br><span class="line"><span class="comment">JDK早期的 重量级 - OS</span></span><br><span class="line"><span class="comment">后来的改进</span></span><br><span class="line"><span class="comment">锁升级的概念：</span></span><br><span class="line"><span class="comment">    我就是厕所所长 （一 二）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">sync (Object)</span></span><br><span class="line"><span class="comment">markword 记录这个线程ID （偏向锁）</span></span><br><span class="line"><span class="comment">如果线程争用：升级为 自旋锁</span></span><br><span class="line"><span class="comment">10次以后，</span></span><br><span class="line"><span class="comment">升级为重量级锁 - OS</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">执行时间短（加锁代码），线程数少，用自旋</span></span><br><span class="line"><span class="comment">执行时间长，线程数多，用系统锁**/</span></span><br></pre></td></tr></table></figure>

<p>多个线程去访问同一个资源的时候对这个资源上锁。</p>
<p>访问某一段代码或者某临界资源的时候是需要有一把锁的概念在这儿的。</p>
<p><img src="/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/01_04.jpg" alt="01_04"></p>
<p>比如：我们对一个数字做递增，两个程序对它一块儿来做递增，递增就是把一个程序往上加1啊，如果两个线程共同访问的时候，第一个线程一读它是0，然后把它加1，在自己线程内部内存里面算还没有写回去的时候而第二个线程读到了它还是0，加1在写回去，本来加了两次，但还是1，那么我们在对这个数字递增的过程当中就上把锁，就是说第一个线程对这个数字访问的时候是独占的，不允许别的线程来访问，不允许别的线程来对它计算，我必须加完1收释放锁，其他线程才能对它继续加。</p>
<p>实质上，这把锁并不是对数字进行锁定的， 你可以任意指定，想锁谁就锁谁。</p>
<img src="/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Users\Anarchism\AppData\Roaming\Typora\typora-user-images\image-20200331202023954.png" alt="image-20200331202023954" style="zoom:67%;">

<ol>
<li>上了把锁之后才能对count进行减减访问，你可以new一个Object，所以这里锁定就是o，当我拿到这把锁的时候才能执行这段代码。是锁定的某一个对象，synchronized有一个锁升级的概念</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*synchronized关键字</span></span><br><span class="line"><span class="comment">*对某个对象加锁</span></span><br><span class="line"><span class="comment">*<span class="doctag">@author</span> oi</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">package</span> com.oi.juc.c_001;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">private</span> Object o = <span class="keyword">new</span> Object();</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">synchronized</span>(o) &#123; <span class="comment">//任何线程要想执行下面的代码，必须先拿到o的锁</span></span><br><span class="line">			count--;</span><br><span class="line">			System.out.println(Thread.currentThread().getName() + <span class="string">" count = "</span> + count);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>synchronized它的一些特性。如果说你每次都定义个一个锁的对象Object o 把它new出来那加锁的时候太麻烦每次都要new一个新的对象出来，所以呢，有一个简单的方式就是<strong>synchronized(this)</strong>锁定当前对象就行</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * synchronized关键字</span></span><br><span class="line"><span class="comment"> * 对某个对象加锁</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> oi</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">package</span> com.oi.juc.c_002;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">10</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123; ߳</span><br><span class="line">            <span class="comment">//任何线程想要执行那个下面的代码，必须先要拿到this的锁</span></span><br><span class="line">      count--;</span><br><span class="line">			System.out.println(Thread.currentThread().getName() + <span class="string">" count = "</span> + count);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>如果你要是锁定当前对象呢，你也可以写成如下方法。synchronized方法和synchronized(this)执行这段代码它是等值的</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.oi.juc.c_003;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">10</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="comment">//等同于在方法的代码执行时要synchronized(this)</span></span><br><span class="line">		count--;</span><br><span class="line">		System.out.println(Thread.currentThread().getName() + <span class="string">" count = "</span> + count);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol start="4">
<li>静态方法static是没有this对象的，你不需要new出一个对象来就能执行这个方法，但如果这个这个上面加一个synchronized的话就代表synchronized(T.class)。这里这个synchronized(T.class)锁的就是T类的对象</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.oi.juc.c_004;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">10</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="comment">//这里等同于synchronized(T.class)</span></span><br><span class="line">		count--;</span><br><span class="line">		System.out.println(Thread.currentThread().getName() + <span class="string">" count = "</span> + count);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mm</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">synchronized</span>(T<span class="class">.<span class="keyword">class</span>) </span>&#123; </span><br><span class="line">            <span class="comment">//考虑一下这里写synchronized(this)是否可以？</span></span><br><span class="line">			count --;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>问题：T.class是单例的吗？</strong></p>
<p>一个类 load到内存它是不是单例的，想想看。一般情况下是，如果是在同一个ClassLoader空间那它一定是。不是同一个类加载器就不是了，不同的类加载器互相之间也不能访问。所以说你能访问它，那他一定就是单例</p>
<ol start="5">
<li>下面程序：很有可能读不到别的线程修改过的内容，除了这点之外count减减完了之后下面的count输出和你减完的结果不对，很容易分析：如果有一个线程把它从10减到9了，然后又有一个线程在前面一个线程还没有输出呢进来了把9又减到了8，继续输出的8，而不是9。如果你想修正它，前面第一个是在上面加volatile，改了马上就能得到。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分析一下这个程序的输出</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> oi</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">package</span> com.oi.juc.c_005;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="comment">/*volatile*/</span> <span class="keyword">int</span> count = <span class="number">100</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="comment">/*synchronized*/</span> <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; </span><br><span class="line">		count--;</span><br><span class="line">		System.out.println(Thread.currentThread().getName() + <span class="string">" count = "</span> + count);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		T t = <span class="keyword">new</span> T();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">new</span> Thread(t, <span class="string">"THREAD"</span> + i).start();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>另外这个之外还可以加synchronized，加了synchronized就没有必要在加volatile了，因为</li>
</ol>
<h4 id="synchronized既保证了原子性，又保证了可见性。"><a href="#synchronized既保证了原子性，又保证了可见性。" class="headerlink" title="synchronized既保证了原子性，又保证了可见性。"></a>synchronized既保证了原子性，又保证了可见性。</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对比上一个小程序</span></span><br><span class="line"><span class="keyword">package</span> com.oi.juc.c_006;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">10</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; </span><br><span class="line">		count--;</span><br><span class="line">		System.out.println(Thread.currentThread().getName() + <span class="string">" count = "</span> + count);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++) &#123;</span><br><span class="line">			T t = <span class="keyword">new</span> T();</span><br><span class="line">			<span class="keyword">new</span> Thread(t, <span class="string">"THREAD"</span> + i).start();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol start="7">
<li>如下代码：同步方法和非同步方法是否可以同时调用？就是我有一个synchronized的m1方法，我调用m1的时候能不能调用m2，拿大腿想一想这个是肯定可以的，线程里面访问m1的时候需要加锁，可是访问m2的时候我又不需要加锁，所以允许执行m2。</li>
</ol>
<p>这些小实验的设计是比较考验功力的，学习线程的时候自己要多动手进行试验，任何一个理论，都可以进行验证。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *同步和非同步方法是否可以同时调用？</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> oi</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">package</span> com.oi.juc.c_007;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123; </span><br><span class="line">		System.out.println(Thread.currentThread().getName() + <span class="string">" m1 start..."</span>);</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(Thread.currentThread().getName() + <span class="string">" m1 end"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(Thread.currentThread().getName() + <span class="string">" m2 "</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		T t = <span class="keyword">new</span> T();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">/*new Thread(()-&gt;t.m1(), "t1").start();</span></span><br><span class="line"><span class="comment">		new Thread(()-&gt;t.m2(), "t2").start();*/</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">new</span> Thread(t::m1, <span class="string">"t1"</span>).start();</span><br><span class="line">		<span class="keyword">new</span> Thread(t::m2, <span class="string">"t2"</span>).start();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		//1.8之前的写法</span></span><br><span class="line"><span class="comment">		new Thread(new Runnable() &#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">			@Override</span></span><br><span class="line"><span class="comment">			public void run() &#123;</span></span><br><span class="line"><span class="comment">				t.m1();</span></span><br><span class="line"><span class="comment">			&#125;</span></span><br><span class="line"><span class="comment">		&#125;);</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol start="8">
<li>我们在来看一个synchronized应用的例子</li>
</ol>
<p>我们定义了一个class账户，有名称、余额。写方法给哪个用户设置它多少余额，读方法通过这个名字得到余额值。如果我们给写方法加锁，给读方法不加锁，你的业务允许产生这种问题吗？业务说我中间读到了一些不太好的数据也没关系，如果不允许客户读到中间不好的数据那这个就有问题。正因为我们加了锁的方法和不加锁的方法可以同时运行。</p>
<p><strong>问题</strong>比如说：张三，给他设置100块钱启动了，睡了1毫秒之后呢去读它的值，然后再睡2秒再去读它的值这个时候你会看到读到的值有问题，原因是在设定的过程中this.name你中间睡了一下，这个过程当中我模拟了一个线程来读，这个时候调用的是getBalance方法，而调用这个方法的时候是不用加锁的，所以说我不需要等你整个过程执行完就可以读到你中间结果产生的内存，这个现象就叫做脏读。这问题的产生就是synchronized方法和非synchronized方法是同时运行的。<strong>解决</strong>就是把getBalance加上synchronized就可以了，如果你的业务允许脏读，就可以不用加锁，加锁之后的效率低下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 面试题：模拟银行账户</span></span><br><span class="line"><span class="comment"> * 对业务写方法加锁</span></span><br><span class="line"><span class="comment"> * 对业务读方法不加锁</span></span><br><span class="line"><span class="comment"> * 这样行不行？</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 容易产生脏读问题（dirtyRead）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">package</span> com.oi.juc.c_008;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">	String name;</span><br><span class="line">	<span class="keyword">double</span> balance;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(String name, <span class="keyword">double</span> balance)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">this</span>.balance = balance;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="comment">/*synchronized*/</span> <span class="function"><span class="keyword">double</span> <span class="title">getBalance</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.balance;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Account a = <span class="keyword">new</span> Account();</span><br><span class="line">		<span class="keyword">new</span> Thread(()-&gt;a.set(<span class="string">"zhangsan"</span>, <span class="number">100.0</span>)).start();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		System.out.println(a.getBalance(<span class="string">"zhangsan"</span>));</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		System.out.println(a.getBalance(<span class="string">"zhangsan"</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Synchronized-是可重入锁"><a href="#Synchronized-是可重入锁" class="headerlink" title="Synchronized 是可重入锁"></a>Synchronized 是可重入锁</h4><p>锁定的是this</p>
<p>再来看synchronized的另外一个属性：可重入，是synchronized必须了解的一个概念。</p>
<p>如果是一个同步方法调用另外一个同步方法，有一个方法加了锁，另外一个方法也需要加锁，加的是同一把锁也是同一个线程，那这个时候申请仍然会得到该对象的锁。比如说是synchronized可重入的，有一个方法m1 是synchronized有一个方法m2也是synchrionzed，m1里能不能调m2。我们m1开始的时候这个线程得到了这把锁，然后在m1里面调用m2，如果说这个时候不允许任何线程再来拿这把锁的时候就死锁了。这个时候调m2它发现是同一个线程，因为你m2也需要申请这把锁，它发现是同一个线程申请的这把锁，允许，可以没问题，这就叫可重入锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 一个同步方法可以调用另外一个同步方法，一个线程已经拥有某个对象的锁，再次申请的时候仍然会得到该对象的锁。</span></span><br><span class="line"><span class="comment"> * 也就是说synchronized获得锁是可重入的</span></span><br><span class="line"><span class="comment"> * synchronized</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> oi</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">package</span> com.oi.juc.c_009;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"m1 start"</span>);</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		m2();</span><br><span class="line">		System.out.println(<span class="string">"m1 end"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">"m2"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">new</span> T().m1();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>模拟一个父类子类的概念，父类synchronized，子类调用super.m的时候必须得可重入，否则就会出问题（调用父类是同一把锁）。所谓的重入锁就是你拿到这把锁之后不停加锁加锁，加好几道，但锁定的还是同一个对象，去一道就减个1，就是这么个概念。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.oi.juc.c_010;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"m start"</span>);</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">"m end"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">new</span> TT().m();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TT</span> <span class="keyword">extends</span> <span class="title">T</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"child m start"</span>);</span><br><span class="line">		<span class="keyword">super</span>.m();</span><br><span class="line">		System.out.println(<span class="string">"child m end"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 程序在执行过程中，如果出现异常，默认情况锁会被释放</span></span><br><span class="line"><span class="comment"> * 所以，在并发处理的过程中，有异常要多加小心，不然可能会发生不一致的情况。</span></span><br><span class="line"><span class="comment"> * 比如，在一个web app处理过程中，多个servlet线程共同访问同一个资源，这时如果异常处理不合适，</span></span><br><span class="line"><span class="comment"> * 在第一个线程中抛出异常，其他线程就会进入同步代码区，有可能会访问到异常产生时的数据。</span></span><br><span class="line"><span class="comment"> * 因此要非常小心的处理同步业务逻辑中的异常</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h4 id="synchronized的底层实现"><a href="#synchronized的底层实现" class="headerlink" title="synchronized的底层实现"></a>synchronized的底层实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">synchronized的底层实现</span><br><span class="line">JDK早期的 重量级 - OS</span><br><span class="line">后来的改进</span><br><span class="line">锁升级的概念：</span><br><span class="line">    我就是厕所所长 （一 二）</span><br><span class="line"></span><br><span class="line">sync (Object)</span><br><span class="line">0.无锁: 没有对资源进行锁定，所有的线程都能访问并修改同一个资源，但同时只有一个线程能修改成功。</span><br><span class="line">1.偏向锁: markword 记录这个线程ID 没加锁, 默认不会有线程抢这把锁</span><br><span class="line">2.自旋锁(CAS): 如果线程争用：升级为 自旋锁 默认10次以后，</span><br><span class="line">3.重量级锁: 向操作系统内核申请, 等待时不占用CPU</span><br><span class="line"></span><br><span class="line">执行时间短（加锁代码），线程数少，用自旋</span><br><span class="line">执行时间长，线程数多，用系统锁</span><br></pre></td></tr></table></figure>


<img src="/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/../../../只要学不死 就往死里学/note/JUC/image/多线程/image-20200526234924652.png" alt="image-20200526234924652" style="zoom:80%;">


<img src="/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/../../../只要学不死 就往死里学/note/JUC/image/笔记/image-20200526064113021.png" alt="image-20200526064113021" style="zoom:67%;">


<img src="/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/../../../只要学不死 就往死里学/note/JUC/image/笔记/image-20200527055724201.png" alt="image-20200527055724201" style="zoom:67%;">

<h3 id="Volatile"><a href="#Volatile" class="headerlink" title="Volatile"></a>Volatile</h3><img src="/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/../../../只要学不死 就往死里学/note/JUC/image/笔记/image-20200527061309216.png" alt="image-20200527061309216" style="zoom: 50%;">

<h4 id="保证线程可见性"><a href="#保证线程可见性" class="headerlink" title="保证线程可见性"></a>保证线程可见性</h4><img src="/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Users\Anarchism\AppData\Roaming\Typora\typora-user-images\image-20200331210227033.png" alt="image-20200331210227033" style="zoom:67%;">

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">volatile 关键字，使一个变量在多个线程间可见</span></span><br><span class="line"><span class="comment">A B线程都用到一个变量，java默认是A线程中保留一份copy，这样如果B线程修改了该变量，则A线程未必知道</span></span><br><span class="line"><span class="comment">使用volatile关键字，会让所有线程都会读到变量的修改值</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">在下面的代码中，running是存在于堆内存的t对象中</span></span><br><span class="line"><span class="comment">当线程t1开始运行的时候，会把running值从内存中读到t1线程的工作区，在运行过程中直接使用这个copy，并不会每次都去</span></span><br><span class="line"><span class="comment">读取堆内存，这样，当主线程修改running的值之后，t1线程感知不到，所以不会停止运行</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">使用volatile，将会强制所有线程都去堆内存中读取running的值</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">可以阅读这篇文章进行更深入的理解</span></span><br><span class="line"><span class="comment">http://www.cnblogs.com/nexiyi/p/java_memory_model_and_thread.html</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">volatile并不能保证多个线程共同修改running变量时所带来的不一致问题，也就是说volatile不能替代synchronized</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">*synchronized可以保证可见性和原子性，volatile只能保证可见性</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure>

<h4 id="禁止指令重排序"><a href="#禁止指令重排序" class="headerlink" title="禁止指令重排序"></a>禁止指令重排序</h4><p>synchronized+双重检查的单例模式要加volatile，防止指令重排序</p>
<p>why?</p>
<p>new对象过程(四条指令)：</p>
<p>​      1）给instance实例分配内存；</p>
<p>　　2）初始化instance的构造器；</p>
<p>　　3）将instance对象指向分配的内存空间（注意到这步时instance就非null了）</p>
<p>　　如果指令按照顺序执行倒也无妨，但JVM为了优化指令，提高程序运行效率，允许指令重排序。如此，在程序真正运行时以上指令执行顺序可能是这样的：</p>
<p>　　a）给instance实例分配内存；</p>
<p>　　b）将instance对象指向分配的内存空间；</p>
<p>　　c）初始化instance的构造器；</p>
<p>　　这时候，当线程一执行b）完毕，在执行c）之前，被切换到线程二上，这时候instance判断为非空，此时线程二直接来到return instance语句，拿走instance然后使用，接着就顺理成章地报错（对象尚未初始化）。</p>
<p><img src="/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20200527062720639.png" alt="image-20200527062720639"></p>
<p>volatile保证a初始化之后再赋值给变量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mgr06</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Mgr06 INSTANCE; <span class="comment">//JIT</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Mgr06</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Mgr06 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//双重检查</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Mgr06<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(INSTANCE == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    INSTANCE = <span class="keyword">new</span> Mgr06();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<img src="/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/../../../只要学不死 就往死里学/note/JUC/image/笔记/image-20200527062234223.png" alt="image-20200527062234223" style="zoom:67%;">

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">·volatile 引用类型（包括数组）只能保证引用本身的可见性，不能保证内部字段的可见性</span><br><span class="line">·volatile并不能保证多个线程共同修改变量时，所带来的不一致问题，也就是说volatile不能替代synchronized</span><br><span class="line">·synchronized可以保证可见性和原子性，volatile只能保证可见性</span><br><span class="line"> * 同步代码块中的语句越少越好</span><br></pre></td></tr></table></figure>

<h4 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * synchronized优化</span></span><br><span class="line"><span class="comment"> * 同步代码块中的语句越少越好</span></span><br><span class="line"><span class="comment"> * 比较m1和m2</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> oi</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FineCoarseLock</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">//do sth need not sync</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//业务逻辑中只有下面这句需要sync，这时不应该给整个方法上锁</span></span><br><span class="line">      count ++;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//do sth need not sync</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">//do sth need not sync</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//业务逻辑中只有下面这句需要sync，这时不应该给整个方法上锁</span></span><br><span class="line">      <span class="comment">//采用细粒度的锁，可以使线程争用时间变短，从而提高效率</span></span><br><span class="line">      <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">         count++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//do sth need not sync</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Synchronized注意事项"><a href="#Synchronized注意事项" class="headerlink" title="Synchronized注意事项"></a>Synchronized注意事项</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 不要以字符串常量作为锁定对象</span></span><br><span class="line"><span class="comment"> * 在下面的例子中，m1和m2其实锁定的是同一个对象</span></span><br><span class="line"><span class="comment"> * 这种情况还会发生比较诡异的现象，比如你用到了一个类库，在该类库中代码锁定了字符串“Hello”，</span></span><br><span class="line"><span class="comment"> * 但是你读不到源码，所以你在自己的代码中也锁定了"Hello",这时候就有可能发生非常诡异的死锁阻塞，</span></span><br><span class="line"><span class="comment"> * 因为你的程序和你用到的类库不经意间使用了同一把锁</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 锁定某对象o，如果o的属性发生改变，不影响锁的使用</span></span><br><span class="line"><span class="comment"> * 但是如果o变成另外一个对象，则锁定的对象发生改变</span></span><br><span class="line"><span class="comment"> * 应该避免将锁定对象的引用变成另外的对象</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><h4 id="CAS-Atomic类"><a href="#CAS-Atomic类" class="headerlink" title="CAS / Atomic类"></a>CAS / Atomic类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 解决同样的问题的更高效的方法，使用AtomXXX类</span></span><br><span class="line"><span class="comment">* AtomXXX类本身方法都是原子性的，但不能保证多个方法连续调用是原子性的</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure>



<p>CAS是CPU原语支持，判断之后不会被打断</p>
<p>ABA问题：基本类型不影响，引用类型会产生ABA</p>
<p>AtomicStampReference 类, 加时间戳解决ABA问题</p>
<h5 id="CAS调用的是Unsafe"><a href="#CAS调用的是Unsafe" class="headerlink" title="CAS调用的是Unsafe"></a>CAS调用的是Unsafe</h5><img src="/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Users\Anarchism\AppData\Roaming\Typora\typora-user-images\image-20200331230925283.png" alt="image-20200331230925283" style="zoom:67%;">

<p>JDK11 CompareAndSet 1.8 CompareAndSwap</p>
<img src="/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Users\Anarchism\AppData\Roaming\Typora\typora-user-images\image-20200401054224292.png" alt="image-20200401054224292" style="zoom:67%;">

<h5 id="CAS是乐观锁"><a href="#CAS是乐观锁" class="headerlink" title="CAS是乐观锁"></a>CAS是乐观锁</h5><img src="/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Users\Anarchism\AppData\Roaming\Typora\typora-user-images\image-20200331231024356.png" alt="image-20200331231024356" style="zoom:67%;">

<h5 id="ABA问题怎么解决"><a href="#ABA问题怎么解决" class="headerlink" title="ABA问题怎么解决"></a>ABA问题怎么解决</h5><ol>
<li>AtomicStampedReference：带版本戳的原子引用类型，版本戳为int类型。</li>
<li>AtomicMarkableReference：带版本戳的原子引用类型，版本戳为boolean类型。(只能降低概率, 不能避免)</li>
</ol>
<h5 id="乐观锁（-Optimistic-Locking-）"><a href="#乐观锁（-Optimistic-Locking-）" class="headerlink" title="乐观锁（ Optimistic Locking ）"></a>乐观锁（ Optimistic Locking ）</h5><p>乐观锁是相对悲观锁而言的，乐观锁假设数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则返回给用户错误的信息，让用户决定如何去做。</p>
<p>相对于悲观锁，在对数据库进行处理的时候，乐观锁并不会使用数据库提供的锁机制。一般的实现乐观锁的方式就是记录数据版本。</p>
<h5 id="悲观锁（Pessimistic-Lock）"><a href="#悲观锁（Pessimistic-Lock）" class="headerlink" title="悲观锁（Pessimistic Lock）"></a>悲观锁（Pessimistic Lock）</h5><p>当我们要对一个数据库中的一条数据进行修改的时候，为了避免同时被其他人修改，最好的办法就是直接对该数据进行加锁以防止并发。这种借助数据库锁机制，在修改数据之前先锁定，再修改的方式被称之为悲观并发控制（又名“悲观锁”，Pessimistic Concurrency Control，缩写“PCC”）</p>
<p><strong>悲观锁主要是共享锁或排他锁</strong></p>
<ul>
<li>共享锁又称为读锁，简称S锁。顾名思义，共享锁就是多个事务对于同一数据可以共享一把锁，都能访问到数据，但是只能读不能修改。</li>
<li>排他锁又称为写锁，简称X锁。顾名思义，排他锁就是不能与其他锁并存，如果一个事务获取了一个数据行的排他锁，其他事务就不能再获取该行的其他锁，包括共享锁和排他锁，但是获取排他锁的事务是可以对数据行读取和修改。</li>
</ul>
<p>悲观并发控制实际上是“先取锁再访问”的保守策略，为数据处理的安全提供了保证。</p>
<h5 id="三种原子操作对比"><a href="#三种原子操作对比" class="headerlink" title="三种原子操作对比"></a>三种原子操作对比</h5><p>1000线程结果:<br><img src="/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20200527124006570.png" alt="image-20200527124006570"></p>
<h5 id="LongAdder-分段锁-也是CAS操作"><a href="#LongAdder-分段锁-也是CAS操作" class="headerlink" title="LongAdder: 分段锁: 也是CAS操作"></a>LongAdder: 分段锁: 也是CAS操作</h5><p>1000个线程, 分四段锁(250), 最后求和<br><img src="/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/../../../只要学不死 就往死里学/note/JUC/image/笔记/image-20200527124346716.png" alt="image-20200527124346716" style="zoom:67%;"></p>
<p>线程数量少，LongAdder不一定有优势</p>
<p>线程数量少, synchronized反而有优势<br><img src="/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/../../../只要学不死 就往死里学/note/JUC/image/笔记/image-20200527124231381.png" alt="image-20200527124231381" style="zoom:67%;"></p>
<h4 id="ReentrantLock-可重入锁"><a href="#ReentrantLock-可重入锁" class="headerlink" title="ReentrantLock : 可重入锁"></a>ReentrantLock : 可重入锁</h4><p>Synchronized加在同一类的不同方法, 相当于synchrnized this, 是同一把锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">reentrantlock(可重入锁)用于替代<span class="keyword">synchronized</span></span><br><span class="line">比<span class="keyword">synchronized</span>功能多</span><br><span class="line"></span><br><span class="line"><span class="keyword">synchronized</span>:自动解锁</span><br><span class="line">Reentrantlock:手动解锁, 一定要解锁, 不能影响后边的线程 <span class="keyword">try</span>/<span class="keyword">catch</span>/<span class="keyword">finally</span></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * reentrantlock用于替代synchronized</span></span><br><span class="line"><span class="comment"> * 由于m1锁定this,只有m1执行完毕的时候,m2才能执行</span></span><br><span class="line"><span class="comment"> * 这里是复习synchronized最原始的语义</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 使用reentrantlock可以完成同样的功能</span></span><br><span class="line"><span class="comment"> * 需要注意的是，必须要必须要必须要手动释放锁（重要的事情说三遍）</span></span><br><span class="line"><span class="comment"> * 使用syn锁定的话如果遇到异常，jvm会自动释放锁，但是lock必须手动释放锁，因此经常在finally中进行锁的释放</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line">    </span><br><span class="line"> <span class="comment">/* 使用reentrantlock可以进行“尝试锁定”tryLock，这样无法锁定，或者在指定时间内无法锁定，线程可以决定是否继续等待*/</span></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T03_ReentrantLock3</span> </span>&#123;</span><br><span class="line">	Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			lock.lock();</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">				TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">				System.out.println(i);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			lock.unlock();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 使用tryLock进行尝试锁定，不管锁定与否，方法都将继续执行</span></span><br><span class="line"><span class="comment">	 * 可以根据tryLock的返回值来判定是否锁定</span></span><br><span class="line"><span class="comment">	 * 也可以指定tryLock的时间，由于tryLock(time)抛出异常，所以要注意unclock的处理，必须放到finally中</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		boolean locked = lock.tryLock();</span></span><br><span class="line"><span class="comment">		System.out.println("m2 ..." + locked);</span></span><br><span class="line"><span class="comment">		if(locked) lock.unlock();</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">		<span class="keyword">boolean</span> locked = <span class="keyword">false</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			locked = lock.tryLock(<span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line">			System.out.println(<span class="string">"m2 ..."</span> + locked);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			<span class="keyword">if</span>(locked) lock.unlock();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		T03_ReentrantLock3 rl = <span class="keyword">new</span> T03_ReentrantLock3();</span><br><span class="line">		<span class="keyword">new</span> Thread(rl::m1).start();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">new</span> Thread(rl::m2).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="lockIntenrrupt打断"><a href="#lockIntenrrupt打断" class="headerlink" title="lockIntenrrupt打断"></a>lockIntenrrupt打断</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 使用ReentrantLock还可以调用lockInterruptibly方法，可以对线程interrupt方法做出响应，</span></span><br><span class="line"><span class="comment"> * 在一个线程等待锁的过程中，可以被打断*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T04_ReentrantLock4</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">		Thread t1 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				lock.lock();</span><br><span class="line">				System.out.println(<span class="string">"t1 start"</span>);</span><br><span class="line">				TimeUnit.SECONDS.sleep(Integer.MAX_VALUE);</span><br><span class="line">				System.out.println(<span class="string">"t1 end"</span>);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				System.out.println(<span class="string">"interrupted!"</span>);</span><br><span class="line">			&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">				lock.unlock();</span><br><span class="line">			&#125;&#125;);</span><br><span class="line">		t1.start();</span><br><span class="line">		Thread t2 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="comment">//lock.lock();</span></span><br><span class="line">				lock.lockInterruptibly(); <span class="comment">//可以对interrupt()方法做出响应</span></span><br><span class="line">				System.out.println(<span class="string">"t2 start"</span>);</span><br><span class="line">				TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">				System.out.println(<span class="string">"t2 end"</span>);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				System.out.println(<span class="string">"interrupted!"</span>);</span><br><span class="line">			&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">				lock.unlock();</span><br><span class="line">            &#125;&#125;);</span><br><span class="line">		t2.start();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		t2.interrupt(); <span class="comment">//打断线程2的等待</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="ReentrantLock默认是非公平-可设置为公平锁"><a href="#ReentrantLock默认是非公平-可设置为公平锁" class="headerlink" title="ReentrantLock默认是非公平, 可设置为公平锁"></a>ReentrantLock默认是非公平, 可设置为公平锁</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/*ReentrantLock还可以指定为公平锁*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ReentrantLock lock=<span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>); <span class="comment">//参数为true表示为公平锁，请对比输出结果</span></span><br></pre></td></tr></table></figure>

<h5 id="ReentrantLock-Vs-Synchronized"><a href="#ReentrantLock-Vs-Synchronized" class="headerlink" title="ReentrantLock Vs Synchronized"></a>ReentrantLock Vs Synchronized</h5><img src="/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/../../../只要学不死 就往死里学/note/JUC/image/笔记/image-20200527130123437.png" alt="image-20200527130123437" style="zoom: 80%;">

<h4 id="CountDownLatch-倒数发车"><a href="#CountDownLatch-倒数发车" class="headerlink" title="CountDownLatch : 倒数发车"></a>CountDownLatch : 倒数发车</h4><ul>
<li>类似 Join : 门闩作用</li>
<li>CountDownLatch.countDown(); 是原子操作</li>
<li>latch.await(); 阻塞住  countDown到0的时候, 继续执行</li>
<li>latch.countDown();  latch数减一</li>
<li>对比Join: CountDownLatch更灵活</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T06_TestCountDownLatch</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        usingJoin();</span><br><span class="line">        usingCountDownLatch();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">usingCountDownLatch</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 启100个线程, latch = 线程数</span></span><br><span class="line">        Thread[] threads = <span class="keyword">new</span> Thread[<span class="number">100</span>];</span><br><span class="line">        CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(threads.length);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;threads.length; i++) &#123;</span><br><span class="line">            threads[i] = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">10000</span>; j++) result += j;</span><br><span class="line">                latch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threads.length; i++) &#123;</span><br><span class="line">            threads[i].start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            latch.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"end latch"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">usingJoin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread[] threads = <span class="keyword">new</span> Thread[<span class="number">100</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;threads.length; i++) &#123;</span><br><span class="line">            threads[i] = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">10000</span>; j++) result += j;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threads.length; i++) &#123;</span><br><span class="line">            threads[i].start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threads.length; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                threads[i].join();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"end join"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="CyclicBarrier-人满发车"><a href="#CyclicBarrier-人满发车" class="headerlink" title="CyclicBarrier : 人满发车"></a>CyclicBarrier : 人满发车</h4><ul>
<li>自己指定发车的线程数量<img src="/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/../../../只要学不死 就往死里学/note/JUC/md/image/image-20200401153822854.png" alt="image-20200401153822854" style="zoom: 67%;">

</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//CyclicBarrier barrier = new CyclicBarrier(20);</span></span><br><span class="line">    CyclicBarrier barrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">20</span>, () -&gt; System.out.println(<span class="string">"满人"</span>));</span><br><span class="line">    <span class="comment">/*CyclicBarrier barrier = new CyclicBarrier(20, new Runnable() &#123;</span></span><br><span class="line"><span class="comment">        @Override</span></span><br><span class="line"><span class="comment">        public void run() &#123;</span></span><br><span class="line"><span class="comment">            System.out.println("满人，发车");</span></span><br><span class="line"><span class="comment">        &#125;&#125;);*/</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    barrier.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>谷歌开源的组件</p>
<p>配合Zuul网关<br><img src="/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/../../../只要学不死 就往死里学/note/JUC/image/笔记/image-20200527132511607.png" alt="image-20200527132511607" style="zoom:67%;"></p>
<h4 id="Phaser-相位器"><a href="#Phaser-相位器" class="headerlink" title="Phaser: 相位器"></a>Phaser: 相位器</h4><p>婚礼环节举例, 遗传算法, 一个一个的栅栏<br><img src="/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/../../../只要学不死 就往死里学/note/JUC/image/image-20200401153718039.png" alt="image-20200401153718039" style="zoom:50%;"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MarriagePhaser</span> <span class="keyword">extends</span> <span class="title">Phaser</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">onAdvance</span><span class="params">(<span class="keyword">int</span> phase, <span class="keyword">int</span> registeredParties)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (phase) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                System.out.println(<span class="string">"所有人到齐了！"</span> + registeredParties);</span><br><span class="line">                System.out.println();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                System.out.println(<span class="string">"所有人吃完了！"</span> + registeredParties);</span><br><span class="line">                System.out.println();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                System.out.println(<span class="string">"所有人离开了！"</span> + registeredParties);</span><br><span class="line">                System.out.println();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                System.out.println(<span class="string">"婚礼结束！新郎新娘抱抱！"</span> + registeredParties);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ReadWriteLock-读写锁-共享锁-读锁-排它锁-写锁"><a href="#ReadWriteLock-读写锁-共享锁-读锁-排它锁-写锁" class="headerlink" title="ReadWriteLock 读写锁 [ 共享锁 (读锁) + 排它锁 (写锁) ]"></a>ReadWriteLock 读写锁 [ 共享锁 (读锁) + 排它锁 (写锁) ]</h4><ul>
<li>读读共享</li>
<li>读写共享</li>
<li>写写排他</li>
</ul>
<img src="/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/../../../只要学不死 就往死里学/note/JUC/image/笔记/image-20200527134243634.png" alt="image-20200527134243634" style="zoom:80%;">

<p><a href="https://www.jianshu.com/p/9cd5212c8841" target="_blank" rel="noopener">https://www.jianshu.com/p/9cd5212c8841</a></p>
<ol>
<li>Java并发库中ReetrantReadWriteLock实现了ReadWriteLock接口并添加了可重入的特性</li>
<li>ReentrantReadWriteLock读写锁的效率明显高于synchronized关键字</li>
<li>ReentrantReadWriteLock读写锁的实现中，读锁使用共享模式；写锁使用独占模式，换句话说，读锁可以在没有写锁的时候被多个线程同时持有，写锁是独占的</li>
<li>ReetrantReadWriteLock读写锁的实现中，需要注意的，当有读锁时，写锁就不能获得；而当有写锁时，除了获得写锁的这个线程可以获得读锁外，其他线程不能获得读锁</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T10_TestReadWriteLock</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">static</span> ReadWriteLock readWriteLock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">    <span class="keyword">static</span> Lock readLock = readWriteLock.readLock();</span><br><span class="line">    <span class="keyword">static</span> Lock writeLock = readWriteLock.writeLock();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(Lock lock)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            System.out.println(<span class="string">"read over!"</span>);</span><br><span class="line">            <span class="comment">//模拟读取操作</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(Lock lock, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            value = v;</span><br><span class="line">            System.out.println(<span class="string">"write over!"</span>);</span><br><span class="line">            <span class="comment">//模拟写操作</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//Runnable readR = ()-&gt; read(lock);</span></span><br><span class="line">        Runnable readR = ()-&gt; read(readLock);</span><br><span class="line">        <span class="comment">//Runnable writeR = ()-&gt;write(lock, new Random().nextInt());</span></span><br><span class="line">        Runnable writeR = ()-&gt;write(writeLock, <span class="keyword">new</span> Random().nextInt());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">18</span>; i++) <span class="keyword">new</span> Thread(readR).start();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">2</span>; i++) <span class="keyword">new</span> Thread(writeR).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Semaphore-限流-默认非公平-可改fair参数"><a href="#Semaphore-限流-默认非公平-可改fair参数" class="headerlink" title="Semaphore: 限流, 默认非公平, 可改fair参数"></a>Semaphore: 限流, 默认非公平, 可改fair参数</h4><p>AbstractQuenedSynchronizer抽象的队列式同步器</p>
<img src="/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/../../../只要学不死 就往死里学/note/JUC/image/image-20200401163248555.png" alt="image-20200401163248555" style="zoom: 67%;">

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//Semaphore s = new Semaphore(2);</span></span><br><span class="line">    <span class="comment">//默认非公平</span></span><br><span class="line">    Semaphore s = <span class="keyword">new</span> Semaphore(<span class="number">2</span>, <span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">//允许一个线程同时执行</span></span><br><span class="line">    <span class="comment">//Semaphore s = new Semaphore(1);</span></span><br><span class="line">    <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            s.acquire(); <span class="comment">// 获得许可, 谁得到, 谁执行</span></span><br><span class="line">            System.out.println(<span class="string">"T1 running..."</span>);</span><br><span class="line">            Thread.sleep(<span class="number">200</span>);</span><br><span class="line">            System.out.println(<span class="string">"T1 running..."</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            s.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">    <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            s.acquire();</span><br><span class="line">            System.out.println(<span class="string">"T2 running..."</span>);</span><br><span class="line">            Thread.sleep(<span class="number">200</span>);</span><br><span class="line">            System.out.println(<span class="string">"T2 running..."</span>);</span><br><span class="line">            s.release();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Exchanger-执行到交换方法后阻塞-然后线程交换数据"><a href="#Exchanger-执行到交换方法后阻塞-然后线程交换数据" class="headerlink" title="Exchanger: 执行到交换方法后阻塞, 然后线程交换数据"></a>Exchanger: 执行到交换方法后阻塞, 然后线程交换数据</h4><p>两个线程之间, 一个线程命令另一个线程阻塞, 交换数据, 继续执行<br><img src="/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/../../../只要学不死 就往死里学/note/JUC/image/image-20200401164647991.png" alt="image-20200401164647991" style="zoom:50%;"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Exchanger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T12_TestExchanger</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Exchanger&lt;String&gt; exchanger = <span class="keyword">new</span> Exchanger&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            String s = <span class="string">"T1"</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                s = exchanger.exchange(s);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" "</span> + s);</span><br><span class="line"></span><br><span class="line">        &#125;, <span class="string">"t1"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            String s = <span class="string">"T2"</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                s = exchanger.exchange(s);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" "</span> + s);</span><br><span class="line"></span><br><span class="line">        &#125;, <span class="string">"t2"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="三道线程通信面试题"><a href="#三道线程通信面试题" class="headerlink" title="三道线程通信面试题"></a>三道线程通信面试题</h4><h5 id="到五停止"><a href="#到五停止" class="headerlink" title="到五停止"></a>到五停止</h5><blockquote>
<p>实现一个容器，提供两个方法，add，size<br>写两个线程，线程1添加10个元素到容器中，线程2实现监控元素的个数，当个数到5个时，线程2给出提示并结束</p>
</blockquote>
<h6 id="wait-notify"><a href="#wait-notify" class="headerlink" title="wait / notify"></a>wait / notify</h6><p><strong>notify()不释放锁</strong></p>
<p><strong>wait()释放锁</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 这里使用wait和notify做到，wait会释放锁，而notify不会释放锁</span></span><br><span class="line"><span class="comment"> * 需要注意的是，运用这种方法，必须要保证t2先执行，也就是首先让t2监听才可以</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * notify之后，t1必须释放锁，t2退出后，也必须notify，通知t1继续执行</span></span><br><span class="line"><span class="comment"> * 整个通信过程比较繁琐</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">package</span> com.oi.juc.c_020_01_Interview;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T04_NotifyFreeLock</span> </span>&#123;</span><br><span class="line">	<span class="comment">//添加volatile，使t2能够得到通知</span></span><br><span class="line">	<span class="keyword">volatile</span> List lists = <span class="keyword">new</span> ArrayList();</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">		lists.add(o);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> lists.size();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		T04_NotifyFreeLock c = <span class="keyword">new</span> T04_NotifyFreeLock();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">			<span class="keyword">synchronized</span>(lock) &#123;</span><br><span class="line">				System.out.println(<span class="string">"t2启动"</span>);</span><br><span class="line">				<span class="keyword">if</span>(c.size() != <span class="number">5</span>) &#123;</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						lock.wait();</span><br><span class="line">					&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">						e.printStackTrace();</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				System.out.println(<span class="string">"t2 结束"</span>);</span><br><span class="line">				<span class="comment">//通知t1继续执行</span></span><br><span class="line">				lock.notify();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;, <span class="string">"t2"</span>).start();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e1) &#123;</span><br><span class="line">			e1.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">			System.out.println(<span class="string">"t1启动"</span>);</span><br><span class="line">			<span class="keyword">synchronized</span>(lock) &#123;</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">					c.add(<span class="keyword">new</span> Object());</span><br><span class="line">					System.out.println(<span class="string">"add "</span> + i);</span><br><span class="line">					</span><br><span class="line">					<span class="keyword">if</span>(c.size() == <span class="number">5</span>) &#123;</span><br><span class="line">						lock.notify();</span><br><span class="line">						<span class="comment">//释放锁，让t2得以执行</span></span><br><span class="line">						<span class="keyword">try</span> &#123;</span><br><span class="line">							lock.wait();</span><br><span class="line">						&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">							e.printStackTrace();</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">					&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">						e.printStackTrace();</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;, <span class="string">"t1"</span>).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 使用Latch（门闩）替代wait notify来进行通知</span></span><br><span class="line"><span class="comment"> * 好处是通信方式简单，同时也可以指定等待时间</span></span><br><span class="line"><span class="comment"> * 使用await和countdown方法替代wait和notify</span></span><br><span class="line"><span class="comment"> * CountDownLatch不涉及锁定，当count的值为零时当前线程继续运行</span></span><br><span class="line"><span class="comment"> * 当不涉及同步，只是涉及线程通信的时候，用synchronized + wait/notify就显得太重了</span></span><br><span class="line"><span class="comment"> * 这时应该考虑countdownlatch/cyclicbarrier/semaphore</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T05_CountDownLatch</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 添加volatile，使t2能够得到通知</span></span><br><span class="line">	<span class="keyword">volatile</span> List lists = <span class="keyword">new</span> ArrayList();</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">		lists.add(o);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> lists.size();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		T05_CountDownLatch c = <span class="keyword">new</span> T05_CountDownLatch();</span><br><span class="line">		CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">			System.out.println(<span class="string">"t2启动"</span>);</span><br><span class="line">			<span class="keyword">if</span> (c.size() != <span class="number">5</span>) &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					latch.await();</span><br><span class="line">					</span><br><span class="line">					<span class="comment">//也可以指定等待时间</span></span><br><span class="line">					<span class="comment">//latch.await(5000, TimeUnit.MILLISECONDS);</span></span><br><span class="line">				&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(<span class="string">"t2 结束"</span>);</span><br><span class="line"></span><br><span class="line">		&#125;, <span class="string">"t2"</span>).start();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e1) &#123;</span><br><span class="line">			e1.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">			System.out.println(<span class="string">"t1启动"</span>);</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">				c.add(<span class="keyword">new</span> Object());</span><br><span class="line">				System.out.println(<span class="string">"add "</span> + i);</span><br><span class="line">				<span class="keyword">if</span> (c.size() == <span class="number">5</span>) &#123;</span><br><span class="line">					<span class="comment">// 打开门闩，让t2得以执行</span></span><br><span class="line">					latch.countDown();</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">				&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;, <span class="string">"t1"</span>).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="LockSupport"><a href="#LockSupport" class="headerlink" title="LockSupport"></a>LockSupport</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T07_LockSupport_WithoutSleep</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 添加volatile，使t2能够得到通知</span></span><br><span class="line">	<span class="keyword">volatile</span> List lists = <span class="keyword">new</span> ArrayList();</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">		lists.add(o);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> lists.size();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> Thread t1 = <span class="keyword">null</span>, t2 = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		T07_LockSupport_WithoutSleep c = <span class="keyword">new</span> T07_LockSupport_WithoutSleep();</span><br><span class="line"></span><br><span class="line">		t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">			System.out.println(<span class="string">"t1启动"</span>);</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">				c.add(<span class="keyword">new</span> Object());</span><br><span class="line">				System.out.println(<span class="string">"add "</span> + i);</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (c.size() == <span class="number">5</span>) &#123;</span><br><span class="line">					LockSupport.unpark(t2);</span><br><span class="line">					LockSupport.park();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;, <span class="string">"t1"</span>);</span><br><span class="line"></span><br><span class="line">		t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">			LockSupport.park();</span><br><span class="line">			System.out.println(<span class="string">"t2 结束"</span>);</span><br><span class="line">			LockSupport.unpark(t1);</span><br><span class="line">		&#125;, <span class="string">"t2"</span>);</span><br><span class="line">		t2.start();</span><br><span class="line">		t1.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="Semaphore-join"><a href="#Semaphore-join" class="headerlink" title="Semaphore + join"></a>Semaphore + join</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T08_Semaphore</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 添加volatile，使t2能够得到通知</span></span><br><span class="line">    <span class="keyword">volatile</span> List lists = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        lists.add(o);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lists.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Thread t1 = <span class="keyword">null</span>, t2 = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        T08_Semaphore c = <span class="keyword">new</span> T08_Semaphore();</span><br><span class="line">        Semaphore s = <span class="keyword">new</span> Semaphore(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                s.acquire();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                    c.add(<span class="keyword">new</span> Object());</span><br><span class="line">                    System.out.println(<span class="string">"add "</span> + i);</span><br><span class="line">                &#125;</span><br><span class="line">                s.release();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t2.start();</span><br><span class="line">                t2.join();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                s.acquire();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">5</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                    System.out.println(i);</span><br><span class="line">                &#125;</span><br><span class="line">                s.release();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;, <span class="string">"t1"</span>);</span><br><span class="line"></span><br><span class="line">        t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                s.acquire();</span><br><span class="line">                System.out.println(<span class="string">"t2 结束"</span>);</span><br><span class="line">                s.release();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t2"</span>);</span><br><span class="line">        <span class="comment">//t2.start();</span></span><br><span class="line">        t1.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="生产消费"><a href="#生产消费" class="headerlink" title="生产消费"></a>生产消费</h5><blockquote>
<p>面试题：写一个固定容量同步容器，拥有put和get方法，以及getCount方法，<br>能够支持2个生产者线程以及10个消费者线程的阻塞调用</p>
</blockquote>
<h6 id="wait-notify-1"><a href="#wait-notify-1" class="headerlink" title="wait / notify"></a>wait / notify</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyContainer1</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">private</span> LinkedList&lt;T&gt; lists = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">private</span> <span class="keyword">int</span> MAX = <span class="number">10</span>; <span class="comment">//最多10个元素</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 醒了还要判断是不是满了</span></span><br><span class="line">        <span class="keyword">while</span>(lists.size() == MAX) &#123; <span class="comment">//想想为什么用while而不是用if？</span></span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="keyword">this</span>.wait(); <span class="comment">//effective java</span></span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		lists.add(t);</span><br><span class="line">		++count;</span><br><span class="line">		<span class="keyword">this</span>.notifyAll(); <span class="comment">// 叫醒所有等待线程, 不能指定叫醒消费线程</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		T t = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">while</span>(lists.size() == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="keyword">this</span>.wait();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		t = lists.removeFirst();</span><br><span class="line">		count --;</span><br><span class="line">		<span class="keyword">this</span>.notifyAll(); <span class="comment">//通知生产者进行生产</span></span><br><span class="line">		<span class="keyword">return</span> t;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		MyContainer1&lt;String&gt; c = <span class="keyword">new</span> MyContainer1&lt;&gt;();</span><br><span class="line">		<span class="comment">//启动消费者线程</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">5</span>; j++) System.out.println(c.get());</span><br><span class="line">			&#125;, <span class="string">"c"</span> + i).start();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//启动生产者线程</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">2</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">25</span>; j++) c.put(Thread.currentThread().getName() + <span class="string">" "</span> + j);</span><br><span class="line">			&#125;, <span class="string">"p"</span> + i).start();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="ReentrantLock-Condition-背过"><a href="#ReentrantLock-Condition-背过" class="headerlink" title="ReentrantLock + Condition (背过)"></a>ReentrantLock + Condition (背过)</h6><p>精确叫醒生产 / 消费线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyContainer2</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">private</span> LinkedList&lt;T&gt; lists = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">private</span> <span class="keyword">int</span> MAX = <span class="number">10</span>; <span class="comment">//最多10个元素</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition producer = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition consumer = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">while</span> (lists.size() == MAX) &#123; <span class="comment">//想想为什么用while而不是用if？</span></span><br><span class="line">                producer.await();</span><br><span class="line">            &#125;</span><br><span class="line">            lists.add(t);</span><br><span class="line">            ++count;</span><br><span class="line">            consumer.signalAll(); <span class="comment">//通知消费者线程进行消费</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        T t = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">while</span> (lists.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                consumer.await();</span><br><span class="line">            &#125;</span><br><span class="line">            t = lists.removeFirst();</span><br><span class="line">            count--;</span><br><span class="line">            producer.signalAll(); <span class="comment">//通知生产者进行生产</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyContainer2&lt;String&gt; c = <span class="keyword">new</span> MyContainer2&lt;&gt;();</span><br><span class="line">        <span class="comment">//启动消费者线程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++) System.out.println(c.get());</span><br><span class="line">            &#125;, <span class="string">"c"</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//启动生产者线程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">25</span>; j++) c.put(Thread.currentThread().getName() + <span class="string">" "</span> + j);</span><br><span class="line">            &#125;, <span class="string">"p"</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="交替打印"><a href="#交替打印" class="headerlink" title="交替打印"></a>交替打印</h5><h6 id="常用方法1-LockSupport的park-unpark"><a href="#常用方法1-LockSupport的park-unpark" class="headerlink" title="常用方法1: LockSupport的park/unpark"></a>常用方法1: LockSupport的park/unpark</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Locksupport park 当前线程阻塞（停止）</span></span><br><span class="line"><span class="comment">//unpark(Thread t)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T02_00_LockSupport</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Thread t1 = <span class="keyword">null</span>, t2 = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] aI = <span class="string">"1234567"</span>.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] aC = <span class="string">"ABCDEFG"</span>.toCharArray();</span><br><span class="line"></span><br><span class="line">        t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">char</span> c : aI) &#123;</span><br><span class="line">                    System.out.print(c);</span><br><span class="line">                    LockSupport.unpark(t2); <span class="comment">//叫醒T2</span></span><br><span class="line">                    LockSupport.park(); <span class="comment">//T1阻塞</span></span><br><span class="line">                &#125;</span><br><span class="line">        &#125;, <span class="string">"t1"</span>);</span><br><span class="line"></span><br><span class="line">        t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">char</span> c : aC) &#123;</span><br><span class="line">                LockSupport.park(); <span class="comment">//t2阻塞 放在打印前,可以保证先打印1</span></span><br><span class="line">                System.out.print(c);</span><br><span class="line">                LockSupport.unpark(t1); <span class="comment">//叫醒t1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t2"</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="常用方法2-synchronized的wait-notify"><a href="#常用方法2-synchronized的wait-notify" class="headerlink" title="常用方法2: synchronized的wait/notify"></a>常用方法2: synchronized的wait/notify</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T07_00_sync_wait_notify</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 标记, 保证t1先打印</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> t2Started = <span class="keyword">false</span>;</span><br><span class="line">	<span class="comment">// CountDownLatch也可以实现</span></span><br><span class="line">    <span class="comment">//private static CountDownLatch latch = new C(1);</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Object o = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span>[] aI = <span class="string">"1234567"</span>.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] aC = <span class="string">"ABCDEFG"</span>.toCharArray();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="comment">//latch.await();</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">synchronized</span> (o) &#123;</span><br><span class="line">				<span class="comment">// 保证第一个线程先运行</span></span><br><span class="line">                <span class="keyword">while</span>(!t2Started) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        o.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">				</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">char</span> c : aI) &#123;</span><br><span class="line">                    System.out.print(c);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        o.notify();</span><br><span class="line">                        o.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                o.notify(); <span class="comment">// 第一个线程最终必须要唤醒t2, 不然程序结束不了</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t1"</span>).start();</span><br><span class="line">		<span class="comment">// t2</span></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">synchronized</span> (o) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">char</span> c : aC) &#123;</span><br><span class="line">                    System.out.print(c);</span><br><span class="line">                    <span class="comment">//latch.countDown()</span></span><br><span class="line">                    t2Started = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        o.notify();</span><br><span class="line">                        o.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                o.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t2"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="方法3-ReentrantLock-的-condition-的-signal-await"><a href="#方法3-ReentrantLock-的-condition-的-signal-await" class="headerlink" title="方法3: ReentrantLock 的 condition 的 signal/await"></a>方法3: ReentrantLock 的 condition 的 signal/await</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T09_00_lock_condition</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span>[] aI = <span class="string">"1234567"</span>.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] aC = <span class="string">"ABCDEFG"</span>.toCharArray();</span><br><span class="line"></span><br><span class="line">        Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">        <span class="comment">// 两个等待队列</span></span><br><span class="line">        Condition conditionT1 = lock.newCondition();</span><br><span class="line">        Condition conditionT2 = lock.newCondition();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">char</span> c : aI) &#123;</span><br><span class="line">                    System.out.print(c);</span><br><span class="line">                    conditionT2.signal();</span><br><span class="line">                    conditionT1.await();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                conditionT2.signal();</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;, <span class="string">"t1"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">char</span> c : aC) &#123;</span><br><span class="line"></span><br><span class="line">                    System.out.print(c);</span><br><span class="line">                    conditionT1.signal();</span><br><span class="line">                    conditionT2.await();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                conditionT1.signal();</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t2"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="AQS-所有锁的心"><a href="#AQS-所有锁的心" class="headerlink" title="AQS (所有锁的心)"></a>AQS (所有锁的心)</h4><h5 id="ReentrantLock源码-lock"><a href="#ReentrantLock源码-lock" class="headerlink" title="ReentrantLock源码 lock( )"></a>ReentrantLock源码 lock( )</h5><p>通过模板方法, (回调函数, 钩子函数)</p>
<p>调用父类方法, 子类去实现</p>
<p>ReentrantLock.lock( ) -&gt; Sync.acquire( ) -&gt; AQS.tryAcquire( ) -&gt; ReentrantLock.nonfairTryAcquire( ) -&gt; AQS.getState( )<br><img src="/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/../../../只要学不死 就往死里学/note/JUC/image/笔记/image-20200527204622726.png" alt="image-20200527204622726" style="zoom:80%;"></p>
<img src="/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/../../../只要学不死 就往死里学/note/JUC/md/image/image-20200402065727531.png" alt="image-20200402065727531" style="zoom:50%;">

<ol>
<li><p>node里装的是thread线程</p>
</li>
<li><p>state 是 volatile 修饰的, 设置state的方法    </p>
</li>
</ol>
<img src="/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/../../../只要学不死 就往死里学/note/JUC/md/image/image-20200402065940538.png" alt="image-20200402065940538" style="zoom:50%;">

<p>AQS添加节点: 不用给整个链表加锁, 只观测tail节点, 通过CAS, 提高效率</p>
<p><img src="/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20200527224948564.png" alt="image-20200527224948564"></p>
<img src="/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/../../../只要学不死 就往死里学/note/JUC/image/笔记/image-20200527230919030.png" alt="image-20200527230919030" style="zoom:80%;">


<img src="/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/../../../只要学不死 就往死里学/note/JUC/image/笔记/image-20200527231134651.png" alt="image-20200527231134651" style="zoom:80%;">

<p>头节点先获得, 第二个一直尝试</p>
<p><img src="/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20200527231438271.png" alt="image-20200527231438271"></p>
<img src="/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/../../../只要学不死 就往死里学/note/JUC/image/笔记/image-20200527232418283.png" alt="image-20200527232418283" style="zoom:80%;">

<p><strong>AQS使用了模板方法模式，自定义同步器时需要重写下面几个AQS提供的模板方法：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">isHeldExclusively()   <span class="comment">//该线程是否正在独占资源。只有用到condition才需要去实现它。 </span></span><br><span class="line">tryAcquire(<span class="keyword">int</span>)      <span class="comment">//独占方式。尝试获取资源，成功则返回true，失败则返回false。 </span></span><br><span class="line">tryRelease(<span class="keyword">int</span>)     <span class="comment">//独占方式。尝试释放资源，成功则返回true，失败则返回false。 </span></span><br><span class="line">tryAcquireShared(<span class="keyword">int</span>)    <span class="comment">//共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。 </span></span><br><span class="line">tryReleaseShared(<span class="keyword">int</span>)   <span class="comment">//共享方式。尝试释放资源，成功则返回true，失败则返回false</span></span><br></pre></td></tr></table></figure>

<p>AQS类中的其他方法都是final ，所以无法被其他类使用，只有这几个方法可以被其他类使用。</p>
<p>以 <strong>ReentrantLock</strong> 为例，<strong>state初始化为0</strong>，表示未锁定状态。A线程<strong>lock()时</strong>，会调用tryAcquire()独占该锁并将<strong>state+1</strong>。此后，其他线程再tryAcquire()时就会失败，直到A线程<strong>unlock()到state=0</strong>（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A线程自己是可以重复获取此锁的（state会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证state是能回到零态的。</p>
<p>再以<strong>CountDownLatch</strong>以例，任务分为<strong>N个子线</strong>程去执行，<strong>state</strong>也<strong>初始化为N</strong>（注意N要与线程个数一致）。这N个子线程是并行执行的，每个子线程执行完后countDown()一次，<strong>state会CAS(Compare and Swap)减1</strong>。等到<strong>所有子线程都执行完后(即state=0)</strong>，会<strong>unpark()主调用线程</strong>，然后主调用线程就会<strong>从await()函数返回</strong>，继续后余动作。</p>
<p>一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现<code>tryAcquire-tryRelease</code>、<code>tryAcquireShared-tryReleaseShared</code>中的一种即可。但AQS也支持自定义同步器同时<strong>实现独占和共享两种方式</strong>，如 <strong>ReentrantReadWriteLock</strong>。</p>
<h5 id="AQS的数据结构是双向链表-原理CAS-volatile"><a href="#AQS的数据结构是双向链表-原理CAS-volatile" class="headerlink" title="AQS的数据结构是双向链表  原理CAS + volatile"></a>AQS的数据结构是双向链表  原理CAS + volatile</h5><ol>
<li>核心是int类型的state</li>
<li>state 被 volatile 修饰</li>
<li>AQS 拥有 boolean compareAndSetState(int expect, int update) 方法, <strong>往队尾加节点</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">** 源码 **</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Head of the wait queue, lazily initialized.  Except for</span></span><br><span class="line"><span class="comment">     * initialization, it is modified only via method setHead.  Note:</span></span><br><span class="line"><span class="comment">     * If head exists, its waitStatus is guaranteed not to be</span></span><br><span class="line"><span class="comment">     * CANCELLED.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Tail of the wait queue, lazily initialized.  Modified only via</span></span><br><span class="line"><span class="comment">     * method enq to add new wait node.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The synchronization state.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the current value of synchronization state.</span></span><br><span class="line"><span class="comment">     * This operation has memory semantics of a &#123;<span class="doctag">@code</span> volatile&#125; read.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> current state value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sets the value of synchronization state.</span></span><br><span class="line"><span class="comment">     * This operation has memory semantics of a &#123;<span class="doctag">@code</span> volatile&#125; write.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> newState the new state value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> newState)</span> </span>&#123;</span><br><span class="line">        state = newState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Atomically sets synchronization state to the given updated</span></span><br><span class="line"><span class="comment">     * value if the current state value equals the expected value.</span></span><br><span class="line"><span class="comment">     * This operation has memory semantics of a &#123;<span class="doctag">@code</span> volatile&#125; read</span></span><br><span class="line"><span class="comment">     * and write.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> expect the expected value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> update the new value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if successful. False return indicates that the actual</span></span><br><span class="line"><span class="comment">     *         value was not equal to the expected value.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetState</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// See below for intrinsics setup to support this</span></span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, expect, update);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="AQS面试题"><a href="#AQS面试题" class="headerlink" title="AQS面试题"></a>AQS面试题</h5><p><img src="/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20200527213938929.png" alt="image-20200527213938929"></p>
<img src="/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/../../../只要学不死 就往死里学/note/JUC/image/image-20200402065631929.png" alt="image-20200402065631929" style="zoom:50%;">


<img src="/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/../../../只要学不死 就往死里学/note/JUC/image/image-20200402063557639.png" alt="image-20200402063557639" style="zoom:50%;">


<img src="/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/../../../只要学不死 就往死里学/note/JUC/image/笔记/image-20200528235029593.png" alt="image-20200528235029593" style="zoom:67%;">

<h4 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h4><h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><p>ThreadLocal是解决线程安全问题一个很好的思路，它通过为每个线程提供一个独立的变量副本解决了变量并发访问的冲突问题。在很多情况下，ThreadLocal比直接使用synchronized同步机制解决线程安全问题更简单，更方便，且结果程序拥有更高的并发性。</p>
<p>设到<strong>当前线程的map</strong><br><img src="/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/../../../只要学不死 就往死里学/note/JUC/image/笔记/image-20200527234707313.png" alt="image-20200527234707313" style="zoom:67%;"></p>
<img src="/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/../../../只要学不死 就往死里学/note/JUC/image/笔记/image-20200527234813608.png" alt="image-20200527234813608" style="zoom: 67%;">

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ThreadLocal线程局部变量</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * ThreadLocal是使用空间换时间，synchronized是使用时间换空间</span></span><br><span class="line"><span class="comment"> * 比如在hibernate中session就存在与ThreadLocal中，避免synchronized的使用</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 运行下面的程序，理解ThreadLocal</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">package</span> com.oi.juc.c_022_RefTypeAndThreadLocal;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal2</span> </span>&#123;</span><br><span class="line">	<span class="comment">//volatile static Person p = new Person();</span></span><br><span class="line">	<span class="keyword">static</span> ThreadLocal&lt;Person&gt; tl = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">				</span><br><span class="line">		<span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			System.out.println(tl.get());</span><br><span class="line">		&#125;).start();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">			tl.set(<span class="keyword">new</span> Person());</span><br><span class="line">		&#125;).start();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">		String name = <span class="string">"zhangsan"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="强软弱虚四种引用"><a href="#强软弱虚四种引用" class="headerlink" title="强软弱虚四种引用"></a>强软弱虚四种引用</h5><p><img src="/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20200528125043817.png" alt="image-20200528125043817"></p>
<img src="/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/../../../只要学不死 就往死里学/note/JUC/md/image/image-20200402113830722.png" alt="image-20200402113830722" style="zoom: 80%;">

<h5 id="强引用-new-出来的-不回收"><a href="#强引用-new-出来的-不回收" class="headerlink" title="强引用: new 出来的, 不回收"></a>强引用: new 出来的, 不回收</h5><p>当<strong>内存空间不足</strong>时，<code>Java</code>虚拟机宁愿抛出<code>OutOfMemoryError</code>错误，使程序<strong>异常终止</strong>，也不会靠随意<strong>回收</strong>具有<strong>强引用</strong>的<strong>对象</strong>来解决内存不足的问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">M m = <span class="keyword">new</span> M();</span><br><span class="line">m = <span class="keyword">null</span>;</span><br><span class="line">System.gc(); <span class="comment">//DisableExplicitGC , 有引用 , M就不会被回收</span></span><br><span class="line">System.in.read(); <span class="comment">// 阻塞住线程 , 观察效果</span></span><br></pre></td></tr></table></figure>

<h5 id="软引用-满则回收"><a href="#软引用-满则回收" class="headerlink" title="软引用: 满则回收"></a>软引用: 满则回收</h5><ul>
<li>软引用是用来描述一些还有用但并非必须的对象。</li>
<li>对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围进行第二次回收。</li>
<li>如果这次回收还没有足够的内存，才会抛出内存溢出异常。</li>
<li>如果一个对象只具有<strong>软引用</strong>，则<strong>内存空间充足</strong>时，<strong>垃圾回收器</strong>就<strong>不会</strong>回收它；如果<strong>内存空间不足</strong>了，就会<strong>回收</strong>这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 软引用</span></span><br><span class="line"><span class="comment"> * 软引用是用来描述一些还有用但并非必须的对象。</span></span><br><span class="line"><span class="comment"> * 对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围进行第二次回收。</span></span><br><span class="line"><span class="comment"> * 如果这次回收还没有足够的内存，才会抛出内存溢出异常。</span></span><br><span class="line"><span class="comment"> * -Xmx20M</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">package</span> com.oi.juc.c_022_RefTypeAndThreadLocal;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.ref.SoftReference;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T02_SoftReference</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SoftReference&lt;<span class="keyword">byte</span>[]&gt; m = <span class="keyword">new</span> SoftReference&lt;&gt;(<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>*<span class="number">1024</span>*<span class="number">10</span>]);</span><br><span class="line">        <span class="comment">//m = null;</span></span><br><span class="line">        System.out.println(m.get());</span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(m.get());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//再分配一个数组，heap将装不下，这时候系统会垃圾回收，先回收一次，如果不够，会把软引用干掉</span></span><br><span class="line">        <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>*<span class="number">1024</span>*<span class="number">15</span>];</span><br><span class="line">        System.out.println(m.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//软引用非常适合缓存使用</span></span><br></pre></td></tr></table></figure>

<h5 id="弱引用：一般用在容器里ThreadLocal-lt-gt-WeakHashMap"><a href="#弱引用：一般用在容器里ThreadLocal-lt-gt-WeakHashMap" class="headerlink" title="弱引用：一般用在容器里ThreadLocal&lt;&gt;(), WeakHashMap"></a>弱引用：一般用在容器里ThreadLocal&lt;&gt;(), WeakHashMap</h5><p>作用: 有强引用指向它的时候, 一旦强引用消失, 就不用再管他了</p>
<img src="/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/../../../只要学不死 就往死里学/note/JUC/image/笔记/image-20200528124442712.png" alt="image-20200528124442712" style="zoom:50%;">

<p><code>JVM</code>首先将<strong>软引用</strong>中的<strong>对象</strong>引用置为<code>null</code>，然后通知<strong>垃圾回收器</strong>进行回收：</p>
<p><code>WeakReference</code>对象的生命周期基本由<strong>垃圾回收器</strong>决定，一旦垃圾回收线程发现了<strong>弱引用对象</strong>，在下一次<code>GC</code>过程中就会对其进行回收。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 弱引用遭到gc就会回收</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T03_WeakReference</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        WeakReference&lt;M&gt; m = <span class="keyword">new</span> WeakReference&lt;&gt;(<span class="keyword">new</span> M());</span><br><span class="line"></span><br><span class="line">        System.out.println(m.get());</span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(m.get());</span><br><span class="line"></span><br><span class="line">        ThreadLocal&lt;M&gt; tl = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line">        tl.set(<span class="keyword">new</span> M());</span><br><span class="line">        tl.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>tl 指向ThreadLocal 是强引用</p>
<p>ThreadLocalMap 的 key 是弱引用</p>
<p>使用ThreadLocal , 不用的对象, 务必remove() 掉, 因为key如果为空了, value永远访问不到, 导致内存泄漏</p>
<img src="/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/../../../只要学不死 就往死里学/note/JUC/md/image/image-20200402120531506.png" alt="image-20200402120531506" style="zoom: 80%;">

<p>ThreadLocal的set() 方法 调用了getMap() , key: threadlocal对象, value: </p>
<img src="/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/../../../只要学不死 就往死里学/note/JUC/image/笔记/image-20200528125305588.png" alt="image-20200528125305588" style="zoom:80%;">

<p>key一个弱引用指向threadlocal</p>
<img src="/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/../../../只要学不死 就往死里学/note/JUC/image/笔记/image-20200528125402186.png" alt="image-20200528125402186" style="zoom:67%;">

<h5 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h5><p>垃圾回收时候直接干掉</p>
<img src="/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/../../../只要学不死 就往死里学/note/JUC/image/笔记/image-20200528131123856.png" alt="image-20200528131123856" style="zoom: 50%;">


<img src="/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/../../../只要学不死 就往死里学/note/JUC/md/image/image-20200402124801164.png" alt="image-20200402124801164" style="zoom:50%;">


<img src="/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/../../../只要学不死 就往死里学/note/JUC/md/image/image-20200402172620123.png" alt="image-20200402172620123" style="zoom:67%;">


<img src="/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/../../../只要学不死 就往死里学/note/JUC/md/image/image-20200402172209626.png" alt="image-20200402172209626" style="zoom: 80%;">



<h3 id="并发容器"><a href="#并发容器" class="headerlink" title="并发容器"></a>并发容器</h3><img src="/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/../../../只要学不死 就往死里学/note/JUC/image/笔记/image-20200528134414349.png" alt="image-20200528134414349" style="zoom:80%;">

<p><img src="/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20200528220820441.png" alt="image-20200528220820441"></p>
<p><img src="/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20200528220924869.png" alt="image-20200528220924869"></p>
<p><img src="/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20200528221154743.png" alt="image-20200528221154743"></p>
<p><img src="/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20200528221314448.png" alt="image-20200528221314448"></p>
<p>同步容器类</p>
<p>总结：<br>1：对于map/set的选择使用<br>HashMap<br>TreeMap<br>LinkedHashMap</p>
<p>Hashtable<br>Collections.sychronizedXXX</p>
<p>ConcurrentHashMap<br>ConcurrentSkipListMap </p>
<p>2：队列<br>ArrayList<br>LinkedList<br>Collections.synchronizedXXX<br>CopyOnWriteList<br>Queue<br>    CocurrentLinkedQueue //concurrentArrayQueue<br>    BlockingQueue<br>        LinkedBQ<br>        ArrayBQ<br>        TransferQueue<br>        SynchronusQueue<br>    DelayQueue执行定时任务</p>
<p>1：Vector Hashtable ：早期使用synchronized实现<br>2：ArrayList HashSet ：未考虑多线程安全（未实现同步）<br>3：HashSet vs Hashtable StringBuilder vs StringBuffer<br>4：Collections.synchronized***工厂方法使用的也是synchronized</p>
<p>使用早期的同步容器以及Collections.synchronized***方法的不足之处，请阅读：<br><a href="http://blog.csdn.net/itm_hadf/article/details/7506529" target="_blank" rel="noopener">http://blog.csdn.net/itm_hadf/article/details/7506529</a></p>
<p>使用新的并发容器<br><a href="http://xuganggogo.iteye.com/blog/321630" target="_blank" rel="noopener">http://xuganggogo.iteye.com/blog/321630</a></p>
<h4 id="Map的发展历程"><a href="#Map的发展历程" class="headerlink" title="Map的发展历程"></a>Map的发展历程</h4><img src="/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/../../../只要学不死 就往死里学/note/JUC/image/笔记/image-20200528222832446.png" alt="image-20200528222832446" style="zoom:67%;">

<p>hashTable –&gt; hashMap –&gt; synchronizedHashMap –&gt; concurrentHashMap</p>
<ol>
<li><p>hashTable 整体加锁, 所有方法加synchronized</p>
</li>
<li><p>hashmap 没有锁, 并发场景数据不一致</p>
</li>
<li><p>synchronizedHashMap 在 hashMap 的基础上使用了细粒度锁</p>
</li>
<li><p>concurrentHashMap 使用了CAS, 插入效率一般, 读取效率特别高</p>
</li>
</ol>
<h4 id="从Vector-gt-List-gt-Queue-解决超卖问题"><a href="#从Vector-gt-List-gt-Queue-解决超卖问题" class="headerlink" title="从Vector -&gt; List -&gt; Queue ( 解决超卖问题 )"></a>从Vector -&gt; List -&gt; Queue ( 解决超卖问题 )</h4><p>Vector: 古老的同步容器, 方法都是synchronized,  但是两个同步方法之间的业务逻辑不是原子性的, 还是会发生超卖问题, 因此需要再外层再加synchronized</p>
<p>ConcurrentLinkedQueue: CAS实现, 适合代码执行时间短</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 有N张火车票，每张票都有一个编号</span></span><br><span class="line"><span class="comment"> * 同时有10个窗口对外售票</span></span><br><span class="line"><span class="comment"> * 请写一个模拟程序</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 分析下面的程序可能会产生哪些问题？</span></span><br><span class="line"><span class="comment"> * 重复销售？超量销售？</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 使用Vector或者Collections.synchronizedXXX</span></span><br><span class="line"><span class="comment"> * 分析一下，这样能解决问题吗？</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 就算操作A和B都是同步的，但A和B组成的复合操作也未必是同步的，仍然需要自己进行同步</span></span><br><span class="line"><span class="comment"> * 就像这个程序，判断size和进行remove必须是一整个的原子操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TicketSeller3</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> List&lt;String&gt; tickets = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">1000</span>; i++) tickets.add(<span class="string">"票 编号："</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">				<span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">					<span class="keyword">synchronized</span>(tickets) &#123;</span><br><span class="line">						<span class="keyword">if</span>(tickets.size() &lt;= <span class="number">0</span>) <span class="keyword">break</span>;		</span><br><span class="line">						<span class="keyword">try</span> &#123;</span><br><span class="line">							TimeUnit.MILLISECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">						&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">							e.printStackTrace();</span><br><span class="line">						&#125;	</span><br><span class="line">						System.out.println(<span class="string">"销售了--"</span> + tickets.remove(<span class="number">0</span>));</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;).start();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/* 使用ConcurrentLinkedQueue提高并发性 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TicketSeller4</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> Queue&lt;String&gt; tickets = <span class="keyword">new</span> ConcurrentLinkedQueue&lt;&gt;();</span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">1000</span>; i++) tickets.add(<span class="string">"票 编号："</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">				<span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">					String s = tickets.poll();</span><br><span class="line">					<span class="keyword">if</span>(s == <span class="keyword">null</span>) <span class="keyword">break</span>;</span><br><span class="line">					<span class="keyword">else</span> System.out.println(<span class="string">"销售了--"</span> + s);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;).start();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Synchronized-Vs-CAS"><a href="#Synchronized-Vs-CAS" class="headerlink" title="Synchronized Vs CAS"></a>Synchronized Vs CAS</h4><p>要看并发量高低, 并发量不高, 代码执行时间长, 用Synchronized</p>
<h4 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h4><h5 id="ConcurrentSkipListMap"><a href="#ConcurrentSkipListMap" class="headerlink" title="ConcurrentSkipListMap"></a>ConcurrentSkipListMap</h5><p>跳表比链表查找快, 比treeMap的cas操作容易</p>
<img src="/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/../../../只要学不死 就往死里学/note/JUC/image/笔记/image-20200528230935451.png" alt="image-20200528230935451" style="zoom:67%;">

<h4 id="写时复制"><a href="#写时复制" class="headerlink" title="写时复制"></a>写时复制</h4><h5 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h5><h5 id="CopyOnWriteArraySet"><a href="#CopyOnWriteArraySet" class="headerlink" title="CopyOnWriteArraySet"></a>CopyOnWriteArraySet</h5><p>往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。</p>
<p>CopyOnWriteArraySet内部维护着一个CopyOnWriteArrayList</p>
<p>写时排他锁, 读时共享锁, 适合读特别多, 写特别少</p>
<h4 id="LinkedBlockingQueue-天生的生产者-消费者模型"><a href="#LinkedBlockingQueue-天生的生产者-消费者模型" class="headerlink" title="LinkedBlockingQueue: 天生的生产者/消费者模型"></a>LinkedBlockingQueue: 天生的生产者/消费者模型</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> BlockingQueue&lt;String&gt; strs = <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;();</span><br><span class="line"><span class="keyword">static</span> Random r = <span class="keyword">new</span> Random();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">            strs.put(<span class="string">"a"</span> + i); <span class="comment">//如果满了，就会等待</span></span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(r.nextInt(<span class="number">1000</span>));</span><br><span class="line">         &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;, <span class="string">"p1"</span>).start();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">         <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">               System.out.println(Thread.currentThread().getName() + <span class="string">" take -"</span> + strs.take()); <span class="comment">//如果空了，就会等待</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;, <span class="string">"c"</span> + i).start();</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> BlockingQueue&lt;String&gt; strs = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> Random r = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">		strs.put(<span class="string">"a"</span> + i);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//strs.put("aaa"); // 满了就会等待，程序阻塞</span></span><br><span class="line">	<span class="comment">//strs.add("aaa"); // 满了报错</span></span><br><span class="line">	<span class="comment">//strs.offer("aaa"); // 满了结束, 用返回值判断</span></span><br><span class="line">	strs.offer(<span class="string">"aaa"</span>, <span class="number">1</span>, TimeUnit.SECONDS); <span class="comment">// 满了等一秒, 加不进去, 返回</span></span><br><span class="line">	</span><br><span class="line">	System.out.println(strs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Queue和List的区别"><a href="#Queue和List的区别" class="headerlink" title="Queue和List的区别"></a>Queue和List的区别</h5><p>Queue多了很多线程友好的方法, 或者阻塞, 或者时间等待<br>offer()<br>peek()<br>poll()<br>put()<br>take()</p>
<h4 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue:"></a>DelayQueue:</h4><p>按时间进行任务调度, 等待多长时间后执行</p>
<p>本质是PriorityQueue, 需要指定一种排序方式, 例如等待时间短的先执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T07_DelayQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> BlockingQueue&lt;MyTask&gt; tasks = <span class="keyword">new</span> DelayQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> Random r = <span class="keyword">new</span> Random();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">implements</span> <span class="title">Delayed</span> </span>&#123;</span><br><span class="line">		String name;</span><br><span class="line">		<span class="keyword">long</span> runningTime;</span><br><span class="line">		</span><br><span class="line">		MyTask(String name, <span class="keyword">long</span> rt) &#123;</span><br><span class="line">			<span class="keyword">this</span>.name = name;</span><br><span class="line">			<span class="keyword">this</span>.runningTime = rt;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Delayed o)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="keyword">this</span>.getDelay(TimeUnit.MILLISECONDS) &lt; o.getDelay(TimeUnit.MILLISECONDS))</span><br><span class="line">				<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">this</span>.getDelay(TimeUnit.MILLISECONDS) &gt; o.getDelay(TimeUnit.MILLISECONDS)) </span><br><span class="line">				<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">else</span> </span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getDelay</span><span class="params">(TimeUnit unit)</span> </span>&#123;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">return</span> unit.convert(runningTime - System.currentTimeMillis(), TimeUnit.MILLISECONDS);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> name + <span class="string">" "</span> + runningTime;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">		<span class="keyword">long</span> now = System.currentTimeMillis();</span><br><span class="line">		MyTask t1 = <span class="keyword">new</span> MyTask(<span class="string">"t1"</span>, now + <span class="number">1000</span>);</span><br><span class="line">		MyTask t2 = <span class="keyword">new</span> MyTask(<span class="string">"t2"</span>, now + <span class="number">2000</span>);</span><br><span class="line">		MyTask t3 = <span class="keyword">new</span> MyTask(<span class="string">"t3"</span>, now + <span class="number">1500</span>);</span><br><span class="line">		MyTask t4 = <span class="keyword">new</span> MyTask(<span class="string">"t4"</span>, now + <span class="number">2500</span>);</span><br><span class="line">		MyTask t5 = <span class="keyword">new</span> MyTask(<span class="string">"t5"</span>, now + <span class="number">500</span>);</span><br><span class="line">		</span><br><span class="line">		tasks.put(t1);</span><br><span class="line">		tasks.put(t2);</span><br><span class="line">		tasks.put(t3);</span><br><span class="line">		tasks.put(t4);</span><br><span class="line">		tasks.put(t5);</span><br><span class="line">		</span><br><span class="line">		System.out.println(tasks);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++) &#123;</span><br><span class="line">			System.out.println(tasks.take());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h5><p>内部是一个红黑树<br>可自定义compareTo<br><img src="/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/../../../只要学不死 就往死里学/note/JUC/image/笔记/image-20200529064306360.png" alt="image-20200529064306360" style="zoom: 67%;"></p>
<h4 id="SynchronousQueue-用处最大-任务调度"><a href="#SynchronousQueue-用处最大-任务调度" class="headerlink" title="SynchronousQueue 用处最大, 任务调度"></a>SynchronousQueue 用处最大, 任务调度</h4><p><strong>容量为0</strong>, 只能用put()阻塞 , 用来<strong>手递手</strong>给另一个线程数据<br>类似Exchanger</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">		BlockingQueue&lt;String&gt; strs = <span class="keyword">new</span> SynchronousQueue&lt;&gt;();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				System.out.println(strs.take());</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;).start();</span><br><span class="line"></span><br><span class="line">		strs.put(<span class="string">"aaa"</span>); <span class="comment">//阻塞等待消费者消费</span></span><br><span class="line">		<span class="comment">//strs.put("bbb");</span></span><br><span class="line">		<span class="comment">//strs.add("aaa");</span></span><br><span class="line">		System.out.println(strs.size());</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h4 id="TransferQueue-amp-LinkedTransferQueue"><a href="#TransferQueue-amp-LinkedTransferQueue" class="headerlink" title="TransferQueue &amp; LinkedTransferQueue"></a>TransferQueue &amp; LinkedTransferQueue</h4><p>transfer(), <strong>装完等着, 等其他线程取走</strong><br>用于订单提交后, 确认有人处理订单, 再返回<br>收钱, 确认收到, 返回</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">		LinkedTransferQueue&lt;String&gt; strs = <span class="keyword">new</span> LinkedTransferQueue&lt;&gt;();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				System.out.println(strs.take());</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;).start();</span><br><span class="line">		</span><br><span class="line">		strs.transfer(<span class="string">"aaa"</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//strs.put("aaa");</span></span><br><span class="line">		<span class="comment">/*new Thread(() -&gt; &#123;</span></span><br><span class="line"><span class="comment">			try &#123;</span></span><br><span class="line"><span class="comment">				System.out.println(strs.take());</span></span><br><span class="line"><span class="comment">			&#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">				e.printStackTrace();</span></span><br><span class="line"><span class="comment">			&#125;</span></span><br><span class="line"><span class="comment">		&#125;).start();*/</span></span><br><span class="line"></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线程任务"><a href="#线程任务" class="headerlink" title="线程任务"></a>线程任务</h3><h4 id="Excutor"><a href="#Excutor" class="headerlink" title="Excutor"></a>Excutor</h4><p><img src="/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/../../../只要学不死 就往死里学/note/JUC/image/笔记/image-20200522221235180.png" alt="image-20200522221235180" style="zoom: 80%;"><img src="/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/../../../只要学不死 就往死里学/note/JUC/md/image/image-20200403195118211.png" alt="image-20200403195118211" style="zoom:80%;"><br><img src="/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20200531072858642.png" alt="image-20200531072858642"></p>
<h4 id="ExcutorService-方法"><a href="#ExcutorService-方法" class="headerlink" title="ExcutorService 方法"></a>ExcutorService 方法</h4><p>主要是submint和shutdown和shutdownnow</p>
<img src="/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/../../../只要学不死 就往死里学/note/JUC/image/笔记/image-20200529125814455.png" alt="image-20200529125814455" style="zoom: 80%;">


<img src="/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/../../../只要学不死 就往死里学/note/JUC/md/image/image-20200403201506150.png" alt="image-20200403201506150" style="zoom:67%;">

<h4 id="Callable"><a href="#Callable" class="headerlink" title="Callable"></a>Callable</h4><p>类似Runnable, 相当于Runnable + return 一个<Future></Future></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T03_Callable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        Callable&lt;String&gt; c = <span class="keyword">new</span> Callable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"Hello Callable"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        ExecutorService service = Executors.newCachedThreadPool();</span><br><span class="line">        Future&lt;String&gt; future = service.submit(c); <span class="comment">//异步</span></span><br><span class="line"></span><br><span class="line">        System.out.println(future.get());<span class="comment">//阻塞</span></span><br><span class="line"></span><br><span class="line">        service.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h4><p>存储执行的任务将来才会产生的结果<br>ExcutorService.submit(task, result) 返回值是Future</p>
<p><img src="/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20200529125137980.png" alt="image-20200529125137980"></p>
<h4 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h4><p>更灵活, <strong>既是一个Runnable又可以存结果</strong><br>Future + Runnable<br><img src="/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/../../../只要学不死 就往死里学/note/JUC/image/笔记/image-20200529130051594.png" alt="image-20200529130051594" style="zoom:67%;"><br><img src="/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/../../../只要学不死 就往死里学/note/JUC/image/笔记/image-20200529130142044.png" alt="image-20200529130142044" style="zoom:67%;"></p>
<p>FutureTask对比Callable</p>
<p>Callable执行完, 需要另外的Future进行存储<br>FutureTask执行完, 结果保存在自己这<br><img src="/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/../../../只要学不死 就往死里学/note/JUC/image/笔记/image-20200529130307731.png" alt="image-20200529130307731" style="zoom:50%;"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T06_00_Future</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">      </span><br><span class="line">      FutureTask&lt;Integer&gt; task = <span class="keyword">new</span> FutureTask&lt;&gt;(()-&gt;&#123;</span><br><span class="line">         TimeUnit.MILLISECONDS.sleep(<span class="number">500</span>);</span><br><span class="line">         <span class="keyword">return</span> <span class="number">1000</span>;</span><br><span class="line">      &#125;); <span class="comment">//new Callable () &#123; Integer call();&#125;</span></span><br><span class="line">      </span><br><span class="line">      <span class="keyword">new</span> Thread(task).start();</span><br><span class="line">      </span><br><span class="line">      System.out.println(task.get()); <span class="comment">//阻塞</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="CompletableFutrue"><a href="#CompletableFutrue" class="headerlink" title="CompletableFutrue"></a>CompletableFutrue</h4><p>方便各种任务的管理, 同时管理多个Future</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;Double&gt; futureTM = CompletableFuture.supplyAsync(()-&gt;priceOfTM());</span><br><span class="line">        CompletableFuture&lt;Double&gt; futureTB = CompletableFuture.supplyAsync(()-&gt;priceOfTB());</span><br><span class="line">        CompletableFuture&lt;Double&gt; futureJD = CompletableFuture.supplyAsync(()-&gt;priceOfJD());</span><br><span class="line"></span><br><span class="line">        CompletableFuture.allOf(futureTM, futureTB, futureJD).join();</span><br><span class="line"></span><br><span class="line">        CompletableFuture.supplyAsync(()-&gt;priceOfTM())</span><br><span class="line">                .thenApply(String::valueOf)</span><br><span class="line">                .thenApply(str-&gt; <span class="string">"price "</span> + str)</span><br><span class="line">                .thenAccept(System.out::println);</span><br></pre></td></tr></table></figure>



<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p>线程池 ： 线程集合hashset + 任务集合</p>
<img src="/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/../../../只要学不死 就往死里学/note/JUC/md/image/image-20200403203015066.png" alt="image-20200403203015066" style="zoom: 67%;">

<p><img src="/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/../../../只要学不死 就往死里学/note/JUC/md/image/image-20200403195118211.png" alt="image-20200403195118211" style="zoom:80%;"><img src="/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/../../../只要学不死 就往死里学/note/JUC/md/image/image-20200403201544155.png" alt="image-20200403201544155" style="zoom:67%;"></p>
<img src="/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/../../../只要学不死 就往死里学/note/JUC/image/SE笔记/image-20200522120920520.png" alt="image-20200522120920520" style="zoom: 50%;">

<h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><img src="/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/../../../只要学不死 就往死里学/note/JUC/image/SE笔记/image-20200522120855575.png" alt="image-20200522120855575" style="zoom: 67%;">


<img src="/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/../../../只要学不死 就往死里学/note/JUC/image/笔记/image-20200522121506135.png" alt="image-20200522121506135" style="zoom:67%;">

<h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><img src="/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/../../../只要学不死 就往死里学/note/JUC/image/SE笔记/image-20200522120956504.png" alt="image-20200522120956504" style="zoom: 67%;">

<h4 id="生命周期-1"><a href="#生命周期-1" class="headerlink" title="生命周期"></a>生命周期</h4><p><img src="/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20200530071412193.png" alt="image-20200530071412193"></p>
<p>Running状态的线程, 调用ShutDown() 进入ShutDown状态;  调用ShutDownNow(), 进入Stop状态</p>
<img src="/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/../../../只要学不死 就往死里学/note/JUC/image/笔记/image-20200522121038785.png" alt="image-20200522121038785" style="zoom: 50%;">

<h4 id="七个参数"><a href="#七个参数" class="headerlink" title="七个参数"></a>七个参数</h4><img src="/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/../../../只要学不死 就往死里学/note/JUC/image/笔记/image-20200522121055638.png" alt="image-20200522121055638" style="zoom: 67%;">


<img src="/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/../../../只要学不死 就往死里学/note/JUC/image/SE笔记/image-20200522121106590.png" alt="image-20200522121106590" style="zoom:67%;">

<p><img src="/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20200529132654110.png" alt="image-20200529132654110"></p>
<img src="/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/../../../只要学不死 就往死里学/note/JUC/md/image/image-20200403190747668.png" alt="image-20200403190747668" style="zoom: 67%;">

<h5 id="拒绝策略-1-任务队列满-2-线程池满"><a href="#拒绝策略-1-任务队列满-2-线程池满" class="headerlink" title="拒绝策略: 1.任务队列满 2.线程池满"></a><strong>拒绝策略: 1.任务队列满 2.线程池满</strong></h5><p>JDK默认提供四种</p>
<img src="/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/../../../只要学不死 就往死里学/note/JUC/image/笔记/image-20200529133742585.png" alt="image-20200529133742585" style="zoom:80%;">

<p>阿里规约<br><img src="/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/../../../只要学不死 就往死里学/note/JUC/image/笔记/image-20200529133303945.png" alt="image-20200529133303945" style="zoom: 67%;"></p>
<img src="/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/../../../只要学不死 就往死里学/note/JUC/image/笔记/image-20200529133426122.png" alt="image-20200529133426122" style="zoom:67%;">



<h4 id="submit与execute区别"><a href="#submit与execute区别" class="headerlink" title="submit与execute区别"></a>submit与execute区别</h4><h5 id="（1）可以接受的任务类型"><a href="#（1）可以接受的任务类型" class="headerlink" title="（1）可以接受的任务类型"></a><strong>（1）可以接受的任务类型</strong></h5><p>​        submit：</p>
<p>​        <img src="/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/20151202163536892" alt="img"></p>
<p>​       execute：</p>
<p>​       <img src="/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/20151202163634814" alt="img"></p>
<p>​       可以看出：</p>
<p>​            execute只能接受Runnable类型的任务</p>
<p>​            submit不管是Runnable还是Callable类型的任务都可以接受，但是Runnable返回值均为void，所以使用Future的get()获得的还是null</p>
<p><strong>（2）返回值</strong></p>
<p>​        由Callable和Runnable的区别可知：</p>
<p>​        execute没有返回值</p>
<p>​        submit有返回值，所以需要返回值的时候必须使用submit</p>
<p><strong>（3）异常</strong></p>
<p>​        <strong>1.execute中抛出异常</strong></p>
<p>​          <strong>execute中的是Runnable接口的实现</strong>，所以<strong>只能使用try、catch</strong>来捕获CheckedException，通过实现UncaughtExceptionHande接口处理UncheckedException</p>
<p>​          即和普通线程的处理方式完全一致</p>
<p>​        <strong>2.submit中抛出异常</strong></p>
<p>​          <strong>不管提交的是Runnable还是Callable类型的任务，如果不对返回值Future调用get()方法，都会吃掉异常</strong></p>
<h4 id="Executors"><a href="#Executors" class="headerlink" title="Executors"></a>Executors</h4><p>线程池的工厂, 工具类</p>
<h4 id="JDK自带线程池"><a href="#JDK自带线程池" class="headerlink" title="JDK自带线程池"></a>JDK自带线程池</h4><h5 id="SingleThreadPool"><a href="#SingleThreadPool" class="headerlink" title="SingleThreadPool"></a>SingleThreadPool</h5><ul>
<li>意义在于: 任务队列不用自己维护, 线程的生命周期不自己管理</li>
<li>核心和最大都是1</li>
<li>任务队列是阻塞队列</li>
<li>阻塞队列最大Integer.MAX</li>
<li>使用单个工作线程来执行一个无边界的队列。（注意，如果单个线程在执行过程中因为某些错误中止，新的线程会替代它执行后续线程）。它可以保证认为是按顺序执行的，任何时候都不会有多于一个的任务处于活动状态。和 <strong>newFixedThreadPool(1)</strong> 的区别在于，如果线程遇到错误中止，它是无法使用替代线程的。<br><img src="/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20200530065410475.png" alt="image-20200530065410475"></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 顺序执行</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		ExecutorService service = Executors.newSingleThreadExecutor();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">final</span> <span class="keyword">int</span> j = i;</span><br><span class="line">			<span class="comment">// 没有线程, 阻塞住</span></span><br><span class="line">			service.execute(()-&gt;&#123;</span><br><span class="line">				</span><br><span class="line">				System.out.println(j + <span class="string">" "</span> + Thread.currentThread().getName());</span><br><span class="line">			&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h5 id="CachedThreadPool"><a href="#CachedThreadPool" class="headerlink" title="CachedThreadPool"></a>CachedThreadPool</h5><ul>
<li>核心线程数0, 最大线程数Integer.MAX_VALUE (<strong>线程数几乎达不到,区别于阻塞队列的MAX</strong>)</li>
<li>空闲线程存活时间60S</li>
<li>任务队列是同步队列</li>
<li>特点: <strong>来了就进入任务队列</strong>, 任务队列SynchronousQueue是<strong>手递手</strong>的, 容量为0<br>来一个任务, 必须马上执行, 没有线程执行, 马上new一个</li>
<li>优势: <strong>大量短生命周期的异步任务时</strong>, 不会堆积, 不会启动特别多的线程时使用</li>
<li>调用 <strong>execute</strong> 时，<strong>重用空闲线程</strong>，如果不存在空闲线程，那么会重新创建一个新的线程。如果线程<strong>超过 60 秒</strong>还未被使用，就会被中止并从缓存中<strong>移除</strong>。因此，<strong>线程池在长时间空闲后不会消耗任何资源</strong>。<br><img src="/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20200530065629729.png" alt="image-20200530065629729"></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">		ExecutorService service = Executors.newCachedThreadPool();</span><br><span class="line">		System.out.println(service);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">			service.execute(() -&gt; &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					TimeUnit.MILLISECONDS.sleep(<span class="number">500</span>);</span><br><span class="line">				&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">				System.out.println(Thread.currentThread().getName());</span><br><span class="line">			&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(service);</span><br><span class="line">		</span><br><span class="line">		TimeUnit.SECONDS.sleep(<span class="number">80</span>);</span><br><span class="line">		</span><br><span class="line">		System.out.println(service);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h5 id="FixedThreadPool"><a href="#FixedThreadPool" class="headerlink" title="FixedThreadPool"></a>FixedThreadPool</h5><ul>
<li><strong>固定线程数量</strong></li>
<li><strong>所有线程都是核心线程,</strong> 因此<strong>没有回收</strong>, 空闲回收时间是0</li>
<li>任务队列是<strong>阻塞队列</strong>, 最大<strong>Integer.MAX_VALUE</strong></li>
<li>复用 <strong>固定数量的线程</strong> 处理一个 <strong>共享的无边界队列</strong> 。任何时间点，最多有 nThreads 个线程会处于活动状态执行任务。如果当所有线程都是活动时，有多的任务被提交过来，那么它会一致在队列中等待直到有线程可用。如果任何线程在执行过程中因为错误而中止，新的线程会替代它的位置来执行后续的任务。<strong>所有线程都会一致存于线程池中，直到执行 ExecutorService.shutdown() 关闭。</strong><br><img src="/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20200530073303210.png" alt="image-20200530073303210"></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 4核CPU, 4个线程, 并行执行任务, 计算0-20000的质数</span></span><br><span class="line"><span class="comment">// 单线程2.8秒, 四线程不到1秒</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> cpuCoreNum = <span class="number">4</span>;</span><br><span class="line">		</span><br><span class="line">		ExecutorService service = Executors.newFixedThreadPool(cpuCoreNum);</span><br><span class="line">		</span><br><span class="line">		MyTask t1 = <span class="keyword">new</span> MyTask(<span class="number">1</span>, <span class="number">80000</span>); <span class="comment">//1-5 5-10 10-15 15-20</span></span><br><span class="line">		MyTask t2 = <span class="keyword">new</span> MyTask(<span class="number">80001</span>, <span class="number">130000</span>);</span><br><span class="line">		MyTask t3 = <span class="keyword">new</span> MyTask(<span class="number">130001</span>, <span class="number">170000</span>);</span><br><span class="line">		MyTask t4 = <span class="keyword">new</span> MyTask(<span class="number">170001</span>, <span class="number">200000</span>);</span><br><span class="line">		</span><br><span class="line">		Future&lt;List&lt;Integer&gt;&gt; f1 = service.submit(t1);</span><br><span class="line">		Future&lt;List&lt;Integer&gt;&gt; f2 = service.submit(t2);</span><br><span class="line">		Future&lt;List&lt;Integer&gt;&gt; f3 = service.submit(t3);</span><br><span class="line">		Future&lt;List&lt;Integer&gt;&gt; f4 = service.submit(t4);</span><br><span class="line">		</span><br><span class="line">		start = System.currentTimeMillis();</span><br><span class="line">		f1.get();</span><br><span class="line">		f2.get();</span><br><span class="line">		f3.get();</span><br><span class="line">		f4.get();</span><br><span class="line">		end = System.currentTimeMillis();</span><br><span class="line">		System.out.println(end - start);</span><br></pre></td></tr></table></figure>

<h6 id="并发-amp-并行"><a href="#并发-amp-并行" class="headerlink" title="并发 &amp; 并行"></a>并发 &amp; 并行</h6><img src="/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/../../../只要学不死 就往死里学/note/JUC/image/笔记/image-20200530075537742.png" alt="image-20200530075537742" style="zoom:67%;">

<h5 id="CachedThreadPool和FixedThreadPool选择"><a href="#CachedThreadPool和FixedThreadPool选择" class="headerlink" title="CachedThreadPool和FixedThreadPool选择"></a>CachedThreadPool和FixedThreadPool选择</h5><p>任务量忽大忽小, 用Cached<br>任务量比较平稳, 用Fixed</p>
<h5 id="ScheduledThreadPool"><a href="#ScheduledThreadPool" class="headerlink" title="ScheduledThreadPool"></a>ScheduledThreadPool</h5><ul>
<li><p>定时任务线程池</p>
<img src="/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/../../../只要学不死 就往死里学/note/JUC/image/笔记/image-20200530075137625.png" alt="image-20200530075137625" style="zoom:80%;">

</li>
</ul>
<img src="/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/../../../只要学不死 就往死里学/note/JUC/image/笔记/image-20200530074810921.png" alt="image-20200530074810921" style="zoom:80%;">

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		ScheduledExecutorService service = Executors.newScheduledThreadPool(<span class="number">4</span>);</span><br><span class="line">		service.scheduleAtFixedRate(()-&gt;&#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				TimeUnit.MILLISECONDS.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">1000</span>));</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(Thread.currentThread().getName());</span><br><span class="line">		&#125;, <span class="number">0</span>, <span class="number">500</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h5 id="WorkStealingPool"><a href="#WorkStealingPool" class="headerlink" title="WorkStealingPool"></a>WorkStealingPool</h5><ul>
<li><p>每个线程维护一个自己的任务队列</p>
</li>
<li><p>空闲的线程从其他线程的队列中偷一个任务执行</p>
</li>
<li><p>new了一个ForkJoinPool</p>
<img src="/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/../../../只要学不死 就往死里学/note/JUC/image/笔记/image-20200530093103697.png" alt="image-20200530093103697" style="zoom:67%;">
<img src="/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/../../../只要学不死 就往死里学/note/JUC/image/笔记/image-20200530092942647.png" alt="image-20200530092942647" style="zoom:67%;">

</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		ExecutorService service = Executors.newWorkStealingPool();</span><br><span class="line">		System.out.println(Runtime.getRuntime().availableProcessors());</span><br><span class="line"></span><br><span class="line">		service.execute(<span class="keyword">new</span> R(<span class="number">1000</span>));</span><br><span class="line">		service.execute(<span class="keyword">new</span> R(<span class="number">2000</span>));</span><br><span class="line">		service.execute(<span class="keyword">new</span> R(<span class="number">2000</span>));</span><br><span class="line">		service.execute(<span class="keyword">new</span> R(<span class="number">2000</span>)); <span class="comment">//daemon</span></span><br><span class="line">		service.execute(<span class="keyword">new</span> R(<span class="number">2000</span>));</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//由于产生的是精灵线程（守护线程、后台线程），主线程不阻塞的话，看不到输出</span></span><br><span class="line">		System.in.read(); </span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">R</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> time;</span><br><span class="line">		R(<span class="keyword">int</span> t) &#123;</span><br><span class="line">			<span class="keyword">this</span>.time = t;</span><br><span class="line">		&#125;</span><br><span class="line">        </span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				TimeUnit.MILLISECONDS.sleep(time);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">            </span><br><span class="line">			System.out.println(time  + <span class="string">" "</span> + Thread.currentThread().getName());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h5 id="ForkJoinPool"><a href="#ForkJoinPool" class="headerlink" title="ForkJoinPool"></a>ForkJoinPool</h5><ul>
<li>父任务分成小任务, 最后结果汇总<img src="/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/../../../只要学不死 就往死里学/note/JUC/image/笔记/image-20200530093324219.png" alt="image-20200530093324219" style="zoom:67%;">
<img src="/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/../../../只要学不死 就往死里学/note/JUC/image/笔记/image-20200530093513702.png" alt="image-20200530093513702" style="zoom: 80%;">
<img src="/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/../../../只要学不死 就往死里学/note/JUC/image/笔记/image-20200530093851923.png" alt="image-20200530093851923" style="zoom: 80%;">

</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T12_ForkJoinPool</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1000000</span>];</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_NUM = <span class="number">50000</span>;</span><br><span class="line">	<span class="keyword">static</span> Random r = <span class="keyword">new</span> Random();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.length; i++) &#123;</span><br><span class="line">			nums[i] = r.nextInt(<span class="number">100</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">"---"</span> + Arrays.stream(nums).sum()); <span class="comment">//stream api</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 不带返回值的</span></span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AddTask</span> <span class="keyword">extends</span> <span class="title">RecursiveAction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> start, end;</span><br><span class="line"></span><br><span class="line">		AddTask(<span class="keyword">int</span> s, <span class="keyword">int</span> e) &#123;</span><br><span class="line">			start = s;</span><br><span class="line">			end = e;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span>(end-start &lt;= MAX_NUM) &#123;</span><br><span class="line">				<span class="keyword">long</span> sum = <span class="number">0L</span>;</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> i=start; i&lt;end; i++) sum += nums[i];</span><br><span class="line">				System.out.println(<span class="string">"from:"</span> + start + <span class="string">" to:"</span> + end + <span class="string">" = "</span> + sum);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">int</span> middle = start + (end-start)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">				AddTask subTask1 = <span class="keyword">new</span> AddTask(start, middle);</span><br><span class="line">				AddTask subTask2 = <span class="keyword">new</span> AddTask(middle, end);</span><br><span class="line">				subTask1.fork();</span><br><span class="line">				subTask2.fork();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 带返回值的</span></span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AddTaskRet</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">		<span class="keyword">int</span> start, end;</span><br><span class="line">		AddTaskRet(<span class="keyword">int</span> s, <span class="keyword">int</span> e) &#123;</span><br><span class="line">			start = s;</span><br><span class="line">			end = e;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">protected</span> Long <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 达到可执行数量</span></span><br><span class="line">			<span class="keyword">if</span>(end-start &lt;= MAX_NUM) &#123;</span><br><span class="line">				<span class="keyword">long</span> sum = <span class="number">0L</span>;</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> i=start; i&lt;end; i++) sum += nums[i];</span><br><span class="line">				<span class="keyword">return</span> sum;</span><br><span class="line">			&#125; </span><br><span class="line">			<span class="comment">// 没达到数量, 继续拆分</span></span><br><span class="line">			<span class="keyword">int</span> middle = start + (end-start)/<span class="number">2</span>;</span><br><span class="line">			</span><br><span class="line">			AddTaskRet subTask1 = <span class="keyword">new</span> AddTaskRet(start, middle);</span><br><span class="line">			AddTaskRet subTask2 = <span class="keyword">new</span> AddTaskRet(middle, end);</span><br><span class="line">			subTask1.fork();</span><br><span class="line">			subTask2.fork();</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">return</span> subTask1.join() + subTask2.join();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		<span class="comment">/*ForkJoinPool fjp = new ForkJoinPool();</span></span><br><span class="line"><span class="comment">		AddTask task = new AddTask(0, nums.length);</span></span><br><span class="line"><span class="comment">		fjp.execute(task);*/</span></span><br><span class="line"></span><br><span class="line">		T12_ForkJoinPool temp = <span class="keyword">new</span> T12_ForkJoinPool();</span><br><span class="line"></span><br><span class="line">		ForkJoinPool fjp = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">		AddTaskRet task = <span class="keyword">new</span> AddTaskRet(<span class="number">0</span>, nums.length);</span><br><span class="line">		fjp.execute(task);</span><br><span class="line">		<span class="keyword">long</span> result = task.join();</span><br><span class="line">		System.out.println(result);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//System.in.read();</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="ParallelStreamAPI-并行流式API"><a href="#ParallelStreamAPI-并行流式API" class="headerlink" title="ParallelStreamAPI 并行流式API"></a>ParallelStreamAPI 并行流式API</h5><p>并行流式API， <strong>效率高于foreach</strong>, <strong>底层是ForkJoinPool</strong>, <strong>快四倍</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">   List&lt;Integer&gt; nums = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">   Random r = <span class="keyword">new</span> Random();</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span>; i++) nums.add(<span class="number">1000000</span> + r.nextInt(<span class="number">1000000</span>));</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//System.out.println(nums);</span></span><br><span class="line">   </span><br><span class="line">   <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">   nums.forEach(v-&gt;isPrime(v));</span><br><span class="line">   <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">   System.out.println(end - start); <span class="comment">// 1916</span></span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 并行流</span></span><br><span class="line">   start = System.currentTimeMillis();</span><br><span class="line">   nums.parallelStream().forEach(T13_ParallelStreamAPI::isPrime);</span><br><span class="line">   end = System.currentTimeMillis();</span><br><span class="line">   </span><br><span class="line">   System.out.println(end - start); <span class="comment">// 514</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=num/<span class="number">2</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(num % i == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="自定义拒绝策略"><a href="#自定义拒绝策略" class="headerlink" title="自定义拒绝策略"></a>自定义拒绝策略</h4><p>MyHandler implements RejectedExecutionHandler</p>
<p><img src="/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20200530090527305.png" alt="image-20200530090527305"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService service = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">4</span>, <span class="number">4</span>,</span><br><span class="line">                <span class="number">0</span>, TimeUnit.SECONDS, <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">6</span>),</span><br><span class="line">                Executors.defaultThreadFactory(),</span><br><span class="line">                <span class="keyword">new</span> MyHandler());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHandler</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor executor)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//log("r rejected")</span></span><br><span class="line">            <span class="comment">//save r kafka mysql redis</span></span><br><span class="line">            <span class="comment">//try 3 times</span></span><br><span class="line">            <span class="keyword">if</span>(executor.getQueue().size() &lt; <span class="number">10000</span>) &#123;</span><br><span class="line">                <span class="comment">//try put again();</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="线程池源码"><a href="#线程池源码" class="headerlink" title="线程池源码"></a>线程池源码</h4><img src="/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/../../../只要学不死 就往死里学/note/JUC/image/笔记/image-20200530092516213.png" alt="image-20200530092516213" style="zoom:67%;">


<p><img src="/2020/05/23/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image/%E7%AC%94%E8%AE%B0/image-20200730134028335.png" alt="image-20200730134028335"></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Java-SE/" rel="tag"># Java SE</a>
          
            <a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="tag"># 多线程</a>
          
            <a href="/tags/JUC/" rel="tag"># JUC</a>
          
            <a href="/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" rel="tag"># 并发编程</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/05/22/Spring%20IOC%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/" rel="next" title="IOC基本使用">
                <i class="fa fa-chevron-left"></i> IOC基本使用
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/06/04/Spring%E5%8E%9F%E7%90%86%E8%AE%B2%E8%A7%A3/" rel="prev" title="Spring原理讲解">
                Spring原理讲解 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/oi.jpg"
                alt="OiPunk" />
            
              <p class="site-author-name" itemprop="name">OiPunk</p>
              <p class="site-description motion-element" itemprop="description">跑到前面那棵小树再休息</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">50</span>
                  <span class="site-state-item-name">文章</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">39</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/OiPunk" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:oipunk@foxmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#线程"><span class="nav-number">1.</span> <span class="nav-text">线程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#概念"><span class="nav-number">1.1.</span> <span class="nav-text">概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#启动线程的五种方式"><span class="nav-number">1.2.</span> <span class="nav-text">启动线程的五种方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#生命周期"><span class="nav-number">1.3.</span> <span class="nav-text">生命周期</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#常用方法"><span class="nav-number">1.4.</span> <span class="nav-text">常用方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Synchronized"><span class="nav-number">2.</span> <span class="nav-text">Synchronized</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#synchronized既保证了原子性，又保证了可见性。"><span class="nav-number">2.1.</span> <span class="nav-text">synchronized既保证了原子性，又保证了可见性。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Synchronized-是可重入锁"><span class="nav-number">2.2.</span> <span class="nav-text">Synchronized 是可重入锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#synchronized的底层实现"><span class="nav-number">2.3.</span> <span class="nav-text">synchronized的底层实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Volatile"><span class="nav-number">3.</span> <span class="nav-text">Volatile</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#保证线程可见性"><span class="nav-number">3.1.</span> <span class="nav-text">保证线程可见性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#禁止指令重排序"><span class="nav-number">3.2.</span> <span class="nav-text">禁止指令重排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#锁优化"><span class="nav-number">3.3.</span> <span class="nav-text">锁优化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Synchronized注意事项"><span class="nav-number">3.4.</span> <span class="nav-text">Synchronized注意事项</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#锁"><span class="nav-number">4.</span> <span class="nav-text">锁</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#CAS-Atomic类"><span class="nav-number">4.1.</span> <span class="nav-text">CAS &#x2F; Atomic类</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#CAS调用的是Unsafe"><span class="nav-number">4.1.1.</span> <span class="nav-text">CAS调用的是Unsafe</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#CAS是乐观锁"><span class="nav-number">4.1.2.</span> <span class="nav-text">CAS是乐观锁</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ABA问题怎么解决"><span class="nav-number">4.1.3.</span> <span class="nav-text">ABA问题怎么解决</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#乐观锁（-Optimistic-Locking-）"><span class="nav-number">4.1.4.</span> <span class="nav-text">乐观锁（ Optimistic Locking ）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#悲观锁（Pessimistic-Lock）"><span class="nav-number">4.1.5.</span> <span class="nav-text">悲观锁（Pessimistic Lock）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#三种原子操作对比"><span class="nav-number">4.1.6.</span> <span class="nav-text">三种原子操作对比</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#LongAdder-分段锁-也是CAS操作"><span class="nav-number">4.1.7.</span> <span class="nav-text">LongAdder: 分段锁: 也是CAS操作</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ReentrantLock-可重入锁"><span class="nav-number">4.2.</span> <span class="nav-text">ReentrantLock : 可重入锁</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#lockIntenrrupt打断"><span class="nav-number">4.2.1.</span> <span class="nav-text">lockIntenrrupt打断</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ReentrantLock默认是非公平-可设置为公平锁"><span class="nav-number">4.2.2.</span> <span class="nav-text">ReentrantLock默认是非公平, 可设置为公平锁</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ReentrantLock-Vs-Synchronized"><span class="nav-number">4.2.3.</span> <span class="nav-text">ReentrantLock Vs Synchronized</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CountDownLatch-倒数发车"><span class="nav-number">4.3.</span> <span class="nav-text">CountDownLatch : 倒数发车</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CyclicBarrier-人满发车"><span class="nav-number">4.4.</span> <span class="nav-text">CyclicBarrier : 人满发车</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Phaser-相位器"><span class="nav-number">4.5.</span> <span class="nav-text">Phaser: 相位器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ReadWriteLock-读写锁-共享锁-读锁-排它锁-写锁"><span class="nav-number">4.6.</span> <span class="nav-text">ReadWriteLock 读写锁 [ 共享锁 (读锁) + 排它锁 (写锁) ]</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Semaphore-限流-默认非公平-可改fair参数"><span class="nav-number">4.7.</span> <span class="nav-text">Semaphore: 限流, 默认非公平, 可改fair参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Exchanger-执行到交换方法后阻塞-然后线程交换数据"><span class="nav-number">4.8.</span> <span class="nav-text">Exchanger: 执行到交换方法后阻塞, 然后线程交换数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#三道线程通信面试题"><span class="nav-number">4.9.</span> <span class="nav-text">三道线程通信面试题</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#到五停止"><span class="nav-number">4.9.1.</span> <span class="nav-text">到五停止</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#wait-notify"><span class="nav-number">4.9.1.1.</span> <span class="nav-text">wait &#x2F; notify</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#CountDownLatch"><span class="nav-number">4.9.1.2.</span> <span class="nav-text">CountDownLatch</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#LockSupport"><span class="nav-number">4.9.1.3.</span> <span class="nav-text">LockSupport</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Semaphore-join"><span class="nav-number">4.9.1.4.</span> <span class="nav-text">Semaphore + join</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#生产消费"><span class="nav-number">4.9.2.</span> <span class="nav-text">生产消费</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#wait-notify-1"><span class="nav-number">4.9.2.1.</span> <span class="nav-text">wait &#x2F; notify</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#ReentrantLock-Condition-背过"><span class="nav-number">4.9.2.2.</span> <span class="nav-text">ReentrantLock + Condition (背过)</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#交替打印"><span class="nav-number">4.9.3.</span> <span class="nav-text">交替打印</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#常用方法1-LockSupport的park-unpark"><span class="nav-number">4.9.3.1.</span> <span class="nav-text">常用方法1: LockSupport的park&#x2F;unpark</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#常用方法2-synchronized的wait-notify"><span class="nav-number">4.9.3.2.</span> <span class="nav-text">常用方法2: synchronized的wait&#x2F;notify</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#方法3-ReentrantLock-的-condition-的-signal-await"><span class="nav-number">4.9.3.3.</span> <span class="nav-text">方法3: ReentrantLock 的 condition 的 signal&#x2F;await</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#AQS-所有锁的心"><span class="nav-number">4.10.</span> <span class="nav-text">AQS (所有锁的心)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#ReentrantLock源码-lock"><span class="nav-number">4.10.1.</span> <span class="nav-text">ReentrantLock源码 lock( )</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#AQS的数据结构是双向链表-原理CAS-volatile"><span class="nav-number">4.10.2.</span> <span class="nav-text">AQS的数据结构是双向链表  原理CAS + volatile</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#AQS面试题"><span class="nav-number">4.10.3.</span> <span class="nav-text">AQS面试题</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ThreadLocal"><span class="nav-number">4.11.</span> <span class="nav-text">ThreadLocal</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#作用"><span class="nav-number">4.11.1.</span> <span class="nav-text">作用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#强软弱虚四种引用"><span class="nav-number">4.11.2.</span> <span class="nav-text">强软弱虚四种引用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#强引用-new-出来的-不回收"><span class="nav-number">4.11.3.</span> <span class="nav-text">强引用: new 出来的, 不回收</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#软引用-满则回收"><span class="nav-number">4.11.4.</span> <span class="nav-text">软引用: 满则回收</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#弱引用：一般用在容器里ThreadLocal-lt-gt-WeakHashMap"><span class="nav-number">4.11.5.</span> <span class="nav-text">弱引用：一般用在容器里ThreadLocal&lt;&gt;(), WeakHashMap</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#虚引用"><span class="nav-number">4.11.6.</span> <span class="nav-text">虚引用</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#并发容器"><span class="nav-number">5.</span> <span class="nav-text">并发容器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Map的发展历程"><span class="nav-number">5.1.</span> <span class="nav-text">Map的发展历程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#从Vector-gt-List-gt-Queue-解决超卖问题"><span class="nav-number">5.2.</span> <span class="nav-text">从Vector -&gt; List -&gt; Queue ( 解决超卖问题 )</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Synchronized-Vs-CAS"><span class="nav-number">5.3.</span> <span class="nav-text">Synchronized Vs CAS</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#跳表"><span class="nav-number">5.4.</span> <span class="nav-text">跳表</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#ConcurrentSkipListMap"><span class="nav-number">5.4.1.</span> <span class="nav-text">ConcurrentSkipListMap</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#写时复制"><span class="nav-number">5.5.</span> <span class="nav-text">写时复制</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#CopyOnWriteArrayList"><span class="nav-number">5.5.1.</span> <span class="nav-text">CopyOnWriteArrayList</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#CopyOnWriteArraySet"><span class="nav-number">5.5.2.</span> <span class="nav-text">CopyOnWriteArraySet</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#LinkedBlockingQueue-天生的生产者-消费者模型"><span class="nav-number">5.6.</span> <span class="nav-text">LinkedBlockingQueue: 天生的生产者&#x2F;消费者模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ArrayBlockingQueue"><span class="nav-number">5.7.</span> <span class="nav-text">ArrayBlockingQueue</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Queue和List的区别"><span class="nav-number">5.7.1.</span> <span class="nav-text">Queue和List的区别</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#DelayQueue"><span class="nav-number">5.8.</span> <span class="nav-text">DelayQueue:</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#PriorityQueue"><span class="nav-number">5.8.1.</span> <span class="nav-text">PriorityQueue</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SynchronousQueue-用处最大-任务调度"><span class="nav-number">5.9.</span> <span class="nav-text">SynchronousQueue 用处最大, 任务调度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TransferQueue-amp-LinkedTransferQueue"><span class="nav-number">5.10.</span> <span class="nav-text">TransferQueue &amp; LinkedTransferQueue</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程任务"><span class="nav-number">6.</span> <span class="nav-text">线程任务</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Excutor"><span class="nav-number">6.1.</span> <span class="nav-text">Excutor</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ExcutorService-方法"><span class="nav-number">6.2.</span> <span class="nav-text">ExcutorService 方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Callable"><span class="nav-number">6.3.</span> <span class="nav-text">Callable</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Future"><span class="nav-number">6.4.</span> <span class="nav-text">Future</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#FutureTask"><span class="nav-number">6.5.</span> <span class="nav-text">FutureTask</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CompletableFutrue"><span class="nav-number">6.6.</span> <span class="nav-text">CompletableFutrue</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程池"><span class="nav-number">7.</span> <span class="nav-text">线程池</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#概念-1"><span class="nav-number">7.1.</span> <span class="nav-text">概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#工作原理"><span class="nav-number">7.2.</span> <span class="nav-text">工作原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#分类"><span class="nav-number">7.3.</span> <span class="nav-text">分类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#生命周期-1"><span class="nav-number">7.4.</span> <span class="nav-text">生命周期</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#七个参数"><span class="nav-number">7.5.</span> <span class="nav-text">七个参数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#拒绝策略-1-任务队列满-2-线程池满"><span class="nav-number">7.5.1.</span> <span class="nav-text">拒绝策略: 1.任务队列满 2.线程池满</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#submit与execute区别"><span class="nav-number">7.6.</span> <span class="nav-text">submit与execute区别</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#（1）可以接受的任务类型"><span class="nav-number">7.6.1.</span> <span class="nav-text">（1）可以接受的任务类型</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Executors"><span class="nav-number">7.7.</span> <span class="nav-text">Executors</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JDK自带线程池"><span class="nav-number">7.8.</span> <span class="nav-text">JDK自带线程池</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#SingleThreadPool"><span class="nav-number">7.8.1.</span> <span class="nav-text">SingleThreadPool</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#CachedThreadPool"><span class="nav-number">7.8.2.</span> <span class="nav-text">CachedThreadPool</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#FixedThreadPool"><span class="nav-number">7.8.3.</span> <span class="nav-text">FixedThreadPool</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#并发-amp-并行"><span class="nav-number">7.8.3.1.</span> <span class="nav-text">并发 &amp; 并行</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#CachedThreadPool和FixedThreadPool选择"><span class="nav-number">7.8.4.</span> <span class="nav-text">CachedThreadPool和FixedThreadPool选择</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ScheduledThreadPool"><span class="nav-number">7.8.5.</span> <span class="nav-text">ScheduledThreadPool</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#WorkStealingPool"><span class="nav-number">7.8.6.</span> <span class="nav-text">WorkStealingPool</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ForkJoinPool"><span class="nav-number">7.8.7.</span> <span class="nav-text">ForkJoinPool</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ParallelStreamAPI-并行流式API"><span class="nav-number">7.8.8.</span> <span class="nav-text">ParallelStreamAPI 并行流式API</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#自定义拒绝策略"><span class="nav-number">7.9.</span> <span class="nav-text">自定义拒绝策略</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#线程池源码"><span class="nav-number">7.10.</span> <span class="nav-text">线程池源码</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">OiPunk</span>

  
</div>









        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "./public/search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
