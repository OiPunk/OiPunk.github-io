<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Redis的前世今生</title>
      <link href="/2020/08/03/Redis%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/"/>
      <url>/2020/08/03/Redis%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="Redis的前世今生"><a href="#Redis的前世今生" class="headerlink" title="Redis的前世今生"></a>Redis的前世今生</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><h4 id="数据存储演变过程"><a href="#数据存储演变过程" class="headerlink" title="数据存储演变过程"></a>数据存储演变过程</h4><img src="/2020/08/03/Redis%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/../../../只要学不死 就往死里学/note/Redis/image/Redis/image-20200408080531729.png" alt="image-20200408080531729" style="zoom: 80%;"><ol><li><strong>数据存储在文件中：</strong>查找数据造成全量扫描，受限于磁盘IO的瓶颈</li><li><strong>关系型数据库：</strong>关系型数据库是行级存储，会空出来没有数据列，受限于磁盘IO的瓶颈</li><li><strong>数据库放入缓存：</strong>受限于硬件，成本高<img src="/2020/08/03/Redis%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/../../../只要学不死 就往死里学/note/Redis/image/Redis/image-20200408115004299.png" alt="image-20200408115004299" style="zoom: 80%;"></li></ol><p><strong>数据的存储方式受限于：</strong></p><ol><li>冯诺依曼体系的硬件制约</li><li>以太网, TCP/IP 的网络</li></ol><p>Redis的特点，对比Memcache , value有类型 , 有类型对应的方法(API) , 计算向数据移动</p><img src="/2020/08/03/Redis%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/../../../只要学不死 就往死里学/note/Redis/image/Redis/image-20200408130647248.png" alt="image-20200408130647248" style="zoom:80%;"><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a><strong>安装</strong></h4><img src="/2020/08/03/Redis%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/../../../只要学不死 就往死里学/note/Redis/image/Redis/image-20200408130854366.png" alt="image-20200408130854366" style="zoom: 80%;"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">centos 6.x</span><br><span class="line">redis官网5.x</span><br><span class="line">http:&#x2F;&#x2F;download.redis. io&#x2F;releases&#x2F;redis-5.0.5.tar.gz</span><br><span class="line">1 , yum install wget</span><br><span class="line">2,cd ~</span><br><span class="line">3,mkdir soft</span><br><span class="line">4,cd soft</span><br><span class="line">5,wget http:&#x2F;&#x2F;download.redis.io&#x2F;releases&#x2F;redis-5.0.5.tar.gz</span><br><span class="line">6,tar xf redis.. tar.gz</span><br><span class="line">7,cd redis-src</span><br><span class="line">8,看README md</span><br><span class="line">9, make</span><br><span class="line">.. install gcc</span><br><span class="line">..... make distclean</span><br><span class="line">10,make</span><br><span class="line">11,cdsrc .. .生成了可执行程序</span><br><span class="line">12, cd ..</span><br><span class="line">13,make install PREFIX&#x3D;&#x2F;opt&#x2F;mashibing&#x2F;redis5</span><br><span class="line">14,vi &#x2F;etc&#x2F;profile</span><br><span class="line">export REDIS_ _HOME&#x3D; &#x2F;opt&#x2F;mashibing&#x2F;redis5</span><br><span class="line">export PATH&#x3D; $PATH:$REDIS_ _HOME&#x2F;bin</span><br><span class="line">.source &#x2F;etc&#x2F;profile</span><br><span class="line">15,cd utils</span><br><span class="line">16,.&#x2F;install_ server.sh ( 可以执行- -次或多次)</span><br><span class="line">)一个物理机中可以有多个redis实例(进程) ,通过port区分</span><br><span class="line">b)可执行程序就-份在目录,但是内存中未来的多个实例需要各自的配置文件,持久化目录等资源 c) service redis_ 6379 start&#x2F;stop&#x2F;stauts &gt; linux &#x2F;etc&#x2F;init.d&#x2F;***</span><br><span class="line">d)脚本还会帮你启动!</span><br><span class="line">17.ps -fe| grep redis</span><br></pre></td></tr></table></figure><img src="/2020/08/03/Redis%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/../../../只要学不死 就往死里学/note/Redis/image/Redis/image-20200408153530228.png" alt="image-20200408153530228"><img src="/2020/08/03/Redis%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/../../../只要学不死 就往死里学/note/Redis/image/Redis/image-20200408184618523.png" alt="image-20200408184618523" style="zoom:67%;"><img src="/2020/08/03/Redis%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/../../../只要学不死 就往死里学/note/Redis/image/Redis/image-20200408184643012.png" alt="image-20200408184643012" style="zoom: 67%;"><h4 id="BIO-gt-同步非阻塞NIO-gt-多路复用NIO"><a href="#BIO-gt-同步非阻塞NIO-gt-多路复用NIO" class="headerlink" title="BIO-&gt;同步非阻塞NIO-&gt;多路复用NIO"></a><strong>BIO-&gt;同步非阻塞NIO-&gt;多路复用NIO</strong></h4><p>内核不断变化</p><ol><li>BIO阻塞: 读一个socket产生的文件描述符, 如果数据包没到, read命令就不能返回, 在这阻塞着, 抛出一个线程在这阻塞着, 有数据就处理, 下边的代码执行不了, 其他线程无法处理已到达的数据, socket是阻塞的<br>一个线程的成本: 线程栈是独立的, 默认1MB, 线程多了, 调度成本提高. CPU浪费, 占用内存多</li><li>同步非阻塞NIO: 遍历, 取出来处理, 都由自己来完成, 同步非阻塞, 每个连接都要掉一次内核</li><li>多路复用NIO: 内核select(), 允许一个程序监视多个文件描述符, 等待直到一个或多个文件描述符准备好, 就能触发I/O操作了 , 一次系统调用读若干个, 返回有数据的, 减少用户态内核态切换 , 选择有数据的, 直接读</li><li>共享空间: 文件描述符都是累赘, 减少内核区域和用户空间之间传参, 把用户空间和内核空间建立映射, 相当于创建共享空间, 通过mmap系统调用, 红黑树+链表, 进程里有文件描述符就往红黑树里放, 内核可以看到, 把到达的放到链表里, 如果</li></ol><img src="/2020/08/03/Redis%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/../../../只要学不死 就往死里学/note/Redis/image/Redis/image-20200408155018832.png" alt="image-20200408155018832" style="zoom: 67%;"><p>Redis进程的文件描述符<br>0: 标准输入  1: 标准输出  2: 报错输出  3,4: pipe调用 5: epoll </p><p>kafka: sendfile + mmap<br>零拷贝: sendfile系统调用</p><img src="/2020/08/03/Redis%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/../../../只要学不死 就往死里学/note/Redis/image/Redis/image-20200408202046656.png" alt="image-20200408202046656" style="zoom: 50%;"><p>Redis为什么快: epoll :     epoll是    <a href="https://baike.baidu.com/item/Linux内核" target="_blank" rel="noopener">Linux内核</a>    为处理大批量    <a href="https://baike.baidu.com/item/文件描述符/9809582" target="_blank" rel="noopener">文件描述符</a>    而作了改进的poll，是Linux下多路复用IO接口select/poll的增强版本，它能显著提高程序在大量    <a href="https://baike.baidu.com/item/并发连接/3763280" target="_blank" rel="noopener">并发连接</a>    中只有少量活跃的情况下的系统    <a href="https://baike.baidu.com/item/CPU/120556" target="_blank" rel="noopener">CPU</a>利用率。另一点原因就是获取事件的时候，它无须遍历整个被侦听的描述符集，只要遍历那些被内核IO事件异步唤醒而加入Ready队列的描述符集合就行了。</p><p>顺序性: 每个连接内的命令顺序<br>内存寻址是ns级, 网卡是ms级, 10万倍差距, 10万连接同时时到达, 可能会产生秒级响应<br>mysql开启缓存, 想模仿redis, 性能反而会低, 多了一次判断过程, 增加了内存空间占用</p><h4 id="类比Nginx"><a href="#类比Nginx" class="headerlink" title="类比Nginx"></a><strong>类比Nginx</strong></h4><img src="/2020/08/03/Redis%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/../../../只要学不死 就往死里学/note/Redis/image/Redis/image-20200408204003689.png" alt="image-20200408204003689" style="zoom: 67%;"><img src="/2020/08/03/Redis%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/../../../只要学不死 就往死里学/note/Redis/image/Redis/image-20200408204441726.png" alt="image-20200408204441726" style="zoom: 67%;"><h3 id="5种数据类型"><a href="#5种数据类型" class="headerlink" title="5种数据类型"></a>5种数据类型</h3><img src="/2020/08/03/Redis%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/../../../只要学不死 就往死里学/note/Redis/image/Redis/image-20200409061635757.png" alt="image-20200409061635757" style="zoom: 50%;"><p><img src="/2020/08/03/Redis%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/image-20200409075037824.png" alt="image-20200409075037824"></p><p>可以根据用户的指令, 看是不是和key里存的type匹配, 不匹配直接返回, 规避异常 </p><img src="/2020/08/03/Redis%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/../../../只要学不死 就往死里学/note/Redis/image/Redis/image-20200409001118398.png" alt="image-20200409001118398" style="zoom: 67%;"><p>nx: 只能新建 分布式锁<br>xx: 只能更新 </p><h4 id="String"><a href="#String" class="headerlink" title="String"></a>String</h4><img src="/2020/08/03/Redis%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/../../../只要学不死 就往死里学/note/Redis/image/Redis/image-20200409113532196.png" alt="image-20200409113532196" style="zoom:67%;"><p><img src="/2020/08/03/Redis%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/image-20200409113353283.png" alt="image-20200409113353283"></p><img src="/2020/08/03/Redis%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/../../../只要学不死 就往死里学/note/Redis/image/Redis/image-20200409003109666.png" alt="image-20200409003109666" style="zoom: 67%;"><p>二进制安全: Redis只取字节流, 一个字符一个字节</p><img src="/2020/08/03/Redis%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/../../../只要学不死 就往死里学/note/Redis/image/Redis/image-20200409003158840.png" alt="image-20200409003158840" style="zoom: 80%;"><img src="/2020/08/03/Redis%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/../../../只要学不死 就往死里学/note/Redis/image/Redis/image-20200409003251515.png" alt="image-20200409003251515" style="zoom:80%;"><img src="/2020/08/03/Redis%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/../../../只要学不死 就往死里学/note/Redis/image/Redis/image-20200409003647771.png" alt="image-20200409003647771" style="zoom:80%;"><p>和Xshell设置有关</p><img src="/2020/08/03/Redis%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/../../../只要学不死 就往死里学/note/Redis/image/Redis/image-20200409003835955.png" alt="image-20200409003835955" style="zoom:80%;"><p>GETSET减少一次I/O</p><img src="/2020/08/03/Redis%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/../../../只要学不死 就往死里学/note/Redis/image/Redis/image-20200409004151835.png" alt="image-20200409004151835" style="zoom:80%;"><p>MSETNX原子性set, k2已经存在, 集体失败</p><img src="/2020/08/03/Redis%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/../../../只要学不死 就往死里学/note/Redis/image/Redis/image-20200409004430586.png" alt="image-20200409004430586" style="zoom:80%;"><h5 id="bitmap-活跃度-登录数"><a href="#bitmap-活跃度-登录数" class="headerlink" title="bitmap (活跃度|登录数)"></a>bitmap (活跃度|登录数)</h5><img src="/2020/08/03/Redis%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/../../../只要学不死 就往死里学/note/Redis/image/Redis/image-20200409055641576.png" alt="image-20200409055641576" style="zoom:67%;"><img src="/2020/08/03/Redis%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/../../../只要学不死 就往死里学/note/Redis/image/Redis/image-20200409055518451.png" alt="image-20200409055518451" style="zoom:67%;"><p>按位与</p><img src="/2020/08/03/Redis%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/../../../只要学不死 就往死里学/note/Redis/image/Redis/image-20200409060700318.png" alt="image-20200409060700318" style="zoom:67%;"><img src="/2020/08/03/Redis%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/../../../只要学不死 就往死里学/note/Redis/image/Redis/image-20200409060858971.png" alt="image-20200409060858971" style="zoom:67%;"><p>bitmap优势, 举例: 统计用户登录, 按位与, 统计365天, key是天<br><img src="/2020/08/03/Redis%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/image-20200409070846180.png" alt="image-20200409070846180"></p><img src="/2020/08/03/Redis%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/../../../只要学不死 就往死里学/note/Redis/image/Redis/image-20200409065325283.png" alt="image-20200409065325283" style="zoom: 80%;"><p>举例: 共计活跃用户数<br>第一天a登录, 第二天ab都登陆, 按位或统计活跃用户数, key是日期, value是用户登录情况</p><p><img src="/2020/08/03/Redis%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/image-20200409071145058.png" alt="image-20200409071145058"></p><img src="/2020/08/03/Redis%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/../../../只要学不死 就往死里学/note/Redis/image/Redis/image-20200409070205536.png" alt="image-20200409070205536" style="zoom:80%;"><h4 id="list-栈-队列"><a href="#list-栈-队列" class="headerlink" title="list (栈|队列)"></a>list (栈|队列)</h4><img src="/2020/08/03/Redis%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/../../../只要学不死 就往死里学/note/Redis/image/Redis/image-20200409124546810.png" alt="image-20200409124546810" style="zoom:67%;"><p>同向操作: 栈<br>反向操作: 队列<br>正反索引</p><img src="/2020/08/03/Redis%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/../../../只要学不死 就往死里学/note/Redis/image/Redis/image-20200409134226364.png" alt="image-20200409134226364" style="zoom: 80%;"><p><img src="/2020/08/03/Redis%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/../../../只要学不死 就往死里学/note/Redis/image/Redis/image-20200409134757688.png" alt="image-20200409134757688" style="zoom: 80%;"><img src="/2020/08/03/Redis%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/image-20200409134906136.png" alt="image-20200409134906136"></p><img src="/2020/08/03/Redis%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/../../../只要学不死 就往死里学/note/Redis/image/Redis/image-20200409134757688.png" alt="image-20200409134757688" style="zoom: 80%;">![image-20200409134906136](Redis的前世今生/image-20200409134906136.png)<h4 id="hash-点赞-收藏-详情页"><a href="#hash-点赞-收藏-详情页" class="headerlink" title="hash (点赞|收藏|详情页)"></a>hash (点赞|收藏|详情页)</h4><p><img src="/2020/08/03/Redis%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/image-20200409192807821.png" alt="image-20200409192807821"></p><img src="/2020/08/03/Redis%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/../../../只要学不死 就往死里学/note/Redis/image/Redis/image-20200409184326045.png" alt="image-20200409184326045" style="zoom:80%;"><img src="/2020/08/03/Redis%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/../../../只要学不死 就往死里学/note/Redis/image/Redis/image-20200409184434046.png" alt="image-20200409184434046" style="zoom:67%;"><img src="/2020/08/03/Redis%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/../../../只要学不死 就往死里学/note/Redis/image/Redis/image-20200409184326045.png" alt="image-20200409184326045" style="zoom: 67%;"><img src="/2020/08/03/Redis%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/../../../只要学不死 就往死里学/note/Redis/image/Redis/image-20200409184434046.png" alt="image-20200409184434046" style="zoom:67%;"><img src="/2020/08/03/Redis%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/../../../只要学不死 就往死里学/note/Redis/image/Redis/image-20200409184326045.png" alt="image-20200409184326045" style="zoom: 67%;"><img src="/2020/08/03/Redis%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/../../../只要学不死 就往死里学/note/Redis/image/Redis/image-20200409184434046.png" alt="image-20200409184434046" style="zoom:67%;"><img src="/2020/08/03/Redis%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/../../../只要学不死 就往死里学/note/Redis/image/Redis/image-20200409184434046.png" alt="image-20200409184434046" style="zoom:67%;"><img src="/2020/08/03/Redis%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/../../../只要学不死 就往死里学/note/Redis/image/Redis/image-20200409184326045.png" alt="image-20200409184326045" style="zoom: 50%;"><img src="/2020/08/03/Redis%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/../../../只要学不死 就往死里学/note/Redis/image/Redis/image-20200409184434046.png" alt="image-20200409184434046" style="zoom:67%;"><img src="/2020/08/03/Redis%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/../../../只要学不死 就往死里学/note/Redis/image/Redis/image-20200409184559748.png" alt="image-20200409184559748" style="zoom:67%;"><h4 id="set-交并差集"><a href="#set-交并差集" class="headerlink" title="set (交并差集)"></a>set (交并差集)<img src="/2020/08/03/Redis%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/image-20200409204042872.png" alt="image-20200409204042872"></h4><p>取交集</p><img src="/2020/08/03/Redis%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/../../../只要学不死 就往死里学/note/Redis/image/Redis/image-20200409185350295.png" alt="image-20200409185350295" style="zoom:67%;"><p>取并集</p><img src="/2020/08/03/Redis%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/../../../只要学不死 就往死里学/note/Redis/image/Redis/image-20200409185449005.png" alt="image-20200409185449005" style="zoom:67%;"><p>取外差</p><img src="/2020/08/03/Redis%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/../../../只要学不死 就往死里学/note/Redis/image/Redis/image-20200409185516331.png" alt="image-20200409185516331" style="zoom:67%;"><p>取随机, 抽奖, 正数不可重复出现, 负数可重复出现<br><img src="/2020/08/03/Redis%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/../../../只要学不死 就往死里学/note/Redis/image/Redis/image-20200409190426588.png" alt="image-20200409190426588" style="zoom: 67%;"></p><img src="/2020/08/03/Redis%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/../../../只要学不死 就往死里学/note/Redis/image/Redis/image-20200409190555586.png" alt="image-20200409190555586" style="zoom:67%;"><p>spop随机抽</p><h4 id="sorted-set-排行榜"><a href="#sorted-set-排行榜" class="headerlink" title="sorted set (排行榜)"></a>sorted set (排行榜)</h4><img src="/2020/08/03/Redis%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/../../../只要学不死 就往死里学/note/Redis/image/Redis/image-20200409203930436.png" alt="image-20200409203930436" style="zoom: 80%;"><img src="/2020/08/03/Redis%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/../../../只要学不死 就往死里学/note/Redis/image/Redis/image-20200409194007602.png" alt="image-20200409194007602" style="zoom:80%;"><img src="/2020/08/03/Redis%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/../../../只要学不死 就往死里学/note/Redis/image/Redis/image-20200409204523505.png" alt="image-20200409204523505" style="zoom:67%;"><img src="/2020/08/03/Redis%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/../../../只要学不死 就往死里学/note/Redis/image/Redis/image-20200409203723767.png" alt="image-20200409203723767" style="zoom:67%;"><img src="/2020/08/03/Redis%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/../../../只要学不死 就往死里学/note/Redis/image/Redis/image-20200409205031951.png" alt="image-20200409205031951" style="zoom:67%;"><img src="/2020/08/03/Redis%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/../../../只要学不死 就往死里学/note/Redis/image/Redis/image-20200409205031951.png" alt="image-20200409205031951" style="zoom: 67%;"><img src="/2020/08/03/Redis%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/../../../只要学不死 就往死里学/note/Redis/image/Redis/image-20200409205154261.png" alt="image-20200409205154261" style="zoom:67%;"><h5 id="跳表-随机造层"><a href="#跳表-随机造层" class="headerlink" title="跳表 (随机造层)"></a>跳表 (随机造层)</h5><img src="/2020/08/03/Redis%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/../../../只要学不死 就往死里学/note/Redis/image/Redis/image-20200409210122129.png" alt="image-20200409210122129" style="zoom:80%;"><p>图错了</p><img src="/2020/08/03/Redis%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/../../../只要学不死 就往死里学/note/Redis/image/Redis/image-20200409210100570.png" alt="image-20200409210100570" style="zoom: 80%;"><img src="/2020/08/03/Redis%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/../../../只要学不死 就往死里学/note/Redis/image/Redis/image-20200409210819329.png" alt="image-20200409210819329" style="zoom:67%;"><h3 id="进阶使用"><a href="#进阶使用" class="headerlink" title="进阶使用"></a>进阶使用</h3><h4 id="管道Pipeline"><a href="#管道Pipeline" class="headerlink" title="管道Pipeline"></a>管道Pipeline</h4><p>客户端连接服务端: </p><img src="/2020/08/03/Redis%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/../../../只要学不死 就往死里学/note/Redis/image/Redis/image-20200410053723804.png" alt="image-20200410053723804" style="zoom:67%;"><p>redis 管道 pipeline 一次多条指令</p><img src="/2020/08/03/Redis%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/../../../只要学不死 就往死里学/note/Redis/image/Redis/image-20200410053427849.png" alt="image-20200410053427849" style="zoom:67%;"><h5 id="订阅发布"><a href="#订阅发布" class="headerlink" title="订阅发布"></a>订阅发布</h5><p>订阅发布, 订阅之后才能收到发布的消息</p><img src="/2020/08/03/Redis%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/../../../只要学不死 就往死里学/note/Redis/image/Redis/image-20200410054646720.png" alt="image-20200410054646720" style="zoom: 67%;"><img src="/2020/08/03/Redis%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/../../../只要学不死 就往死里学/note/Redis/image/Redis/image-20200410054710442.png" alt="image-20200410054710442" style="zoom:67%;"><p>客户端读历史消息和实时消息<br>redis实时消息, sorted list 日期排序, </p><h5 id="聊天室-Redis-DB"><a href="#聊天室-Redis-DB" class="headerlink" title="聊天室 : Redis+DB"></a>聊天室 : Redis+DB</h5><p>​    接收消息: </p><ul><li><strong>实时</strong>的消息: 通过<strong>发布订阅</strong></li><li><strong>3天内</strong>: <strong>sorted_set</strong>, 时间作为分值, 消息作为元素</li><li>历史记录: DB</li></ul><p>​    发送消息: </p><ul><li>一份直接发到Redis的发布订阅, 一份通过Kafka写到数据库</li></ul><img src="/2020/08/03/Redis%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/../../../只要学不死 就往死里学/note/Redis/image/Redis/image-20200410055249924.png" alt="image-20200410055249924" style="zoom: 80%;"><p>第二种方式实现聊天室: 双实例</p><img src="/2020/08/03/Redis%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/../../../只要学不死 就往死里学/note/Redis/image/Redis/image-20200410055947169.png" alt="image-20200410055947169" style="zoom: 80%;"><h4 id="Redis事务-无回滚"><a href="#Redis事务-无回滚" class="headerlink" title="Redis事务(无回滚)"></a>Redis事务(<strong>无回滚</strong>)</h4><ul><li>muti: 开启事务, 所有指令按客户端排队</li><li>exec: 执行事务(哪个客户端的exec先来, 先执行谁的所有指令)</li><li>watch: 开启事务之前, 监控某个元素, 发现被更改, 后续相关指令不执行</li><li>DISCARD: 放弃执行事务, 清空事务队列</li></ul><p><img src="/2020/08/03/Redis%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/image-20200410060037405.png" alt="image-20200410060037405"></p><h5 id="演示事务"><a href="#演示事务" class="headerlink" title="演示事务"></a>演示事务</h5><p>客户端1: 后开启事务, 删除k1<br><img src="/2020/08/03/Redis%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/../../../只要学不死 就往死里学/note/Redis/image/Redis/image-20200410061357607.png" alt="image-20200410061357607" style="zoom: 80%;"></p><p>客户端2: 先开启事务, get不到k1<br><img src="/2020/08/03/Redis%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/image-20200612124145896.png" alt="image-20200612124145896"></p><p>演示watch: k1改了, 事务不执行</p><p>客户端1: 由于k1的值被更改, 相关命令不执行<br><img src="/2020/08/03/Redis%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/../../../只要学不死 就往死里学/note/Redis/image/Redis/image-20200410061613062.png" alt="image-20200410061613062" style="zoom: 80%;"></p><p>客户端2:<br><img src="/2020/08/03/Redis%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/../../../只要学不死 就往死里学/note/Redis/image/Redis/image-20200410061636588.png" alt="image-20200410061636588" style="zoom:80%;"></p><h5 id="不支持回滚"><a href="#不支持回滚" class="headerlink" title="不支持回滚"></a>不支持回滚</h5><ul><li>Redis 命令只会因为<strong>错误的语法而失败</strong>（并且这些问题不能在入队时发现），或是命令用在了错误类型的键上面：这也就是说，从实用性的角度来说，失败的命令是由<strong>编程错误造成</strong>的，而这些错误应该在开发的过程中被发现，而<strong>不应该出现在生产环境</strong>中。</li><li>因为不需要对回滚进行支持，所以 Redis 的内部可以保持简单且快速。</li></ul><p>有种观点认为 Redis 处理事务的做法会产生 bug ， 然而需要注意的是， 在通常情况下， 回滚并不能解决编程错误带来的问题。 举个例子， 如果你本来想通过 <a href="http://redis.cn/commands/incr.html" target="_blank" rel="noopener">INCR</a> 命令将键的值加上 1 ， 却不小心加上了 2 ， 又或者对错误类型的键执行了 <a href="http://redis.cn/commands/incr.html" target="_blank" rel="noopener">INCR</a> ， 回滚是没有办法处理这些情况的。](../image/Redis/image-20200410061754103.png)</p><h4 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h4><p><strong>启动Redis时, 添加布隆过滤器的扩展库</strong></p><h5 id="通过bitmap二进制位数组-映射函数"><a href="#通过bitmap二进制位数组-映射函数" class="headerlink" title="通过bitmap二进制位数组+映射函数"></a>通过bitmap二进制位数组+映射函数</h5><p><img src="/2020/08/03/Redis%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/image-20200410063050476.png" alt="image-20200410063050476"></p><p>三种方式, <strong>最好放在服务端</strong></p><p><img src="/2020/08/03/Redis%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/image-20200410063202681.png" alt="image-20200410063202681"></p><img src="/2020/08/03/Redis%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/../../../只要学不死 就往死里学/note/Redis/image/Redis/image-20200411100955789.png" alt="image-20200411100955789" style="zoom:67%;"><h5 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1，访问redis.io</span><br><span class="line">2,modules</span><br><span class="line">3,访问RedisBloom的github</span><br><span class="line">      https:&#x2F;&#x2F;github.com&#x2F;RedisBloom&#x2F;RedisBloom</span><br><span class="line">4，linux中wget  *.zip</span><br><span class="line">5,yum install unzip</span><br><span class="line">6,unzip *.zip</span><br><span class="line">7,make</span><br><span class="line">8,cp bloom.so  &#x2F;opt&#x2F;mashibing&#x2F;redis5&#x2F;</span><br><span class="line">9,redis-server --loadmodule  &#x2F;opt&#x2F;mashibing&#x2F;redis5&#x2F;redisbloom.so</span><br><span class="line"></span><br><span class="line">10 ,redis-cli  </span><br><span class="line">11,bf.add  ooxx  abc</span><br><span class="line">bf.exits   abc</span><br><span class="line">bf.exits  sdfsdf</span><br><span class="line"></span><br><span class="line">12,cf.add   #  布谷鸟过滤器</span><br></pre></td></tr></table></figure><h4 id="Redis作为缓存和数据库的区别"><a href="#Redis作为缓存和数据库的区别" class="headerlink" title="Redis作为缓存和数据库的区别"></a>Redis作为缓存和数据库的区别</h4><p><img src="/2020/08/03/Redis%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/image-20200411103336509.png" alt="image-20200411103336509"></p><p><img src="/2020/08/03/Redis%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/image-20200411112353530.png" alt="image-20200411112353530"></p><h4 id="Redis回收策略"><a href="#Redis回收策略" class="headerlink" title="Redis回收策略"></a>Redis回收策略</h4><p>过期判定原理：</p><ol><li>被动访问时判定</li><li>周期轮询判定（增量）</li></ol><p>*，目的，稍微牺牲下内存，但是保住了redis性能为王！！！！</p><h5 id="Maxmemory配置指令"><a href="#Maxmemory配置指令" class="headerlink" title="Maxmemory配置指令"></a>Maxmemory配置指令</h5><p><code>maxmemory</code>配置指令用于配置Redis存储数据时指定限制的内存大小。通过redis.conf可以设置该指令，或者之后使用CONFIG SET命令来进行运行时配置。</p><p>例如为了配置内存限制为100mb，以下的指令可以放在<code>redis.conf</code>文件中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">maxmemory 100mb</span><br></pre></td></tr></table></figure><p>当指定的内存限制大小达到时，需要选择不同的行为，也就是<strong>策略</strong>。 </p><h5 id="回收策略"><a href="#回收策略" class="headerlink" title="回收策略"></a>回收策略</h5><p>当maxmemory限制达到的时候Redis会使用的行为由 Redis的maxmemory-policy配置指令来进行配置。</p><p>以下的策略是可用的:</p><ul><li><strong>noeviction</strong>(默认):返回错误当内存限制达到并且客户端尝试执行会让更多内存被使用的命令（大部分的写入指令，但DEL和几个例外）</li><li><strong>allkeys-lru</strong>: 尝试回收最少使用的键（LRU），使得新添加的数据有空间存放。</li><li><strong>volatile-lru</strong>: 尝试回收最少使用的键（LRU），但仅限于在过期集合的键,使得新添加的数据有空间存放。</li><li><strong>allkeys-random</strong>: 回收随机的键使得新添加的数据有空间存放。</li><li><strong>volatile-random</strong>: 回收随机的键使得新添加的数据有空间存放，但仅限于在过期集合的键。</li><li><strong>volatile-ttl</strong>: 回收在过期集合的键，并且优先回收存活时间（TTL）较短的键,使得新添加的数据有空间存放。</li></ul><p>如果没有键满足回收的前提条件的话，策略<strong>volatile-lru</strong>, <strong>volatile-random</strong>以及<strong>volatile-ttl</strong>就和noeviction 差不多了。</p><p>一般的经验规则:</p><ul><li>使用<strong>allkeys-lru</strong>策略：当你希望你的请求符合一个幂定律分布，也就是说，你希望部分的子集元素将比其它其它元素被访问的更多。如果你不确定选择什么，这是个很好的选择。.</li><li>使用<strong>allkeys-random</strong>：如果你是循环访问，所有的键被连续的扫描，或者你希望请求分布正常（所有元素被访问的概率都差不多）。</li><li>使用<strong>volatile-ttl</strong>：如果你想要通过创建缓存对象时设置TTL值，来决定哪些对象应该被过期。</li></ul><p><strong>allkeys-lru</strong> 和 <strong>volatile-random</strong>策略对于当你想要单一的实例实现缓存及持久化一些键时很有用。不过一般运行两个实例是解决这个问题的更好方法。</p><p>为了键设置过期时间也是需要消耗内存的，所以使用<strong>allkeys-lru</strong>这种策略更加高效，因为没有必要为键取设置过期时间当内存有压力时。</p><h5 id="回收进程如何工作"><a href="#回收进程如何工作" class="headerlink" title="回收进程如何工作"></a><strong>回收进程如何工作</strong></h5><p>理解回收进程如何工作是非常重要的:</p><ul><li>一个客户端运行了新的命令，添加了新的数据。</li><li>Redi检查内存使用情况，如果大于maxmemory的限制, 则根据设定好的策略进行回收。</li><li>一个新的命令被执行，等等。</li><li>所以我们不断地穿越内存限制的边界，通过不断达到边界然后不断地回收回到边界以下。</li></ul><p>如果一个命令的结果导致大量内存被使用（例如很大的集合的交集保存到一个新的键），不用多久内存限制就会被这个内存使用量超越。</p><h5 id="近似LRU算法"><a href="#近似LRU算法" class="headerlink" title="近似LRU算法"></a><strong>近似LRU算法</strong></h5><p>Redis的LRU算法并非完整的实现。这意味着Redis并没办法选择最佳候选来进行回收，也就是最久未被访问的键。相反它会尝试运行一个近似LRU的算法，通过对少量keys进行取样，然后回收其中一个最好的key（被访问时间较早的）。</p><p>不过从Redis 3.0算法已经改进为回收键的候选池子。这改善了算法的性能，使得更加近似真是的LRU算法的行为。</p><p>Redis LRU有个很重要的点，你通过调整每次回收时检查的采样数量，以实现<strong>调整</strong>算法的精度。这个参数可以通过以下的配置指令调整:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">maxmemory-samples 5</span><br></pre></td></tr></table></figure><p><img src="/2020/08/03/Redis%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/image-20200411112228687.png" alt="image-20200411112228687"></p><h4 id="Redis持久化-重点"><a href="#Redis持久化-重点" class="headerlink" title="Redis持久化 (重点!!!)"></a>Redis持久化 (重点!!!)</h4><img src="/2020/08/03/Redis%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/../../../只要学不死 就往死里学/note/Redis/image/Redis/image-20200625213446538.png" alt="image-20200625213446538" style="zoom: 80%;"><h5 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h5><img src="/2020/08/03/Redis%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/../../../只要学不死 就往死里学/note/Redis/image/Redis/image-20200411125836850.png" alt="image-20200411125836850" style="zoom:67%;"><h6 id="时点混乱"><a href="#时点混乱" class="headerlink" title="时点混乱"></a>时点混乱</h6><p>持久化的开始后, 还要记录现在修改的值</p><p><img src="/2020/08/03/Redis%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/image-20200411122241429.png" alt="image-20200411122241429"></p><h6 id="管道："><a href="#管道：" class="headerlink" title="管道："></a>管道：</h6><p>Linux管道概念: 前边命令的输出作为后边命令的输入<br><img src="/2020/08/03/Redis%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/image-20200625214137737.png" alt="image-20200625214137737"></p><p>1，衔接，前一个命令的输出作为后一个命令的输入</p><p>2，管道会触发创建【子进程】<br>echo $$ |  more<br>echo $BASHPID | more</p><p>$$ 高于 | </p><ul><li>使用linux的时候：存在父子进程</li><li>父进程的数据，子进程可不可以看得到？</li><li>常规思想，进程是数据隔离的！</li><li>进阶思想，父进程其实可以让子进程看到数据！</li><li>linux中<strong>export的环境变量，子进程的修改不会破坏父进程, 父进程的修改也不会破坏子进程</strong><img src="/2020/08/03/Redis%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/image-20200411123147116.png" alt="image-20200411123147116"></li></ul><h6 id="写时复制"><a href="#写时复制" class="headerlink" title="写时复制"></a>写时复制</h6><ul><li><p>copy on write：<strong>内核机制</strong></p></li><li><p>fork(): <strong>系统调用</strong></p></li><li><p>写时复制, 创建子进程并不发生复制</p></li><li><p>创建进程变快了</p></li><li><p>根据经验，不可能父子进程把所有数据都改一遍, 玩的是指针<img src="/2020/08/03/Redis%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/image-20200411122355696.png" alt="image-20200411122355696"></p><p>要拷贝, 就是把真实数据的地址拷贝一份到需要持久化的进程中<img src="/2020/08/03/Redis%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/../../../只要学不死 就往死里学/note/Redis/image/Redis/1187916-20200304064424042-1801115546.png" alt="img" style="zoom: 50%;"></p></li></ul><p>其实持久化进程这个时候只是指向了数据的地址, 内存消耗并不多. 如果这时候, 原来的数据修改了, 怎么办呢?</p><p>redis会开辟一块新的空间, 让写数据的地址指向新的空间<br>这样就不会影响持久化进程需要持久化的数据了<img src="/2020/08/03/Redis%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/../../../只要学不死 就往死里学/note/Redis/image/Redis/1187916-20200304064625052-1383412525.png" alt="img" style="zoom:50%;"></p><h6 id="创建子进程-fork-实现快照"><a href="#创建子进程-fork-实现快照" class="headerlink" title="创建子进程 fork(), 实现快照"></a>创建子进程 fork(), 实现快照</h6><p>8点创建子进程, 父子进程对数据的修改, 对方看不到</p><img src="/2020/08/03/Redis%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/../../../只要学不死 就往死里学/note/Redis/image/Redis/image-20200411124332883.png" alt="image-20200411124332883" style="zoom:80%;"><h6 id="RDB实现方式"><a href="#RDB实现方式" class="headerlink" title="RDB实现方式"></a>RDB实现方式</h6><ul><li><p>时点</p></li><li><p>save</p></li><li><p>bgsave</p></li><li><p>配置文件给出bgsave规则</p></li></ul>  <img src="/2020/08/03/Redis%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/../../../只要学不死 就往死里学/note/Redis/image/Redis/image-20200411125836850.png" alt="image-20200411125836850" style="zoom:67%;"><h6 id="RDB优缺点"><a href="#RDB优缺点" class="headerlink" title="RDB优缺点"></a>RDB优缺点</h6><h6 id><a href="#" class="headerlink" title></a><img src="/2020/08/03/Redis%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/image-20200411131300663.png" alt="image-20200411131300663"></h6><h5 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h5><ul><li>丢失数据少</li><li>4.0以后AOF是一个混合体, 重写的AOF文件的时候, Redis先用RDB写到AOF文件, 加快了重写的过程<br>形成混合体文件 （默认开启）<br><img src="/2020/08/03/Redis%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/image-20200626082350192.png" alt="image-20200626082350192"></li></ul><p><img src="/2020/08/03/Redis%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/image-20200411132308192.png" alt="image-20200411132308192"></p><p><img src="/2020/08/03/Redis%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/image-20200411133318275.png" alt="image-20200411133318275"></p><p>AOF日志<br><img src="/2020/08/03/Redis%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/image-20200411144422698.png" alt="image-20200411144422698"></p><p>bgsave, 执行rdb</p><p><img src="/2020/08/03/Redis%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/image-20200411145209929.png" alt="image-20200411145209929"></p><p>执行bgsave 生成 dump.rdb<br><img src="/2020/08/03/Redis%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/image-20200411145222593.png" alt="image-20200411145222593"></p><p>无论是混合模式还是单aof, 执行bgrewriteaof, 都只保留最后的数据, 没有历史记录</p><p>*2 有两个元素<br>$6 描述元素的字符数<br><img src="/2020/08/03/Redis%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/image-20200411175010233.png" alt="image-20200411175010233"></p><p>开启混合模式 aof-use-rdb-preamble yes<br>执行BGREWRITEAOF<br>vi appendonly.aof, 出现RDB的内容</p><p><img src="/2020/08/03/Redis%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/image-20200411175038779.png" alt="image-20200411175038779"></p><p>误操作后, 只要不执行BGREWRITEAOF, 可以在日志中删除误操作记录<br>执行BGREWRITEAOF后, 日志就会同步成当前清空的状态</p><img src="/2020/08/03/Redis%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/../../../只要学不死 就往死里学/note/Redis/image/Redis/image-20200626090920441.png" alt="image-20200626090920441" style="zoom: 80%;"><h6 id="开启-修改配置文件"><a href="#开启-修改配置文件" class="headerlink" title="开启, 修改配置文件"></a>开启, 修改配置文件</h6><p>appendonly</p><p><img src="/2020/08/03/Redis%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/image-20200411175528382.png" alt="image-20200411175528382"></p><h4 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h4><p><img src="/2020/08/03/Redis%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/image-20200411181020297.png" alt="image-20200411181020297"></p><p><img src="/2020/08/03/Redis%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/image-20200411181101641.png" alt="image-20200411181101641"></p><p><img src="/2020/08/03/Redis%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/image-20200411181123008.png" alt="image-20200411181123008"></p><p><img src="/2020/08/03/Redis%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/image-20200411184710813.png" alt="image-20200411184710813"></p><p><img src="/2020/08/03/Redis%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/image-20200411184729915.png" alt="image-20200411184729915"></p><p><img src="/2020/08/03/Redis%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/image-20200411200355740.png" alt="image-20200411200355740"></p><img src="/2020/08/03/Redis%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/../../../只要学不死 就往死里学/note/Redis/image/Redis/image-20200411201140595.png" alt="image-20200411201140595" style="zoom: 80%;"><p><img src="/2020/08/03/Redis%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/image-20200411201313150.png" alt="image-20200411201313150"></p><p><img src="/2020/08/03/Redis%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/image-20200411203600461.png" alt="image-20200411203600461"></p><p><img src="/2020/08/03/Redis%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/image-20200411203621238.png" alt="image-20200411203621238"></p><p><img src="/2020/08/03/Redis%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/image-20200411204905204.png" alt="image-20200411204905204"></p><p><img src="/2020/08/03/Redis%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/image-20200411205051120.png" alt="image-20200411205051120"></p><h4 id="击穿"><a href="#击穿" class="headerlink" title="击穿"></a>击穿</h4><p><img src="/2020/08/03/Redis%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/image-20200411214604205.png" alt="image-20200411214604205"></p><h4 id="穿透"><a href="#穿透" class="headerlink" title="穿透"></a><strong>穿透</strong></h4><p><img src="/2020/08/03/Redis%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/image-20200411214620761.png" alt="image-20200411214620761"></p><h4 id="雪崩"><a href="#雪崩" class="headerlink" title="雪崩"></a><strong>雪崩</strong></h4><p><img src="/2020/08/03/Redis%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/image-20200411214646499.png" alt="image-20200411214646499"></p><h4 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a><strong>分布式锁</strong></h4><p>基于数据库实现分布式锁；<br>基于缓存（Redis等）实现分布式锁；<br>基于Zookeeper实现分布式锁；</p><p><strong>Memcached</strong>：利用 Memcached 的 <code>add</code> 命令。此命令是原子性操作，只有在 <code>key</code> 不存在的情况下，才能 <code>add</code> 成功，也就意味着线程得到了锁。</p><p><strong>Redis</strong>：和 Memcached 的方式类似，利用 Redis 的 <code>setnx</code> 命令。此命令同样是原子性操作，只有在 <code>key</code> 不存在的情况下，才能 <code>set</code> 成功。</p><p><strong>Zookeeper</strong>：利用 Zookeeper 的顺序临时节点，来实现分布式锁和等待队列。Zookeeper 设计的初衷，就是为了实现分布式锁服务的。</p><p><strong>Chubby</strong>：Google 公司实现的粗粒度分布式锁服务，底层利用了 Paxos 一致性算法。</p><p><img src="/2020/08/03/Redis%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/image-20200411215324099.png" alt="image-20200411215324099"></p><h3 id="Spring-data-Redis"><a href="#Spring-data-Redis" class="headerlink" title="Spring data Redis"></a>Spring data Redis</h3><p>pom.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-json<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>application.properties</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring.redis.host&#x3D;192.168.150.99</span><br><span class="line">spring.redis.port&#x3D;6379</span><br></pre></td></tr></table></figure><p>DemoApplication</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ConfigurableApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">ConfigurableApplicationContext ctx = SpringApplication.run(DemoApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">TestRedis redis = ctx.getBean(TestRedis<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">redis.testRedis();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TestRedis</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Qualifier;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.Message;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.MessageListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.RedisConnection;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.hash.Jackson2HashMapper;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestRedis</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RedisTemplate  redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier</span>(<span class="string">"ooxx"</span>)</span><br><span class="line">    StringRedisTemplate  stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    ObjectMapper  objectMapper;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testRedis</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        stringRedisTemplate.opsForValue().set("hello01","china");</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        System.out.println(stringRedisTemplate.opsForValue().get("hello01"));</span></span><br><span class="line"></span><br><span class="line">        RedisConnection conn = redisTemplate.getConnectionFactory().getConnection();</span><br><span class="line"></span><br><span class="line">        conn.set(<span class="string">"hello02"</span>.getBytes(),<span class="string">"mashibing"</span>.getBytes());</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(conn.get(<span class="string">"hello02"</span>.getBytes())));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//        HashOperations&lt;String, Object, Object&gt; hash = stringRedisTemplate.opsForHash();</span></span><br><span class="line"><span class="comment">//        hash.put("sean","name","zhouzhilei");</span></span><br><span class="line"><span class="comment">//        hash.put("sean","age","22");</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        System.out.println(hash.entries("sean"));</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Person p = <span class="keyword">new</span> Person();</span><br><span class="line">        p.setName(<span class="string">"zhangsan"</span>);</span><br><span class="line">        p.setAge(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        stringRedisTemplate.setHashValueSerializer(new Jackson2JsonRedisSerializer&lt;Object&gt;(Object.class));</span></span><br><span class="line"></span><br><span class="line">        Jackson2HashMapper jm = <span class="keyword">new</span> Jackson2HashMapper(objectMapper, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        stringRedisTemplate.opsForHash().putAll(<span class="string">"sean01"</span>,jm.toHash(p));</span><br><span class="line"></span><br><span class="line">        Map map = stringRedisTemplate.opsForHash().entries(<span class="string">"sean01"</span>);</span><br><span class="line"></span><br><span class="line">        Person per = objectMapper.convertValue(map, Person<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        System.out.println(per.getName());</span><br><span class="line"></span><br><span class="line">        stringRedisTemplate.convertAndSend(<span class="string">"ooxx"</span>,<span class="string">"hello"</span>);</span><br><span class="line"></span><br><span class="line">        RedisConnection cc = stringRedisTemplate.getConnectionFactory().getConnection();</span><br><span class="line">        cc.subscribe(<span class="keyword">new</span> MessageListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Message message, <span class="keyword">byte</span>[] pattern)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">byte</span>[] body = message.getBody();</span><br><span class="line">                System.out.println(<span class="keyword">new</span> String(body));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"ooxx"</span>.getBytes());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            stringRedisTemplate.convertAndSend(<span class="string">"ooxx"</span>,<span class="string">"hello  from wo zi ji "</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MyTemplate</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTemplate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StringRedisTemplate <span class="title">ooxx</span><span class="params">(RedisConnectionFactory fc)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        StringRedisTemplate tp = <span class="keyword">new</span> StringRedisTemplate(fc);</span><br><span class="line"></span><br><span class="line">        tp.setHashValueSerializer(<span class="keyword">new</span> Jackson2JsonRedisSerializer&lt;Object&gt;(Object<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">        <span class="keyword">return</span>  tp ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Person</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age ;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(Integer age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Redis的学习网站："><a href="#Redis的学习网站：" class="headerlink" title="Redis的学习网站："></a>Redis的学习网站：</h3><ol><li>redis.cn</li><li>redis.io</li><li>db-engines.com</li></ol><h3 id="API代码的学习："><a href="#API代码的学习：" class="headerlink" title="API代码的学习："></a>API代码的学习：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.  redis.io 的client 中有JAVA语言的客户端：jedis、lettuce等可以分别访问他们的github学习</span><br><span class="line">2.  另外是基于spring的使用，主动通过spring.io官网学习spring.data.redis</span><br><span class="line">3.  spring.io中:   https:&#x2F;&#x2F;spring.io&#x2F;projects&#x2F;spring-data-redis</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL主从复制原理及配置</title>
      <link href="/2020/08/03/MySQL%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86%E5%8F%8A%E9%85%8D%E7%BD%AE/"/>
      <url>/2020/08/03/MySQL%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86%E5%8F%8A%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL主从复制原理"><a href="#MySQL主从复制原理" class="headerlink" title="MySQL主从复制原理"></a>MySQL主从复制原理</h1><h3 id="0、为什么需要主从复制？"><a href="#0、为什么需要主从复制？" class="headerlink" title="0、为什么需要主从复制？"></a>0、为什么需要主从复制？</h3><p>1、在业务复杂的系统中，有这么一个情景，有一句sql语句需要锁表，导致暂时不能使用读的服务，那么就很影响运行中的业务，使用主从复制，让主库负责写，从库负责读，这样，即使主库出现了锁表的情景，通过读从库也可以保证业务的正常运作。</p><p>2、做数据的热备</p><p>3、架构的扩展。业务量越来越大，I/O访问频率过高，单机无法满足，此时做多库的存储，降低磁盘I/O访问的频率，提高单个机器的I/O性能。</p><h3 id="1、什么是MySQL的主从复制？"><a href="#1、什么是MySQL的主从复制？" class="headerlink" title="1、什么是MySQL的主从复制？"></a>1、什么是MySQL的主从复制？</h3><p>​        MySQL 主从复制是指数据可以从一个MySQL数据库服务器主节点复制到一个或多个从节点。MySQL 默认采用异步复制方式，这样从节点不用一直访问主服务器来更新自己的数据，数据的更新可以在远程连接上进行，从节点可以复制主数据库中的所有数据库或者特定的数据库，或者特定的表。</p><h3 id="2、MySQL复制原理"><a href="#2、MySQL复制原理" class="headerlink" title="2、MySQL复制原理"></a>2、MySQL复制原理</h3><h5 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h5><p>​        （1）master服务器将数据的改变记录二进制binlog日志，当master上的数据发生改变时，则将其改变写入二进制日志中；        </p><p>​        （2）slave服务器会在一定时间间隔内对master二进制日志进行探测其是否发生改变，如果发生改变，则开始一个I/OThread请求master二进制事件</p><p>​        （3）同时主节点为每个I/O线程启动一个dump线程，用于向其发送二进制事件，并保存至从节点本地的中继日志中，从节点将启动SQL线程从中继日志中读取二进制日志，在本地重放，使得其数据和主节点的保持一致，最后I/OThread和SQLThread将进入睡眠状态，等待下一次被唤醒。</p><h5 id="也就是说："><a href="#也就是说：" class="headerlink" title="也就是说："></a>也就是说：</h5><ul><li>从库会生成两个线程,一个I/O线程,一个SQL线程;</li><li>I/O线程会去请求主库的binlog,并将得到的binlog写到本地的relay-log(中继日志)文件中;</li><li>主库会生成一个log dump线程,用来给从库I/O线程传binlog;</li><li>SQL线程,会读取relay log文件中的日志,并解析成sql语句逐一执行;</li></ul><h5 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h5><p>1–master将操作语句记录到binlog日志中，然后授予slave远程连接的权限（master一定要开启binlog二进制日志功能；通常为了数据安全考虑，slave也开启binlog功能）。<br>2–slave开启两个线程：IO线程和SQL线程。其中：IO线程负责读取master的binlog内容到中继日志relay log里；SQL线程负责从relay log日志里读出binlog内容，并更新到slave的数据库里，这样就能保证slave数据和master数据保持一致了。<br>3–Mysql复制至少需要两个Mysql的服务，当然Mysql服务可以分布在不同的服务器上，也可以在一台服务器上启动多个服务。<br>4–Mysql复制最好确保master和slave服务器上的Mysql版本相同（如果不能满足版本一致，那么要保证master主节点的版本低于slave从节点的版本）<br>5–master和slave两节点间时间需同步</p><p><img src="/2020/08/03/MySQL%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86%E5%8F%8A%E9%85%8D%E7%BD%AE/%E4%B8%BB%E4%BB%8E%E5%8E%9F%E7%90%86.png" alt></p><h5 id="具体步骤："><a href="#具体步骤：" class="headerlink" title="具体步骤："></a>具体步骤：</h5><p>1、从库通过手工执行change  master to 语句连接主库，提供了连接的用户一切条件（user 、password、port、ip），并且让从库知道，二进制日志的起点位置（file名 position 号）；    start  slave</p><p>2、从库的IO线程和主库的dump线程建立连接。</p><p>3、从库根据change  master  to 语句提供的file名和position号，IO线程向主库发起binlog的请求。</p><p>4、主库dump线程根据从库的请求，将本地binlog以events的方式发给从库IO线程。</p><p>5、从库IO线程接收binlog  events，并存放到本地relay-log中，传送过来的信息，会记录到master.info中</p><p>6、从库SQL线程应用relay-log，并且把应用过的记录到relay-log.info中，默认情况下，已经应用过的relay 会自动被清理purge</p><h3 id="3、MySQL主从形式"><a href="#3、MySQL主从形式" class="headerlink" title="3、MySQL主从形式"></a>3、MySQL主从形式</h3><h5 id="（一）一主一从"><a href="#（一）一主一从" class="headerlink" title="（一）一主一从"></a>（一）一主一从</h5><p><img src="/2020/08/03/MySQL%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86%E5%8F%8A%E9%85%8D%E7%BD%AE/1570714549624.png" alt="1570714549624"></p><h5 id="（二）主主复制"><a href="#（二）主主复制" class="headerlink" title="（二）主主复制"></a>（二）主主复制</h5><p><img src="/2020/08/03/MySQL%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86%E5%8F%8A%E9%85%8D%E7%BD%AE/1570714565647.png" alt="1570714565647"></p><h5 id="（三）一主多从"><a href="#（三）一主多从" class="headerlink" title="（三）一主多从"></a>（三）一主多从</h5><p><img src="/2020/08/03/MySQL%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86%E5%8F%8A%E9%85%8D%E7%BD%AE/1570714576819.png" alt="1570714576819"></p><h5 id="（四）多主一从"><a href="#（四）多主一从" class="headerlink" title="（四）多主一从"></a>（四）多主一从</h5><p><img src="/2020/08/03/MySQL%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86%E5%8F%8A%E9%85%8D%E7%BD%AE/1570714615915.png" alt="1570714615915"></p><h5 id="（五）联级复制"><a href="#（五）联级复制" class="headerlink" title="（五）联级复制"></a>（五）联级复制</h5><p><img src="/2020/08/03/MySQL%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86%E5%8F%8A%E9%85%8D%E7%BD%AE/1570714660961-1594043182444.png" alt="1570714660961"></p><h3 id="4、MySQL主从同步延时分析"><a href="#4、MySQL主从同步延时分析" class="headerlink" title="4、MySQL主从同步延时分析"></a>4、MySQL主从同步延时分析</h3><p>​        mysql的主从复制都是单线程的操作，主库对所有DDL和DML产生的日志写进binlog，由于binlog是顺序写，所以效率很高，slave的sql thread线程将主库的DDL和DML操作事件在slave中重放。DML和DDL的IO操作是随机的，不是顺序，所以成本要高很多，另一方面，由于sql thread也是单线程的，当主库的并发较高时，产生的DML数量超过slave的SQL thread所能处理的速度，或者当slave中有大型query语句产生了锁等待，那么延时就产生了。</p><p>​        解决方案：</p><p>​        1.业务的持久化层的实现采用分库架构，mysql服务可平行扩展，分散压力。</p><p>​        2.单个库读写分离，一主多从，主写从读，分散压力。这样从库压力比主库高，保护主库。</p><p>​        3.服务的基础架构在业务和mysql之间加入memcache或者redis的cache层。降低mysql的读压力。</p><p>​        4.不同业务的mysql物理上放在不同机器，分散压力。</p><p>​        5.使用比主库更好的硬件设备作为slave，mysql压力小，延迟自然会变小。</p><p>​        6.使用更加强劲的硬件设备</p><h1 id="MySQL主从复制安装配置"><a href="#MySQL主从复制安装配置" class="headerlink" title="MySQL主从复制安装配置"></a>MySQL主从复制安装配置</h1><h3 id="1、基础设置准备"><a href="#1、基础设置准备" class="headerlink" title="1、基础设置准备"></a>1、基础设置准备</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">操作系统：</span></span><br><span class="line">centos6.5</span><br><span class="line"><span class="meta">#</span><span class="bash">mysql版本：</span></span><br><span class="line">5.7</span><br><span class="line"><span class="meta">#</span><span class="bash">两台虚拟机：</span></span><br><span class="line">node1:192.168.85.111（主）</span><br><span class="line">node2:192.168.85.112（从）</span><br></pre></td></tr></table></figure><h3 id="2、安装MySQL数据库"><a href="#2、安装MySQL数据库" class="headerlink" title="2、安装MySQL数据库"></a>2、安装MySQL数据库</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">详细安装和卸载的步骤参考对应的文档</span></span><br></pre></td></tr></table></figure><h3 id="3、在两台数据库中分别创建数据库"><a href="#3、在两台数据库中分别创建数据库" class="headerlink" title="3、在两台数据库中分别创建数据库"></a>3、在两台数据库中分别创建数据库</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--注意两台必须全部执行</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> msb;</span><br></pre></td></tr></table></figure><h3 id="4、在主（node1）服务器进行如下配置："><a href="#4、在主（node1）服务器进行如下配置：" class="headerlink" title="4、在主（node1）服务器进行如下配置："></a>4、在主（node1）服务器进行如下配置：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">修改配置文件，执行以下命令打开mysql配置文件</span></span><br><span class="line">vi /etc/my.cnf</span><br><span class="line"><span class="meta">#</span><span class="bash">在mysqld模块中添加如下配置信息</span></span><br><span class="line">log-bin=master-bin #二进制文件名称</span><br><span class="line">binlog-format=ROW  #二进制日志格式，有row、statement、mixed三种格式，row指的是把改变的内容复制过去，而不是把命令在从服务器上执行一遍，statement指的是在主服务器上执行的SQL语句，在从服务器上执行同样的语句。MySQL默认采用基于语句的复制，效率比较高。mixed指的是默认采用基于语句的复制，一旦发现基于语句的无法精确的复制时，就会采用基于行的复制。</span><br><span class="line">server-id=1   #要求各个服务器的id必须不一样</span><br><span class="line">binlog-do-db=msb   #同步的数据库名称</span><br></pre></td></tr></table></figure><h3 id="5、配置从服务器登录主服务器的账号授权"><a href="#5、配置从服务器登录主服务器的账号授权" class="headerlink" title="5、配置从服务器登录主服务器的账号授权"></a>5、配置从服务器登录主服务器的账号授权</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--授权操作</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> validate_password_policy=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> validate_password_length=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">replication</span> <span class="keyword">slave</span> <span class="keyword">on</span> *.* <span class="keyword">to</span> <span class="string">'root'</span>@<span class="string">'%'</span> <span class="keyword">identified</span> <span class="keyword">by</span> <span class="string">'123456'</span>;</span><br><span class="line"><span class="comment">--刷新权限</span></span><br><span class="line"><span class="keyword">flush</span> <span class="keyword">privileges</span>;</span><br></pre></td></tr></table></figure><h3 id="6、从服务器的配置"><a href="#6、从服务器的配置" class="headerlink" title="6、从服务器的配置"></a>6、从服务器的配置</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">修改配置文件，执行以下命令打开mysql配置文件</span></span><br><span class="line">vi /etc/my.cnf</span><br><span class="line"><span class="meta">#</span><span class="bash">在mysqld模块中添加如下配置信息</span></span><br><span class="line">log-bin=master-bin#二进制文件的名称</span><br><span class="line">binlog-format=ROW#二进制文件的格式</span><br><span class="line">server-id=2#服务器的id</span><br></pre></td></tr></table></figure><h3 id="7、重启主服务器的mysqld服务"><a href="#7、重启主服务器的mysqld服务" class="headerlink" title="7、重启主服务器的mysqld服务"></a>7、重启主服务器的mysqld服务</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">重启mysql服务</span></span><br><span class="line">service mysqld restart</span><br><span class="line"><span class="meta">#</span><span class="bash">登录mysql数据库</span></span><br><span class="line">mysql -uroot -p</span><br><span class="line"><span class="meta">#</span><span class="bash">查看master的状态</span></span><br><span class="line">show master status；</span><br></pre></td></tr></table></figure><p><img src="/2020/08/03/MySQL%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86%E5%8F%8A%E9%85%8D%E7%BD%AE/1570703264912.png" alt="1570703264912"></p><h3 id="8、重启从服务器并进行相关配置"><a href="#8、重启从服务器并进行相关配置" class="headerlink" title="8、重启从服务器并进行相关配置"></a>8、重启从服务器并进行相关配置</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">重启mysql服务</span></span><br><span class="line">service mysqld restart</span><br><span class="line"><span class="meta">#</span><span class="bash">登录mysql</span></span><br><span class="line">mysql -uroot -p</span><br><span class="line"><span class="meta">#</span><span class="bash">连接主服务器</span></span><br><span class="line">change master to master_host='192.168.85.11',master_user='root',master_password='123456',master_port=3306,master_log_file='master-bin.000001',master_log_pos=154;</span><br><span class="line"><span class="meta">#</span><span class="bash">启动slave</span></span><br><span class="line">start slave</span><br><span class="line"><span class="meta">#</span><span class="bash">查看slave的状态</span></span><br><span class="line">show slave status\G(注意没有分号)</span><br></pre></td></tr></table></figure><h3 id="9、此时可以在主服务器进行相关的数据添加删除工作，在从服务器看相关的状态"><a href="#9、此时可以在主服务器进行相关的数据添加删除工作，在从服务器看相关的状态" class="headerlink" title="9、此时可以在主服务器进行相关的数据添加删除工作，在从服务器看相关的状态"></a>9、此时可以在主服务器进行相关的数据添加删除工作，在从服务器看相关的状态</h3>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL执行计划详解</title>
      <link href="/2020/08/03/MySQL%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%E8%AF%A6%E8%A7%A3/"/>
      <url>/2020/08/03/MySQL%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL执行计划详解"><a href="#MySQL执行计划详解" class="headerlink" title="MySQL执行计划详解"></a>MySQL执行计划详解</h1><p>​       在企业的应用场景中，为了知道优化SQL语句的执行，需要查看SQL语句的具体执行过程，以加快SQL语句的执行效率。</p><p>​       可以使用explain+SQL语句来模拟优化器执行SQL查询语句，从而知道mysql是如何处理sql语句的。</p><p>​       官网地址： <a href="https://dev.mysql.com/doc/refman/5.5/en/explain-output.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.5/en/explain-output.html</a> </p><p><strong>执行计划中的信息</strong></p><table><thead><tr><th align="center">Column</th><th align="center">Meaning</th></tr></thead><tbody><tr><td align="center">id</td><td align="center">查询中执行select子句或者操作表的顺序</td></tr><tr><td align="center">select_type</td><td align="center">是普通查询还是联合查询还是子查询</td></tr><tr><td align="center">table</td><td align="center">访问的表名或者别名，可能是临时表或者union合并结果集</td></tr><tr><td align="center">type</td><td align="center">数据扫描形式</td></tr><tr><td align="center">possible_keys</td><td align="center">显示可能应用在这张表中的索引，一个或多个</td></tr><tr><td align="center">key</td><td align="center">实际使用的索引，如果为null，则没有使用索引</td></tr><tr><td align="center">key_len</td><td align="center">索引中使用的字节数，在不损失精度的情况下长度越短越好。</td></tr><tr><td align="center">ref</td><td align="center">显示索引的哪一列被使用了，如果可能的话，是一个常数</td></tr><tr><td align="center">rows</td><td align="center">大致估算出找出所需记录需要读取的行数</td></tr><tr><td align="center">filtered</td><td align="center">Percentage of rows filtered by table condition</td></tr><tr><td align="center">extra</td><td align="center">Additional information</td></tr></tbody></table><table><thead><tr><th align="center"><code>select_type</code> Value</th><th align="center">Meaning</th></tr></thead><tbody><tr><td align="center">SIMPLE</td><td align="center">Simple SELECT (not using UNION or subqueries)</td></tr><tr><td align="center">PRIMARY</td><td align="center">Outermost SELECT</td></tr><tr><td align="center">UNION</td><td align="center">Second or later SELECT statement in a UNION</td></tr><tr><td align="center">DEPENDENT UNION</td><td align="center">Second or later SELECT statement in a UNION, dependent on outer query</td></tr><tr><td align="center">UNION RESULT</td><td align="center">Result of a UNION.</td></tr><tr><td align="center">SUBQUERY</td><td align="center">First SELECT in subquery</td></tr><tr><td align="center">DEPENDENT SUBQUERY</td><td align="center">First SELECT in subquery, dependent on outer query</td></tr><tr><td align="center">DERIVED</td><td align="center">Derived table</td></tr><tr><td align="center">UNCACHEABLE SUBQUERY</td><td align="center">A subquery for which the result cannot be cached and must be re-evaluated for each row of the outer query</td></tr><tr><td align="center">UNCACHEABLE UNION</td><td align="center">The second or later select in a UNION that belongs to an uncacheable subquery (see UNCACHEABLE SUBQUERY)</td></tr></tbody></table><p><strong>id</strong></p><p>select查询的序列号，包含一组数字，表示查询中执行select子句或者操作表的顺序</p><p>id号分为三种情况：</p><p>​        1、如果id相同，那么执行顺序从上到下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp e <span class="keyword">join</span> dept d <span class="keyword">on</span> e.deptno = d.deptno <span class="keyword">join</span> salgrade sg <span class="keyword">on</span> e.sal <span class="keyword">between</span> sg.losal <span class="keyword">and</span> sg.hisal;</span><br></pre></td></tr></table></figure><p>​        2、如果id不同，如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp e <span class="keyword">where</span> e.deptno <span class="keyword">in</span> (<span class="keyword">select</span> d.deptno <span class="keyword">from</span> dept d <span class="keyword">where</span> d.dname = <span class="string">'SALES'</span>);</span><br></pre></td></tr></table></figure><p>​        3、id相同和不同的，同时存在：相同的可以认为是一组，从上往下顺序执行，在所有组中，id值越大，优先级越高，越先执行</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp e <span class="keyword">join</span> dept d <span class="keyword">on</span> e.deptno = d.deptno <span class="keyword">join</span> salgrade sg <span class="keyword">on</span> e.sal <span class="keyword">between</span> sg.losal <span class="keyword">and</span> sg.hisal <span class="keyword">where</span> e.deptno <span class="keyword">in</span> (<span class="keyword">select</span> d.deptno <span class="keyword">from</span> dept d <span class="keyword">where</span> d.dname = <span class="string">'SALES'</span>);</span><br></pre></td></tr></table></figure><p><strong>select_type</strong></p><p>主要用来分辨查询的类型，是普通查询还是联合查询还是子查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--sample:简单的查询，不包含子查询和union</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp;</span><br><span class="line"></span><br><span class="line"><span class="comment">--primary:查询中若包含任何复杂的子查询，最外层查询则被标记为Primary</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> staname,ename supname <span class="keyword">from</span> (<span class="keyword">select</span> ename staname,mgr <span class="keyword">from</span> emp) t <span class="keyword">join</span> emp <span class="keyword">on</span> t.mgr=emp.empno ;</span><br><span class="line"></span><br><span class="line"><span class="comment">--union:若第二个select出现在union之后，则被标记为union</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> deptno = <span class="number">10</span> <span class="keyword">union</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> sal &gt;<span class="number">2000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--dependent union:跟union类似，此处的depentent表示union或union all联合而成的结果会受外部表影响</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp e <span class="keyword">where</span> e.empno  <span class="keyword">in</span> ( <span class="keyword">select</span> empno <span class="keyword">from</span> emp <span class="keyword">where</span> deptno = <span class="number">10</span> <span class="keyword">union</span> <span class="keyword">select</span> empno <span class="keyword">from</span> emp <span class="keyword">where</span> sal &gt;<span class="number">2000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">--union result:从union表获取结果的select</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> deptno = <span class="number">10</span> <span class="keyword">union</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> sal &gt;<span class="number">2000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--subquery:在select或者where列表中包含子查询</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> sal &gt; (<span class="keyword">select</span> <span class="keyword">avg</span>(sal) <span class="keyword">from</span> emp) ;</span><br><span class="line"></span><br><span class="line"><span class="comment">--dependent subquery:subquery的子查询要受到外部表查询的影响</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp e <span class="keyword">where</span> e.deptno <span class="keyword">in</span> (<span class="keyword">select</span> <span class="keyword">distinct</span> deptno <span class="keyword">from</span> dept);</span><br><span class="line"></span><br><span class="line"><span class="comment">--DERIVED: from子句中出现的子查询，也叫做派生类，</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> staname,ename supname <span class="keyword">from</span> (<span class="keyword">select</span> ename staname,mgr <span class="keyword">from</span> emp) t <span class="keyword">join</span> emp <span class="keyword">on</span> t.mgr=emp.empno ;</span><br><span class="line"></span><br><span class="line"><span class="comment">--UNCACHEABLE SUBQUERY：表示使用子查询的结果不能被缓存</span></span><br><span class="line"> <span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> empno = (<span class="keyword">select</span> empno <span class="keyword">from</span> emp <span class="keyword">where</span> deptno=@@sort_buffer_size);</span><br><span class="line"> </span><br><span class="line"><span class="comment">--uncacheable union:表示union的查询结果不能被缓存：sql语句未验证</span></span><br></pre></td></tr></table></figure><p><strong>table</strong></p><p>对应行正在访问哪一个表，表名或者别名，可能是临时表或者union合并结果集<br>        1、如果是具体的表名，则表明从实际的物理表中获取数据，当然也可以是表的别名</p><p>​        2、表名是derivedN的形式，表示使用了id为N的查询产生的衍生表</p><p>​        3、当有union result的时候，表名是union n1,n2等的形式，n1,n2表示参与union的id</p><p><strong>type</strong></p><p>type显示的是访问类型，访问类型表示我是以何种方式去访问我们的数据，最容易想的是全表扫描，直接暴力的遍历一张表去寻找需要的数据，效率非常低下，访问的类型有很多，效率从最好到最坏依次是：</p><p>system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL </p><p>一般情况下，得保证查询至少达到range级别，最好能达到ref</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--all:全表扫描，一般情况下出现这样的sql语句而且数据量比较大的话那么就需要进行优化。</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp;</span><br><span class="line"></span><br><span class="line"><span class="comment">--index：全索引扫描这个比all的效率要好，主要有两种情况，一种是当前的查询时覆盖索引，即我们需要的数据在索引中就可以索取，或者是使用了索引进行排序，这样就避免数据的重排序</span></span><br><span class="line"><span class="keyword">explain</span>  <span class="keyword">select</span> empno <span class="keyword">from</span> emp;</span><br><span class="line"></span><br><span class="line"><span class="comment">--range：表示利用索引查询的时候限制了范围，在指定范围内进行查询，这样避免了index的全索引扫描，适用的操作符： =, &lt;&gt;, &gt;, &gt;=, &lt;, &lt;=, IS NULL, BETWEEN, LIKE, or IN() </span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> empno <span class="keyword">between</span> <span class="number">7000</span> <span class="keyword">and</span> <span class="number">7500</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--index_subquery：利用索引来关联子查询，不再扫描全表</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> emp.job <span class="keyword">in</span> (<span class="keyword">select</span> job <span class="keyword">from</span> t_job);</span><br><span class="line"></span><br><span class="line"><span class="comment">--unique_subquery:该连接类型类似与index_subquery,使用的是唯一索引</span></span><br><span class="line"> <span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp e <span class="keyword">where</span> e.deptno <span class="keyword">in</span> (<span class="keyword">select</span> <span class="keyword">distinct</span> deptno <span class="keyword">from</span> dept);</span><br><span class="line"> </span><br><span class="line"><span class="comment">--index_merge：在查询过程中需要多个索引组合使用，没有模拟出来</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--ref_or_null：对于某个字段即需要关联条件，也需要null值的情况下，查询优化器会选择这种访问方式</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp e <span class="keyword">where</span>  e.mgr <span class="keyword">is</span> <span class="literal">null</span> <span class="keyword">or</span> e.mgr=<span class="number">7369</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--ref：使用了非唯一性索引进行数据的查找</span></span><br><span class="line"> <span class="keyword">create</span> <span class="keyword">index</span> idx_3 <span class="keyword">on</span> emp(deptno);</span><br><span class="line"> <span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp e,dept d <span class="keyword">where</span> e.deptno =d.deptno;</span><br><span class="line"></span><br><span class="line"><span class="comment">--eq_ref ：使用唯一性索引进行数据查找</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp,emp2 <span class="keyword">where</span> emp.empno = emp2.empno;</span><br><span class="line"></span><br><span class="line"><span class="comment">--const：这个表至多有一个匹配行，</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> empno = <span class="number">7369</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">--system：表只有一行记录（等于系统表），这是const类型的特例，平时不会出现</span></span><br></pre></td></tr></table></figure><p> <strong>possible_keys</strong> </p><p>​        显示可能应用在这张表中的索引，一个或多个，查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询实际使用</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp,dept <span class="keyword">where</span> emp.deptno = dept.deptno <span class="keyword">and</span> emp.deptno = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p><strong>key</strong></p><p>​        实际使用的索引，如果为null，则没有使用索引，查询中若使用了覆盖索引，则该索引和查询的select字段重叠。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp,dept <span class="keyword">where</span> emp.deptno = dept.deptno <span class="keyword">and</span> emp.deptno = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p><strong>key_len</strong></p><p>表示索引中使用的字节数，可以通过key_len计算查询中使用的索引长度，在不损失精度的情况下长度越短越好。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp,dept <span class="keyword">where</span> emp.deptno = dept.deptno <span class="keyword">and</span> emp.deptno = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p><strong>ref</strong></p><p>显示索引的哪一列被使用了，如果可能的话，是一个常数</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp,dept <span class="keyword">where</span> emp.deptno = dept.deptno <span class="keyword">and</span> emp.deptno = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p><strong>rows</strong></p><p>根据表的统计信息及索引使用情况，大致估算出找出所需记录需要读取的行数，此参数很重要，直接反应的sql找了多少数据，在完成目的的情况下越少越好</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp;</span><br></pre></td></tr></table></figure><p><strong>extra</strong></p><p>包含额外的信息。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--using filesort:说明mysql无法利用索引进行排序，只能利用排序算法进行排序，会消耗额外的位置</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">order</span> <span class="keyword">by</span> sal;</span><br><span class="line"></span><br><span class="line"><span class="comment">--using temporary:建立临时表来保存中间结果，查询完成之后把临时表删除</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> ename,<span class="keyword">count</span>(*) <span class="keyword">from</span> emp <span class="keyword">where</span> deptno = <span class="number">10</span> <span class="keyword">group</span> <span class="keyword">by</span> ename;</span><br><span class="line"></span><br><span class="line"><span class="comment">--using index:这个表示当前的查询时覆盖索引的，直接从索引中读取数据，而不用访问数据表。如果同时出现using where 表名索引被用来执行索引键值的查找，如果没有，表面索引被用来读取数据，而不是真的查找</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> deptno,<span class="keyword">count</span>(*) <span class="keyword">from</span> emp <span class="keyword">group</span> <span class="keyword">by</span> deptno <span class="keyword">limit</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--using where:使用where进行条件过滤</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> t_user <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--using join buffer:使用连接缓存，情况没有模拟出来</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--impossible where：where语句的结果总是false</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> empno = <span class="number">7469</span>;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL练习题</title>
      <link href="/2020/08/03/MySQL%E7%BB%83%E4%B9%A0%E9%A2%98/"/>
      <url>/2020/08/03/MySQL%E7%BB%83%E4%B9%A0%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="MySQL练习题"><a href="#MySQL练习题" class="headerlink" title="MySQL练习题"></a>MySQL练习题</h2><h3 id="1、表结构"><a href="#1、表结构" class="headerlink" title="1、表结构"></a>1、表结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">–1.学生表 </span><br><span class="line">Student(s_id,s_name,s_birth,s_sex) –学生编号,学生姓名, 出生年月,学生性别 </span><br><span class="line">–2.课程表 </span><br><span class="line">Course(c_id,c_name,t_id) – –课程编号, 课程名称, 教师编号 </span><br><span class="line">–3.教师表 </span><br><span class="line">Teacher(t_id,t_name) –教师编号,教师姓名 </span><br><span class="line">–4.成绩表 </span><br><span class="line">Score(s_id,c_id,s_score) –学生编号,课程编号,分数</span><br></pre></td></tr></table></figure><h3 id="2、测试数据"><a href="#2、测试数据" class="headerlink" title="2、测试数据"></a>2、测试数据</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--建表</span></span><br><span class="line"><span class="comment">--学生表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`Student`</span>(</span><br><span class="line">    <span class="string">`s_id`</span> <span class="built_in">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">    <span class="string">`s_name`</span> <span class="built_in">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span>,</span><br><span class="line">    <span class="string">`s_birth`</span> <span class="built_in">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span>,</span><br><span class="line">    <span class="string">`s_sex`</span> <span class="built_in">VARCHAR</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span>,</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span>(<span class="string">`s_id`</span>)</span><br><span class="line">);</span><br><span class="line"><span class="comment">--课程表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`Course`</span>(</span><br><span class="line">    <span class="string">`c_id`</span>  <span class="built_in">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">    <span class="string">`c_name`</span> <span class="built_in">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span>,</span><br><span class="line">    <span class="string">`t_id`</span> <span class="built_in">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span>(<span class="string">`c_id`</span>)</span><br><span class="line">);</span><br><span class="line"><span class="comment">--教师表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`Teacher`</span>(</span><br><span class="line">    <span class="string">`t_id`</span> <span class="built_in">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">    <span class="string">`t_name`</span> <span class="built_in">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span>,</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span>(<span class="string">`t_id`</span>)</span><br><span class="line">);</span><br><span class="line"><span class="comment">--成绩表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`Score`</span>(</span><br><span class="line">    <span class="string">`s_id`</span> <span class="built_in">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">    <span class="string">`c_id`</span>  <span class="built_in">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">    <span class="string">`s_score`</span> <span class="built_in">INT</span>(<span class="number">3</span>),</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span>(<span class="string">`s_id`</span>,<span class="string">`c_id`</span>)</span><br><span class="line">);</span><br><span class="line"><span class="comment">--插入学生表测试数据</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Student <span class="keyword">values</span>(<span class="string">'01'</span> , <span class="string">'赵雷'</span> , <span class="string">'1990-01-01'</span> , <span class="string">'男'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Student <span class="keyword">values</span>(<span class="string">'02'</span> , <span class="string">'钱电'</span> , <span class="string">'1990-12-21'</span> , <span class="string">'男'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Student <span class="keyword">values</span>(<span class="string">'03'</span> , <span class="string">'孙风'</span> , <span class="string">'1990-05-20'</span> , <span class="string">'男'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Student <span class="keyword">values</span>(<span class="string">'04'</span> , <span class="string">'李云'</span> , <span class="string">'1990-08-06'</span> , <span class="string">'男'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Student <span class="keyword">values</span>(<span class="string">'05'</span> , <span class="string">'周梅'</span> , <span class="string">'1991-12-01'</span> , <span class="string">'女'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Student <span class="keyword">values</span>(<span class="string">'06'</span> , <span class="string">'吴兰'</span> , <span class="string">'1992-03-01'</span> , <span class="string">'女'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Student <span class="keyword">values</span>(<span class="string">'07'</span> , <span class="string">'郑竹'</span> , <span class="string">'1989-07-01'</span> , <span class="string">'女'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Student <span class="keyword">values</span>(<span class="string">'08'</span> , <span class="string">'王菊'</span> , <span class="string">'1990-01-20'</span> , <span class="string">'女'</span>);</span><br><span class="line"><span class="comment">--课程表测试数据</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Course <span class="keyword">values</span>(<span class="string">'01'</span> , <span class="string">'语文'</span> , <span class="string">'02'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Course <span class="keyword">values</span>(<span class="string">'02'</span> , <span class="string">'数学'</span> , <span class="string">'01'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Course <span class="keyword">values</span>(<span class="string">'03'</span> , <span class="string">'英语'</span> , <span class="string">'03'</span>);</span><br><span class="line"><span class="comment">--教师表测试数据</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Teacher <span class="keyword">values</span>(<span class="string">'01'</span> , <span class="string">'张三'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Teacher <span class="keyword">values</span>(<span class="string">'02'</span> , <span class="string">'李四'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Teacher <span class="keyword">values</span>(<span class="string">'03'</span> , <span class="string">'王五'</span>);</span><br><span class="line"><span class="comment">--成绩表测试数据</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Score <span class="keyword">values</span>(<span class="string">'01'</span> , <span class="string">'01'</span> , <span class="number">80</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Score <span class="keyword">values</span>(<span class="string">'01'</span> , <span class="string">'02'</span> , <span class="number">90</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Score <span class="keyword">values</span>(<span class="string">'01'</span> , <span class="string">'03'</span> , <span class="number">99</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Score <span class="keyword">values</span>(<span class="string">'02'</span> , <span class="string">'01'</span> , <span class="number">70</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Score <span class="keyword">values</span>(<span class="string">'02'</span> , <span class="string">'02'</span> , <span class="number">60</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Score <span class="keyword">values</span>(<span class="string">'02'</span> , <span class="string">'03'</span> , <span class="number">80</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Score <span class="keyword">values</span>(<span class="string">'03'</span> , <span class="string">'01'</span> , <span class="number">80</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Score <span class="keyword">values</span>(<span class="string">'03'</span> , <span class="string">'02'</span> , <span class="number">80</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Score <span class="keyword">values</span>(<span class="string">'03'</span> , <span class="string">'03'</span> , <span class="number">80</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Score <span class="keyword">values</span>(<span class="string">'04'</span> , <span class="string">'01'</span> , <span class="number">50</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Score <span class="keyword">values</span>(<span class="string">'04'</span> , <span class="string">'02'</span> , <span class="number">30</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Score <span class="keyword">values</span>(<span class="string">'04'</span> , <span class="string">'03'</span> , <span class="number">20</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Score <span class="keyword">values</span>(<span class="string">'05'</span> , <span class="string">'01'</span> , <span class="number">76</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Score <span class="keyword">values</span>(<span class="string">'05'</span> , <span class="string">'02'</span> , <span class="number">87</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Score <span class="keyword">values</span>(<span class="string">'06'</span> , <span class="string">'01'</span> , <span class="number">31</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Score <span class="keyword">values</span>(<span class="string">'06'</span> , <span class="string">'03'</span> , <span class="number">34</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Score <span class="keyword">values</span>(<span class="string">'07'</span> , <span class="string">'02'</span> , <span class="number">89</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Score <span class="keyword">values</span>(<span class="string">'07'</span> , <span class="string">'03'</span> , <span class="number">98</span>);</span><br></pre></td></tr></table></figure><h3 id="3、测试题"><a href="#3、测试题" class="headerlink" title="3、测试题"></a>3、测试题</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 1、查询"01"课程比"02"课程成绩高的学生的信息及课程分数  </span></span><br><span class="line"><span class="keyword">select</span> a.* ,b.s_score <span class="keyword">as</span> <span class="number">01</span>_score,c.s_score <span class="keyword">as</span> <span class="number">02</span>_score <span class="keyword">from</span> </span><br><span class="line">    student a </span><br><span class="line">    <span class="keyword">join</span> score b <span class="keyword">on</span> a.s_id=b.s_id <span class="keyword">and</span> b.c_id=<span class="string">'01'</span></span><br><span class="line">    <span class="keyword">left</span> <span class="keyword">join</span> score c <span class="keyword">on</span> a.s_id=c.s_id <span class="keyword">and</span> c.c_id=<span class="string">'02'</span> <span class="keyword">or</span> c.c_id = <span class="literal">NULL</span> <span class="keyword">where</span> b.s_score&gt;c.s_score</span><br><span class="line"><span class="comment">-- 2、查询"01"课程比"02"课程成绩低的学生的信息及课程分数 </span></span><br><span class="line"><span class="keyword">select</span> a.* ,b.s_score <span class="keyword">as</span> <span class="number">01</span>_score,c.s_score <span class="keyword">as</span> <span class="number">02</span>_score <span class="keyword">from</span> </span><br><span class="line">    student a <span class="keyword">left</span> <span class="keyword">join</span> score b <span class="keyword">on</span> a.s_id=b.s_id <span class="keyword">and</span> b.c_id=<span class="string">'01'</span> <span class="keyword">or</span> b.c_id=<span class="literal">NULL</span> </span><br><span class="line">     <span class="keyword">join</span> score c <span class="keyword">on</span> a.s_id=c.s_id <span class="keyword">and</span> c.c_id=<span class="string">'02'</span> <span class="keyword">where</span> b.s_score&lt;c.s_score</span><br><span class="line"><span class="comment">-- 3、查询平均成绩大于等于60分的同学的学生编号和学生姓名和平均成绩</span></span><br><span class="line"><span class="keyword">select</span> b.s_id,b.s_name,<span class="keyword">ROUND</span>(<span class="keyword">AVG</span>(a.s_score),<span class="number">2</span>) <span class="keyword">as</span> avg_score <span class="keyword">from</span> </span><br><span class="line">    student b </span><br><span class="line">    <span class="keyword">join</span> score a <span class="keyword">on</span> b.s_id = a.s_id</span><br><span class="line">    <span class="keyword">GROUP</span> <span class="keyword">BY</span> b.s_id,b.s_name <span class="keyword">HAVING</span> <span class="keyword">ROUND</span>(<span class="keyword">AVG</span>(a.s_score),<span class="number">2</span>)&gt;=<span class="number">60</span>; </span><br><span class="line"><span class="comment">-- 4、查询平均成绩小于60分的同学的学生编号和学生姓名和平均成绩</span></span><br><span class="line">        <span class="comment">-- (包括有成绩的和无成绩的) </span></span><br><span class="line"><span class="keyword">select</span> b.s_id,b.s_name,<span class="keyword">ROUND</span>(<span class="keyword">AVG</span>(a.s_score),<span class="number">2</span>) <span class="keyword">as</span> avg_score <span class="keyword">from</span> </span><br><span class="line">    student b </span><br><span class="line">    <span class="keyword">left</span> <span class="keyword">join</span> score a <span class="keyword">on</span> b.s_id = a.s_id</span><br><span class="line">    <span class="keyword">GROUP</span> <span class="keyword">BY</span> b.s_id,b.s_name <span class="keyword">HAVING</span> <span class="keyword">ROUND</span>(<span class="keyword">AVG</span>(a.s_score),<span class="number">2</span>)&lt;<span class="number">60</span></span><br><span class="line">    <span class="keyword">union</span></span><br><span class="line"><span class="keyword">select</span> a.s_id,a.s_name,<span class="number">0</span> <span class="keyword">as</span> avg_score <span class="keyword">from</span> </span><br><span class="line">    student a </span><br><span class="line">    <span class="keyword">where</span> a.s_id <span class="keyword">not</span> <span class="keyword">in</span> (</span><br><span class="line">                <span class="keyword">select</span> <span class="keyword">distinct</span> s_id <span class="keyword">from</span> score);</span><br><span class="line"><span class="comment">-- 5、查询所有同学的学生编号、学生姓名、选课总数、所有课程的总成绩</span></span><br><span class="line"><span class="keyword">select</span> a.s_id,a.s_name,<span class="keyword">count</span>(b.c_id) <span class="keyword">as</span> sum_course,<span class="keyword">sum</span>(b.s_score) <span class="keyword">as</span> sum_score <span class="keyword">from</span> </span><br><span class="line">    student a </span><br><span class="line">    <span class="keyword">left</span> <span class="keyword">join</span> score b <span class="keyword">on</span> a.s_id=b.s_id</span><br><span class="line">    <span class="keyword">GROUP</span> <span class="keyword">BY</span> a.s_id,a.s_name;</span><br><span class="line"><span class="comment">-- 6、查询"李"姓老师的数量 </span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(t_id) <span class="keyword">from</span> teacher <span class="keyword">where</span> t_name <span class="keyword">like</span> <span class="string">'李%'</span>;</span><br><span class="line"><span class="comment">-- 7、查询学过"张三"老师授课的同学的信息 </span></span><br><span class="line"><span class="keyword">select</span> a.* <span class="keyword">from</span> </span><br><span class="line">    student a </span><br><span class="line">    <span class="keyword">join</span> score b <span class="keyword">on</span> a.s_id=b.s_id <span class="keyword">where</span> b.c_id <span class="keyword">in</span>(</span><br><span class="line">        <span class="keyword">select</span> c_id <span class="keyword">from</span> course <span class="keyword">where</span> t_id =(</span><br><span class="line">            <span class="keyword">select</span> t_id <span class="keyword">from</span> teacher <span class="keyword">where</span> t_name = <span class="string">'张三'</span>));</span><br><span class="line"><span class="comment">-- 8、查询没学过"张三"老师授课的同学的信息 </span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> </span><br><span class="line">    student c </span><br><span class="line">    <span class="keyword">where</span> c.s_id <span class="keyword">not</span> <span class="keyword">in</span>(</span><br><span class="line">        <span class="keyword">select</span> a.s_id <span class="keyword">from</span> student a <span class="keyword">join</span> score b <span class="keyword">on</span> a.s_id=b.s_id <span class="keyword">where</span> b.c_id <span class="keyword">in</span>(</span><br><span class="line">            <span class="keyword">select</span> c_id <span class="keyword">from</span> course <span class="keyword">where</span> t_id =(</span><br><span class="line">                <span class="keyword">select</span> t_id <span class="keyword">from</span> teacher <span class="keyword">where</span> t_name = <span class="string">'张三'</span>)));</span><br><span class="line"><span class="comment">-- 9、查询学过编号为"01"并且也学过编号为"02"的课程的同学的信息 </span></span><br><span class="line"><span class="keyword">select</span> a.* <span class="keyword">from</span> </span><br><span class="line">    student a,score b,score c </span><br><span class="line">    <span class="keyword">where</span> a.s_id = b.s_id  <span class="keyword">and</span> a.s_id = c.s_id <span class="keyword">and</span> b.c_id=<span class="string">'01'</span> <span class="keyword">and</span> c.c_id=<span class="string">'02'</span>; </span><br><span class="line"><span class="comment">-- 10、查询学过编号为"01"但是没有学过编号为"02"的课程的同学的信息</span></span><br><span class="line"><span class="keyword">select</span> a.* <span class="keyword">from</span> </span><br><span class="line">    student a </span><br><span class="line">    <span class="keyword">where</span> a.s_id <span class="keyword">in</span> (<span class="keyword">select</span> s_id <span class="keyword">from</span> score <span class="keyword">where</span> c_id=<span class="string">'01'</span> ) <span class="keyword">and</span> a.s_id <span class="keyword">not</span> <span class="keyword">in</span>(<span class="keyword">select</span> s_id <span class="keyword">from</span> score <span class="keyword">where</span> c_id=<span class="string">'02'</span>)</span><br><span class="line"><span class="comment">-- 11、查询没有学全所有课程的同学的信息 </span></span><br><span class="line"><span class="keyword">select</span> s.* <span class="keyword">from</span> </span><br><span class="line">    student s <span class="keyword">where</span> s.s_id <span class="keyword">in</span>(</span><br><span class="line">        <span class="keyword">select</span> s_id <span class="keyword">from</span> score <span class="keyword">where</span> s_id <span class="keyword">not</span> <span class="keyword">in</span>(</span><br><span class="line">            <span class="keyword">select</span> a.s_id <span class="keyword">from</span> score a </span><br><span class="line">                <span class="keyword">join</span> score b <span class="keyword">on</span> a.s_id = b.s_id <span class="keyword">and</span> b.c_id=<span class="string">'02'</span></span><br><span class="line">                <span class="keyword">join</span> score c <span class="keyword">on</span> a.s_id = c.s_id <span class="keyword">and</span> c.c_id=<span class="string">'03'</span></span><br><span class="line">            <span class="keyword">where</span> a.c_id=<span class="string">'01'</span>))</span><br><span class="line"><span class="comment">-- 12、查询至少有一门课与学号为"01"的同学所学相同的同学的信息 </span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> student <span class="keyword">where</span> s_id <span class="keyword">in</span>(</span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">distinct</span> a.s_id <span class="keyword">from</span> score a <span class="keyword">where</span> a.c_id <span class="keyword">in</span>(<span class="keyword">select</span> a.c_id <span class="keyword">from</span> score a <span class="keyword">where</span> a.s_id=<span class="string">'01'</span>)</span><br><span class="line">    );</span><br><span class="line"><span class="comment">-- 13、查询和"01"号的同学学习的课程完全相同的其他同学的信息  </span></span><br><span class="line"><span class="keyword">select</span> a.* <span class="keyword">from</span> student a <span class="keyword">where</span> a.s_id <span class="keyword">in</span>(</span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">distinct</span> s_id <span class="keyword">from</span> score <span class="keyword">where</span> s_id!=<span class="string">'01'</span> <span class="keyword">and</span> c_id <span class="keyword">in</span>(<span class="keyword">select</span> c_id <span class="keyword">from</span> score <span class="keyword">where</span> s_id=<span class="string">'01'</span>)</span><br><span class="line">    <span class="keyword">group</span> <span class="keyword">by</span> s_id </span><br><span class="line">    <span class="keyword">having</span> <span class="keyword">count</span>(<span class="number">1</span>)=(<span class="keyword">select</span> <span class="keyword">count</span>(<span class="number">1</span>) <span class="keyword">from</span> score <span class="keyword">where</span> s_id=<span class="string">'01'</span>));</span><br><span class="line"><span class="comment">-- 14、查询没学过"张三"老师讲授的任一门课程的学生姓名 </span></span><br><span class="line"><span class="keyword">select</span> a.s_name <span class="keyword">from</span> student a <span class="keyword">where</span> a.s_id <span class="keyword">not</span> <span class="keyword">in</span> (</span><br><span class="line">    <span class="keyword">select</span> s_id <span class="keyword">from</span> score <span class="keyword">where</span> c_id = </span><br><span class="line">                (<span class="keyword">select</span> c_id <span class="keyword">from</span> course <span class="keyword">where</span> t_id =(</span><br><span class="line">                    <span class="keyword">select</span> t_id <span class="keyword">from</span> teacher <span class="keyword">where</span> t_name = <span class="string">'张三'</span>)) </span><br><span class="line">                <span class="keyword">group</span> <span class="keyword">by</span> s_id);</span><br><span class="line"><span class="comment">-- 15、查询两门及其以上不及格课程的同学的学号，姓名及其平均成绩 </span></span><br><span class="line"><span class="keyword">select</span> a.s_id,a.s_name,<span class="keyword">ROUND</span>(<span class="keyword">AVG</span>(b.s_score)) <span class="keyword">from</span> </span><br><span class="line">    student a </span><br><span class="line">    <span class="keyword">left</span> <span class="keyword">join</span> score b <span class="keyword">on</span> a.s_id = b.s_id</span><br><span class="line">    <span class="keyword">where</span> a.s_id <span class="keyword">in</span>(</span><br><span class="line">            <span class="keyword">select</span> s_id <span class="keyword">from</span> score <span class="keyword">where</span> s_score&lt;<span class="number">60</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span>  s_id <span class="keyword">having</span> <span class="keyword">count</span>(<span class="number">1</span>)&gt;=<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">GROUP</span> <span class="keyword">BY</span> a.s_id,a.s_name </span><br><span class="line"><span class="comment">-- 16、检索"01"课程分数小于60，按分数降序排列的学生信息</span></span><br><span class="line"><span class="keyword">select</span> a.*,b.c_id,b.s_score <span class="keyword">from</span> </span><br><span class="line">    student a,score b </span><br><span class="line">    <span class="keyword">where</span> a.s_id = b.s_id <span class="keyword">and</span> b.c_id=<span class="string">'01'</span> <span class="keyword">and</span> b.s_score&lt;<span class="number">60</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> b.s_score <span class="keyword">DESC</span>;</span><br><span class="line"><span class="comment">-- 17、按平均成绩从高到低显示所有学生的所有课程的成绩以及平均成绩</span></span><br><span class="line"><span class="keyword">select</span> a.s_id,(<span class="keyword">select</span> s_score <span class="keyword">from</span> score <span class="keyword">where</span> s_id=a.s_id <span class="keyword">and</span> c_id=<span class="string">'01'</span>) <span class="keyword">as</span> 语文,</span><br><span class="line">                (<span class="keyword">select</span> s_score <span class="keyword">from</span> score <span class="keyword">where</span> s_id=a.s_id <span class="keyword">and</span> c_id=<span class="string">'02'</span>) <span class="keyword">as</span> 数学,</span><br><span class="line">                (<span class="keyword">select</span> s_score <span class="keyword">from</span> score <span class="keyword">where</span> s_id=a.s_id <span class="keyword">and</span> c_id=<span class="string">'03'</span>) <span class="keyword">as</span> 英语,</span><br><span class="line">            <span class="keyword">round</span>(<span class="keyword">avg</span>(s_score),<span class="number">2</span>) <span class="keyword">as</span> 平均分 <span class="keyword">from</span> score a  <span class="keyword">GROUP</span> <span class="keyword">BY</span> a.s_id <span class="keyword">ORDER</span> <span class="keyword">BY</span> 平均分 <span class="keyword">DESC</span>;</span><br><span class="line"><span class="comment">-- 18.查询各科成绩最高分、最低分和平均分：以如下形式显示：课程ID，课程name，最高分，最低分，平均分，及格率，中等率，优良率，优秀率</span></span><br><span class="line"><span class="comment">--及格为&gt;=60，中等为：70-80，优良为：80-90，优秀为：&gt;=90</span></span><br><span class="line"><span class="keyword">select</span> a.c_id,b.c_name,<span class="keyword">MAX</span>(s_score),<span class="keyword">MIN</span>(s_score),<span class="keyword">ROUND</span>(<span class="keyword">AVG</span>(s_score),<span class="number">2</span>),</span><br><span class="line">    <span class="keyword">ROUND</span>(<span class="number">100</span>*(<span class="keyword">SUM</span>(<span class="keyword">case</span> <span class="keyword">when</span> a.s_score&gt;=<span class="number">60</span> <span class="keyword">then</span> <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">end</span>)/<span class="keyword">SUM</span>(<span class="keyword">case</span> <span class="keyword">when</span> a.s_score <span class="keyword">then</span> <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">end</span>)),<span class="number">2</span>) <span class="keyword">as</span> 及格率,</span><br><span class="line">    <span class="keyword">ROUND</span>(<span class="number">100</span>*(<span class="keyword">SUM</span>(<span class="keyword">case</span> <span class="keyword">when</span> a.s_score&gt;=<span class="number">70</span> <span class="keyword">and</span> a.s_score&lt;=<span class="number">80</span> <span class="keyword">then</span> <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">end</span>)/<span class="keyword">SUM</span>(<span class="keyword">case</span> <span class="keyword">when</span> a.s_score <span class="keyword">then</span> <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">end</span>)),<span class="number">2</span>) <span class="keyword">as</span> 中等率,</span><br><span class="line">    <span class="keyword">ROUND</span>(<span class="number">100</span>*(<span class="keyword">SUM</span>(<span class="keyword">case</span> <span class="keyword">when</span> a.s_score&gt;=<span class="number">80</span> <span class="keyword">and</span> a.s_score&lt;=<span class="number">90</span> <span class="keyword">then</span> <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">end</span>)/<span class="keyword">SUM</span>(<span class="keyword">case</span> <span class="keyword">when</span> a.s_score <span class="keyword">then</span> <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">end</span>)),<span class="number">2</span>) <span class="keyword">as</span> 优良率,</span><br><span class="line">    <span class="keyword">ROUND</span>(<span class="number">100</span>*(<span class="keyword">SUM</span>(<span class="keyword">case</span> <span class="keyword">when</span> a.s_score&gt;=<span class="number">90</span> <span class="keyword">then</span> <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">end</span>)/<span class="keyword">SUM</span>(<span class="keyword">case</span> <span class="keyword">when</span> a.s_score <span class="keyword">then</span> <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">end</span>)),<span class="number">2</span>) <span class="keyword">as</span> 优秀率</span><br><span class="line">    <span class="keyword">from</span> score a <span class="keyword">left</span> <span class="keyword">join</span> course b <span class="keyword">on</span> a.c_id = b.c_id <span class="keyword">GROUP</span> <span class="keyword">BY</span> a.c_id,b.c_name</span><br><span class="line"><span class="comment">-- 19、按各科成绩进行排序，并显示排名(实现不完全)</span></span><br><span class="line"><span class="comment">-- mysql没有rank函数</span></span><br><span class="line">    <span class="keyword">select</span> a.s_id,a.c_id,</span><br><span class="line">        @i:=@i +<span class="number">1</span> <span class="keyword">as</span> i保留排名,</span><br><span class="line">        @k:=(<span class="keyword">case</span> <span class="keyword">when</span> @score=a.s_score <span class="keyword">then</span> @k <span class="keyword">else</span> @i <span class="keyword">end</span>) <span class="keyword">as</span> <span class="keyword">rank</span>不保留排名,</span><br><span class="line">        @score:=a.s_score <span class="keyword">as</span> score</span><br><span class="line">    <span class="keyword">from</span> (</span><br><span class="line">        <span class="keyword">select</span> s_id,c_id,s_score <span class="keyword">from</span> score <span class="keyword">WHERE</span> c_id=<span class="string">'01'</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> s_id,c_id,s_score <span class="keyword">ORDER</span> <span class="keyword">BY</span> s_score <span class="keyword">DESC</span></span><br><span class="line">)a,(<span class="keyword">select</span> @k:=<span class="number">0</span>,@i:=<span class="number">0</span>,@score:=<span class="number">0</span>)s</span><br><span class="line">    <span class="keyword">union</span></span><br><span class="line">    <span class="keyword">select</span> a.s_id,a.c_id,</span><br><span class="line">        @i:=@i +<span class="number">1</span> <span class="keyword">as</span> i,</span><br><span class="line">        @k:=(<span class="keyword">case</span> <span class="keyword">when</span> @score=a.s_score <span class="keyword">then</span> @k <span class="keyword">else</span> @i <span class="keyword">end</span>) <span class="keyword">as</span> <span class="keyword">rank</span>,</span><br><span class="line">        @score:=a.s_score <span class="keyword">as</span> score</span><br><span class="line">    <span class="keyword">from</span> (</span><br><span class="line">        <span class="keyword">select</span> s_id,c_id,s_score <span class="keyword">from</span> score <span class="keyword">WHERE</span> c_id=<span class="string">'02'</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> s_id,c_id,s_score <span class="keyword">ORDER</span> <span class="keyword">BY</span> s_score <span class="keyword">DESC</span></span><br><span class="line">)a,(<span class="keyword">select</span> @k:=<span class="number">0</span>,@i:=<span class="number">0</span>,@score:=<span class="number">0</span>)s</span><br><span class="line">    <span class="keyword">union</span></span><br><span class="line">    <span class="keyword">select</span> a.s_id,a.c_id,</span><br><span class="line">        @i:=@i +<span class="number">1</span> <span class="keyword">as</span> i,</span><br><span class="line">        @k:=(<span class="keyword">case</span> <span class="keyword">when</span> @score=a.s_score <span class="keyword">then</span> @k <span class="keyword">else</span> @i <span class="keyword">end</span>) <span class="keyword">as</span> <span class="keyword">rank</span>,</span><br><span class="line">        @score:=a.s_score <span class="keyword">as</span> score</span><br><span class="line">    <span class="keyword">from</span> (</span><br><span class="line">        <span class="keyword">select</span> s_id,c_id,s_score <span class="keyword">from</span> score <span class="keyword">WHERE</span> c_id=<span class="string">'03'</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> s_id,c_id,s_score <span class="keyword">ORDER</span> <span class="keyword">BY</span> s_score <span class="keyword">DESC</span></span><br><span class="line">)a,(<span class="keyword">select</span> @k:=<span class="number">0</span>,@i:=<span class="number">0</span>,@score:=<span class="number">0</span>)s</span><br><span class="line"><span class="comment">-- 20、查询学生的总成绩并进行排名</span></span><br><span class="line"><span class="keyword">select</span> a.s_id,</span><br><span class="line">    @i:=@i+<span class="number">1</span> <span class="keyword">as</span> i,</span><br><span class="line">    @k:=(<span class="keyword">case</span> <span class="keyword">when</span> @score=a.sum_score <span class="keyword">then</span> @k <span class="keyword">else</span> @i <span class="keyword">end</span>) <span class="keyword">as</span> <span class="keyword">rank</span>,</span><br><span class="line">    @score:=a.sum_score <span class="keyword">as</span> score</span><br><span class="line"><span class="keyword">from</span> (<span class="keyword">select</span> s_id,<span class="keyword">SUM</span>(s_score) <span class="keyword">as</span> sum_score <span class="keyword">from</span> score <span class="keyword">GROUP</span> <span class="keyword">BY</span> s_id <span class="keyword">ORDER</span> <span class="keyword">BY</span> sum_score <span class="keyword">DESC</span>)a,</span><br><span class="line">    (<span class="keyword">select</span> @k:=<span class="number">0</span>,@i:=<span class="number">0</span>,@score:=<span class="number">0</span>)s</span><br><span class="line"><span class="comment">-- 21、查询不同老师所教不同课程平均分从高到低显示 </span></span><br><span class="line">    <span class="keyword">select</span> a.t_id,c.t_name,a.c_id,<span class="keyword">ROUND</span>(<span class="keyword">avg</span>(s_score),<span class="number">2</span>) <span class="keyword">as</span> avg_score <span class="keyword">from</span> course a</span><br><span class="line">        <span class="keyword">left</span> <span class="keyword">join</span> score b <span class="keyword">on</span> a.c_id=b.c_id </span><br><span class="line">        <span class="keyword">left</span> <span class="keyword">join</span> teacher c <span class="keyword">on</span> a.t_id=c.t_id</span><br><span class="line">        <span class="keyword">GROUP</span> <span class="keyword">BY</span> a.c_id,a.t_id,c.t_name <span class="keyword">ORDER</span> <span class="keyword">BY</span> avg_score <span class="keyword">DESC</span>;</span><br><span class="line"><span class="comment">-- 22、查询所有课程的成绩第2名到第3名的学生信息及该课程成绩 </span></span><br><span class="line">            <span class="keyword">select</span> d.*,c.排名,c.s_score,c.c_id <span class="keyword">from</span> (</span><br><span class="line">                <span class="keyword">select</span> a.s_id,a.s_score,a.c_id,@i:=@i+<span class="number">1</span> <span class="keyword">as</span> 排名 <span class="keyword">from</span> score a,(<span class="keyword">select</span> @i:=<span class="number">0</span>)s <span class="keyword">where</span> a.c_id=<span class="string">'01'</span>    </span><br><span class="line">            )c</span><br><span class="line">            <span class="keyword">left</span> <span class="keyword">join</span> student d <span class="keyword">on</span> c.s_id=d.s_id</span><br><span class="line">            <span class="keyword">where</span> 排名 <span class="keyword">BETWEEN</span> <span class="number">2</span> <span class="keyword">AND</span> <span class="number">3</span></span><br><span class="line">            <span class="keyword">UNION</span></span><br><span class="line">            <span class="keyword">select</span> d.*,c.排名,c.s_score,c.c_id <span class="keyword">from</span> (</span><br><span class="line">                <span class="keyword">select</span> a.s_id,a.s_score,a.c_id,@j:=@j+<span class="number">1</span> <span class="keyword">as</span> 排名 <span class="keyword">from</span> score a,(<span class="keyword">select</span> @j:=<span class="number">0</span>)s <span class="keyword">where</span> a.c_id=<span class="string">'02'</span>    </span><br><span class="line">            )c</span><br><span class="line">            <span class="keyword">left</span> <span class="keyword">join</span> student d <span class="keyword">on</span> c.s_id=d.s_id</span><br><span class="line">            <span class="keyword">where</span> 排名 <span class="keyword">BETWEEN</span> <span class="number">2</span> <span class="keyword">AND</span> <span class="number">3</span></span><br><span class="line">            <span class="keyword">UNION</span></span><br><span class="line">            <span class="keyword">select</span> d.*,c.排名,c.s_score,c.c_id <span class="keyword">from</span> (</span><br><span class="line">                <span class="keyword">select</span> a.s_id,a.s_score,a.c_id,@k:=@k+<span class="number">1</span> <span class="keyword">as</span> 排名 <span class="keyword">from</span> score a,(<span class="keyword">select</span> @k:=<span class="number">0</span>)s <span class="keyword">where</span> a.c_id=<span class="string">'03'</span>    </span><br><span class="line">            )c</span><br><span class="line">            <span class="keyword">left</span> <span class="keyword">join</span> student d <span class="keyword">on</span> c.s_id=d.s_id</span><br><span class="line">            <span class="keyword">where</span> 排名 <span class="keyword">BETWEEN</span> <span class="number">2</span> <span class="keyword">AND</span> <span class="number">3</span>;</span><br><span class="line"><span class="comment">-- 23、统计各科成绩各分数段人数：课程编号,课程名称,[100-85],[85-70],[70-60],[0-60]及所占百分比</span></span><br><span class="line">        <span class="keyword">select</span> <span class="keyword">distinct</span> f.c_name,a.c_id,b.<span class="string">`85-100`</span>,b.百分比,c.<span class="string">`70-85`</span>,c.百分比,d.<span class="string">`60-70`</span>,d.百分比,e.<span class="string">`0-60`</span>,e.百分比 <span class="keyword">from</span> score a</span><br><span class="line">                <span class="keyword">left</span> <span class="keyword">join</span> (<span class="keyword">select</span> c_id,<span class="keyword">SUM</span>(<span class="keyword">case</span> <span class="keyword">when</span> s_score &gt;<span class="number">85</span> <span class="keyword">and</span> s_score &lt;=<span class="number">100</span> <span class="keyword">then</span> <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">end</span>) <span class="keyword">as</span> <span class="string">`85-100`</span>,</span><br><span class="line">                                            <span class="keyword">ROUND</span>(<span class="number">100</span>*(<span class="keyword">SUM</span>(<span class="keyword">case</span> <span class="keyword">when</span> s_score &gt;<span class="number">85</span> <span class="keyword">and</span> s_score &lt;=<span class="number">100</span> <span class="keyword">then</span> <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">end</span>)/<span class="keyword">count</span>(*)),<span class="number">2</span>) <span class="keyword">as</span> 百分比</span><br><span class="line">                                <span class="keyword">from</span> score <span class="keyword">GROUP</span> <span class="keyword">BY</span> c_id)b <span class="keyword">on</span> a.c_id=b.c_id</span><br><span class="line">                <span class="keyword">left</span> <span class="keyword">join</span> (<span class="keyword">select</span> c_id,<span class="keyword">SUM</span>(<span class="keyword">case</span> <span class="keyword">when</span> s_score &gt;<span class="number">70</span> <span class="keyword">and</span> s_score &lt;=<span class="number">85</span> <span class="keyword">then</span> <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">end</span>) <span class="keyword">as</span> <span class="string">`70-85`</span>,</span><br><span class="line">                                            <span class="keyword">ROUND</span>(<span class="number">100</span>*(<span class="keyword">SUM</span>(<span class="keyword">case</span> <span class="keyword">when</span> s_score &gt;<span class="number">70</span> <span class="keyword">and</span> s_score &lt;=<span class="number">85</span> <span class="keyword">then</span> <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">end</span>)/<span class="keyword">count</span>(*)),<span class="number">2</span>) <span class="keyword">as</span> 百分比</span><br><span class="line">                                <span class="keyword">from</span> score <span class="keyword">GROUP</span> <span class="keyword">BY</span> c_id)c <span class="keyword">on</span> a.c_id=c.c_id</span><br><span class="line">                <span class="keyword">left</span> <span class="keyword">join</span> (<span class="keyword">select</span> c_id,<span class="keyword">SUM</span>(<span class="keyword">case</span> <span class="keyword">when</span> s_score &gt;<span class="number">60</span> <span class="keyword">and</span> s_score &lt;=<span class="number">70</span> <span class="keyword">then</span> <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">end</span>) <span class="keyword">as</span> <span class="string">`60-70`</span>,</span><br><span class="line">                                            <span class="keyword">ROUND</span>(<span class="number">100</span>*(<span class="keyword">SUM</span>(<span class="keyword">case</span> <span class="keyword">when</span> s_score &gt;<span class="number">60</span> <span class="keyword">and</span> s_score &lt;=<span class="number">70</span> <span class="keyword">then</span> <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">end</span>)/<span class="keyword">count</span>(*)),<span class="number">2</span>) <span class="keyword">as</span> 百分比</span><br><span class="line">                                <span class="keyword">from</span> score <span class="keyword">GROUP</span> <span class="keyword">BY</span> c_id)d <span class="keyword">on</span> a.c_id=d.c_id</span><br><span class="line">                <span class="keyword">left</span> <span class="keyword">join</span> (<span class="keyword">select</span> c_id,<span class="keyword">SUM</span>(<span class="keyword">case</span> <span class="keyword">when</span> s_score &gt;=<span class="number">0</span> <span class="keyword">and</span> s_score &lt;=<span class="number">60</span> <span class="keyword">then</span> <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">end</span>) <span class="keyword">as</span> <span class="string">`0-60`</span>,</span><br><span class="line">                                            <span class="keyword">ROUND</span>(<span class="number">100</span>*(<span class="keyword">SUM</span>(<span class="keyword">case</span> <span class="keyword">when</span> s_score &gt;=<span class="number">0</span> <span class="keyword">and</span> s_score &lt;=<span class="number">60</span> <span class="keyword">then</span> <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">end</span>)/<span class="keyword">count</span>(*)),<span class="number">2</span>) <span class="keyword">as</span> 百分比</span><br><span class="line">                                <span class="keyword">from</span> score <span class="keyword">GROUP</span> <span class="keyword">BY</span> c_id)e <span class="keyword">on</span> a.c_id=e.c_id</span><br><span class="line">                <span class="keyword">left</span> <span class="keyword">join</span> course f <span class="keyword">on</span> a.c_id = f.c_id</span><br><span class="line"><span class="comment">-- 24、查询学生平均成绩及其名次 </span></span><br><span class="line">        <span class="keyword">select</span> a.s_id,</span><br><span class="line">                @i:=@i+<span class="number">1</span> <span class="keyword">as</span> <span class="string">'不保留空缺排名'</span>,</span><br><span class="line">                @k:=(<span class="keyword">case</span> <span class="keyword">when</span> @avg_score=a.avg_s <span class="keyword">then</span> @k <span class="keyword">else</span> @i <span class="keyword">end</span>) <span class="keyword">as</span> <span class="string">'保留空缺排名'</span>,</span><br><span class="line">                @avg_score:=avg_s <span class="keyword">as</span> <span class="string">'平均分'</span></span><br><span class="line">        <span class="keyword">from</span> (<span class="keyword">select</span> s_id,<span class="keyword">ROUND</span>(<span class="keyword">AVG</span>(s_score),<span class="number">2</span>) <span class="keyword">as</span> avg_s <span class="keyword">from</span> score <span class="keyword">GROUP</span> <span class="keyword">BY</span> s_id)a,(<span class="keyword">select</span> @avg_score:=<span class="number">0</span>,@i:=<span class="number">0</span>,@k:=<span class="number">0</span>)b;</span><br><span class="line"><span class="comment">-- 25、查询各科成绩前三名的记录</span></span><br><span class="line">            <span class="comment">-- 1.选出b表比a表成绩大的所有组</span></span><br><span class="line">            <span class="comment">-- 2.选出比当前id成绩大的 小于三个的</span></span><br><span class="line">        <span class="keyword">select</span> a.s_id,a.c_id,a.s_score <span class="keyword">from</span> score a </span><br><span class="line">            <span class="keyword">left</span> <span class="keyword">join</span> score b <span class="keyword">on</span> a.c_id = b.c_id <span class="keyword">and</span> a.s_score&lt;b.s_score</span><br><span class="line">            <span class="keyword">group</span> <span class="keyword">by</span> a.s_id,a.c_id,a.s_score <span class="keyword">HAVING</span> <span class="keyword">COUNT</span>(b.s_id)&lt;<span class="number">3</span></span><br><span class="line">            <span class="keyword">ORDER</span> <span class="keyword">BY</span> a.c_id,a.s_score <span class="keyword">DESC</span> </span><br><span class="line"><span class="comment">-- 26、查询每门课程被选修的学生数  </span></span><br><span class="line">        <span class="keyword">select</span> c_id,<span class="keyword">count</span>(s_id) <span class="keyword">from</span> score a <span class="keyword">GROUP</span> <span class="keyword">BY</span> c_id </span><br><span class="line"><span class="comment">-- 27、查询出只有两门课程的全部学生的学号和姓名 </span></span><br><span class="line">        <span class="keyword">select</span> s_id,s_name <span class="keyword">from</span> student <span class="keyword">where</span> s_id <span class="keyword">in</span>(</span><br><span class="line">                <span class="keyword">select</span> s_id <span class="keyword">from</span> score <span class="keyword">GROUP</span> <span class="keyword">BY</span> s_id <span class="keyword">HAVING</span> <span class="keyword">COUNT</span>(c_id)=<span class="number">2</span>); </span><br><span class="line"><span class="comment">-- 28、查询男生、女生人数 </span></span><br><span class="line">        <span class="keyword">select</span> s_sex,<span class="keyword">COUNT</span>(s_sex) <span class="keyword">as</span> 人数  <span class="keyword">from</span> student <span class="keyword">GROUP</span> <span class="keyword">BY</span> s_sex</span><br><span class="line"><span class="comment">-- 29、查询名字中含有"风"字的学生信息</span></span><br><span class="line">        <span class="keyword">select</span> * <span class="keyword">from</span> student <span class="keyword">where</span> s_name <span class="keyword">like</span> <span class="string">'%风%'</span>;</span><br><span class="line"><span class="comment">-- 30、查询同名同性学生名单，并统计同名人数 </span></span><br><span class="line">        <span class="keyword">select</span> a.s_name,a.s_sex,<span class="keyword">count</span>(*) <span class="keyword">from</span> student a  <span class="keyword">JOIN</span> </span><br><span class="line">                    student b <span class="keyword">on</span> a.s_id !=b.s_id <span class="keyword">and</span> a.s_name = b.s_name <span class="keyword">and</span> a.s_sex = b.s_sex</span><br><span class="line">        <span class="keyword">GROUP</span> <span class="keyword">BY</span> a.s_name,a.s_sex</span><br><span class="line"><span class="comment">-- 31、查询1990年出生的学生名单 </span></span><br><span class="line">        <span class="keyword">select</span> s_name <span class="keyword">from</span> student <span class="keyword">where</span> s_birth <span class="keyword">like</span> <span class="string">'1990%'</span> </span><br><span class="line"><span class="comment">-- 32、查询每门课程的平均成绩，结果按平均成绩降序排列，平均成绩相同时，按课程编号升序排列 </span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">select</span> c_id,<span class="keyword">ROUND</span>(<span class="keyword">AVG</span>(s_score),<span class="number">2</span>) <span class="keyword">as</span> avg_score <span class="keyword">from</span> score <span class="keyword">GROUP</span> <span class="keyword">BY</span> c_id <span class="keyword">ORDER</span> <span class="keyword">BY</span> avg_score <span class="keyword">DESC</span>,c_id <span class="keyword">ASC</span></span><br><span class="line"><span class="comment">-- 33、查询平均成绩大于等于85的所有学生的学号、姓名和平均成绩 </span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">select</span> a.s_id,b.s_name,<span class="keyword">ROUND</span>(<span class="keyword">avg</span>(a.s_score),<span class="number">2</span>) <span class="keyword">as</span> avg_score <span class="keyword">from</span> score a</span><br><span class="line">        <span class="keyword">left</span> <span class="keyword">join</span> student b <span class="keyword">on</span> a.s_id=b.s_id <span class="keyword">GROUP</span> <span class="keyword">BY</span> s_id <span class="keyword">HAVING</span> avg_score&gt;=<span class="number">85</span></span><br><span class="line"><span class="comment">-- 34、查询课程名称为"数学"，且分数低于60的学生姓名和分数 </span></span><br><span class="line"> </span><br><span class="line">        <span class="keyword">select</span> a.s_name,b.s_score <span class="keyword">from</span> score b <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> student a <span class="keyword">on</span> a.s_id=b.s_id <span class="keyword">where</span> b.c_id=(</span><br><span class="line">                    <span class="keyword">select</span> c_id <span class="keyword">from</span> course <span class="keyword">where</span> c_name =<span class="string">'数学'</span>) <span class="keyword">and</span> b.s_score&lt;<span class="number">60</span> </span><br><span class="line"><span class="comment">-- 35、查询所有学生的课程及分数情况； </span></span><br><span class="line">        <span class="keyword">select</span> a.s_id,a.s_name,</span><br><span class="line">                    <span class="keyword">SUM</span>(<span class="keyword">case</span> c.c_name <span class="keyword">when</span> <span class="string">'语文'</span> <span class="keyword">then</span> b.s_score <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">end</span>) <span class="keyword">as</span> <span class="string">'语文'</span>,</span><br><span class="line">                    <span class="keyword">SUM</span>(<span class="keyword">case</span> c.c_name <span class="keyword">when</span> <span class="string">'数学'</span> <span class="keyword">then</span> b.s_score <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">end</span>) <span class="keyword">as</span> <span class="string">'数学'</span>,</span><br><span class="line">                    <span class="keyword">SUM</span>(<span class="keyword">case</span> c.c_name <span class="keyword">when</span> <span class="string">'英语'</span> <span class="keyword">then</span> b.s_score <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">end</span>) <span class="keyword">as</span> <span class="string">'英语'</span>,</span><br><span class="line">                    <span class="keyword">SUM</span>(b.s_score) <span class="keyword">as</span>  <span class="string">'总分'</span></span><br><span class="line">        <span class="keyword">from</span> student a <span class="keyword">left</span> <span class="keyword">join</span> score b <span class="keyword">on</span> a.s_id = b.s_id </span><br><span class="line">        <span class="keyword">left</span> <span class="keyword">join</span> course c <span class="keyword">on</span> b.c_id = c.c_id </span><br><span class="line">        <span class="keyword">GROUP</span> <span class="keyword">BY</span> a.s_id,a.s_name  </span><br><span class="line"> <span class="comment">-- 36、查询任何一门课程成绩在70分以上的姓名、课程名称和分数； </span></span><br><span class="line">            <span class="keyword">select</span> a.s_name,b.c_name,c.s_score <span class="keyword">from</span> course b <span class="keyword">left</span> <span class="keyword">join</span> score c <span class="keyword">on</span> b.c_id = c.c_id</span><br><span class="line">                <span class="keyword">left</span> <span class="keyword">join</span> student a <span class="keyword">on</span> a.s_id=c.s_id <span class="keyword">where</span> c.s_score&gt;=<span class="number">70</span> </span><br><span class="line"><span class="comment">-- 37、查询不及格的课程</span></span><br><span class="line">        <span class="keyword">select</span> a.s_id,a.c_id,b.c_name,a.s_score <span class="keyword">from</span> score a <span class="keyword">left</span> <span class="keyword">join</span> course b <span class="keyword">on</span> a.c_id = b.c_id</span><br><span class="line">            <span class="keyword">where</span> a.s_score&lt;<span class="number">60</span> </span><br><span class="line"><span class="comment">--38、查询课程编号为01且课程成绩在80分以上的学生的学号和姓名； </span></span><br><span class="line">        <span class="keyword">select</span> a.s_id,b.s_name <span class="keyword">from</span> score a <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> student b <span class="keyword">on</span> a.s_id = b.s_id</span><br><span class="line">            <span class="keyword">where</span> a.c_id = <span class="string">'01'</span> <span class="keyword">and</span> a.s_score&gt;<span class="number">80</span></span><br><span class="line"><span class="comment">-- 39、求每门课程的学生人数 </span></span><br><span class="line">        <span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> score <span class="keyword">GROUP</span> <span class="keyword">BY</span> c_id; </span><br><span class="line"><span class="comment">-- 40、查询选修"张三"老师所授课程的学生中，成绩最高的学生信息及其成绩</span></span><br><span class="line">        <span class="comment">-- 查询老师id   </span></span><br><span class="line">        <span class="keyword">select</span> c_id <span class="keyword">from</span> course c,teacher d <span class="keyword">where</span> c.t_id=d.t_id <span class="keyword">and</span> d.t_name=<span class="string">'张三'</span></span><br><span class="line">        <span class="comment">-- 查询最高分（可能有相同分数）</span></span><br><span class="line">        <span class="keyword">select</span> <span class="keyword">MAX</span>(s_score) <span class="keyword">from</span> score <span class="keyword">where</span> c_id=<span class="string">'02'</span></span><br><span class="line">        <span class="comment">-- 查询信息</span></span><br><span class="line">        <span class="keyword">select</span> a.*,b.s_score,b.c_id,c.c_name <span class="keyword">from</span> student a</span><br><span class="line">            <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> score b <span class="keyword">on</span> a.s_id = b.s_id</span><br><span class="line">            <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> course c <span class="keyword">on</span> b.c_id=c.c_id</span><br><span class="line">            <span class="keyword">where</span> b.c_id =(<span class="keyword">select</span> c_id <span class="keyword">from</span> course c,teacher d <span class="keyword">where</span> c.t_id=d.t_id <span class="keyword">and</span> d.t_name=<span class="string">'张三'</span>)</span><br><span class="line">            <span class="keyword">and</span> b.s_score <span class="keyword">in</span> (<span class="keyword">select</span> <span class="keyword">MAX</span>(s_score) <span class="keyword">from</span> score <span class="keyword">where</span> c_id=<span class="string">'02'</span>)</span><br><span class="line"><span class="comment">-- 41、查询不同课程成绩相同的学生的学生编号、课程编号、学生成绩 </span></span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">DISTINCT</span> b.s_id,b.c_id,b.s_score <span class="keyword">from</span> score a,score b <span class="keyword">where</span> a.c_id != b.c_id <span class="keyword">and</span> a.s_score = b.s_score</span><br><span class="line"><span class="comment">-- 42、查询每门功成绩最好的前两名 </span></span><br><span class="line">        <span class="comment">-- 牛逼的写法</span></span><br><span class="line">    <span class="keyword">select</span> a.s_id,a.c_id,a.s_score <span class="keyword">from</span> score a</span><br><span class="line">        <span class="keyword">where</span> (<span class="keyword">select</span> <span class="keyword">COUNT</span>(<span class="number">1</span>) <span class="keyword">from</span> score b <span class="keyword">where</span> b.c_id=a.c_id <span class="keyword">and</span> b.s_score&gt;=a.s_score)&lt;=<span class="number">2</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> a.c_id</span><br><span class="line"><span class="comment">-- 43、统计每门课程的学生选修人数（超过5人的课程才统计）。要求输出课程号和选修人数，查询结果按人数降序排列，若人数相同，按课程号升序排列  </span></span><br><span class="line">        <span class="keyword">select</span> c_id,<span class="keyword">count</span>(*) <span class="keyword">as</span> total <span class="keyword">from</span> score <span class="keyword">GROUP</span> <span class="keyword">BY</span> c_id <span class="keyword">HAVING</span> total&gt;<span class="number">5</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> total,c_id <span class="keyword">ASC</span></span><br><span class="line"><span class="comment">-- 44、检索至少选修两门课程的学生学号 </span></span><br><span class="line">        <span class="keyword">select</span> s_id,<span class="keyword">count</span>(*) <span class="keyword">as</span> sel <span class="keyword">from</span> score <span class="keyword">GROUP</span> <span class="keyword">BY</span> s_id <span class="keyword">HAVING</span> sel&gt;=<span class="number">2</span></span><br><span class="line"><span class="comment">-- 45、查询选修了全部课程的学生信息 </span></span><br><span class="line">        <span class="keyword">select</span> * <span class="keyword">from</span> student <span class="keyword">where</span> s_id <span class="keyword">in</span>(        </span><br><span class="line">            <span class="keyword">select</span> s_id <span class="keyword">from</span> score <span class="keyword">GROUP</span> <span class="keyword">BY</span> s_id <span class="keyword">HAVING</span> <span class="keyword">count</span>(*)=(<span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> course))</span><br><span class="line"><span class="comment">--46、查询各学生的年龄</span></span><br><span class="line">    <span class="comment">-- 按照出生日期来算，当前月日 &lt; 出生年月的月日则，年龄减一</span></span><br><span class="line">    <span class="keyword">select</span> s_birth,(<span class="keyword">DATE_FORMAT</span>(<span class="keyword">NOW</span>(),<span class="string">'%Y'</span>)-<span class="keyword">DATE_FORMAT</span>(s_birth,<span class="string">'%Y'</span>) - </span><br><span class="line">                (<span class="keyword">case</span> <span class="keyword">when</span> <span class="keyword">DATE_FORMAT</span>(<span class="keyword">NOW</span>(),<span class="string">'%m%d'</span>)&gt;<span class="keyword">DATE_FORMAT</span>(s_birth,<span class="string">'%m%d'</span>) <span class="keyword">then</span> <span class="number">0</span> <span class="keyword">else</span> <span class="number">1</span> <span class="keyword">end</span>)) <span class="keyword">as</span> age</span><br><span class="line">        <span class="keyword">from</span> student;</span><br><span class="line"><span class="comment">-- 47、查询本周过生日的学生</span></span><br><span class="line">    <span class="keyword">select</span> * <span class="keyword">from</span> student <span class="keyword">where</span> <span class="keyword">WEEK</span>(<span class="keyword">DATE_FORMAT</span>(<span class="keyword">NOW</span>(),<span class="string">'%Y%m%d'</span>))=<span class="keyword">WEEK</span>(s_birth)</span><br><span class="line">    <span class="keyword">select</span> * <span class="keyword">from</span> student <span class="keyword">where</span> <span class="keyword">YEARWEEK</span>(s_birth)=<span class="keyword">YEARWEEK</span>(<span class="keyword">DATE_FORMAT</span>(<span class="keyword">NOW</span>(),<span class="string">'%Y%m%d'</span>))</span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">WEEK</span>(<span class="keyword">DATE_FORMAT</span>(<span class="keyword">NOW</span>(),<span class="string">'%Y%m%d'</span>)) </span><br><span class="line"><span class="comment">-- 48、查询下周过生日的学生</span></span><br><span class="line">    <span class="keyword">select</span> * <span class="keyword">from</span> student <span class="keyword">where</span> <span class="keyword">WEEK</span>(<span class="keyword">DATE_FORMAT</span>(<span class="keyword">NOW</span>(),<span class="string">'%Y%m%d'</span>))+<span class="number">1</span> =<span class="keyword">WEEK</span>(s_birth) </span><br><span class="line"><span class="comment">-- 49、查询本月过生日的学生</span></span><br><span class="line">    <span class="keyword">select</span> * <span class="keyword">from</span> student <span class="keyword">where</span> <span class="keyword">MONTH</span>(<span class="keyword">DATE_FORMAT</span>(<span class="keyword">NOW</span>(),<span class="string">'%Y%m%d'</span>)) =<span class="keyword">MONTH</span>(s_birth)</span><br><span class="line"><span class="comment">-- 50、查询下月过生日的学生</span></span><br><span class="line">    <span class="keyword">select</span> * <span class="keyword">from</span> student <span class="keyword">where</span> <span class="keyword">MONTH</span>(<span class="keyword">DATE_FORMAT</span>(<span class="keyword">NOW</span>(),<span class="string">'%Y%m%d'</span>))+<span class="number">1</span> =<span class="keyword">MONTH</span>(s_birth)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL读写分离</title>
      <link href="/2020/08/03/MySQL%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/"/>
      <url>/2020/08/03/MySQL%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="MySQL读写分离"><a href="#MySQL读写分离" class="headerlink" title="MySQL读写分离"></a>MySQL读写分离</h2><h3 id="1、读写分离的介绍"><a href="#1、读写分离的介绍" class="headerlink" title="1、读写分离的介绍"></a>1、读写分离的介绍</h3><p><img src="/2020/08/03/MySQL%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB.jpg" alt></p><p>​        MySQL读写分离基本原理是让master数据库处理写操作，slave数据库处理读操作。master将写操作的变更同步到各个slave节点。</p><p>​        MySQL读写分离能提高系统性能的原因在于：</p><p>​        1、物理服务器增加，机器处理能力提升。拿硬件换性能。</p><p>​        2、主从只负责各自的读和写，极大程度缓解X锁 (排它锁) 和S锁 (共享锁) 争用。</p><p>​        3、slave可以配置myiasm引擎，提升查询性能以及节约系统开销。</p><p>​        4、master直接写是并发的，slave通过主库发送来的binlog恢复数据是异步。</p><p>​        5、slave可以单独设置一些参数来提升其读的性能。</p><p>​        6、增加冗余，提高可用性。</p><h3 id="2、读写分离的配置"><a href="#2、读写分离的配置" class="headerlink" title="2、读写分离的配置"></a>2、读写分离的配置</h3><h5 id="1、硬件配置"><a href="#1、硬件配置" class="headerlink" title="1、硬件配置"></a>1、硬件配置</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">master 192.168.85.11</span><br><span class="line">slave  192.168.85.12</span><br><span class="line">proxy  192，168.85.14</span><br></pre></td></tr></table></figure><h5 id="2、首先在master和slave上配置主从复制"><a href="#2、首先在master和slave上配置主从复制" class="headerlink" title="2、首先在master和slave上配置主从复制"></a>2、首先在master和slave上配置主从复制</h5><h5 id="3、进行proxy的相关配置"><a href="#3、进行proxy的相关配置" class="headerlink" title="3、进行proxy的相关配置"></a>3、进行proxy的相关配置</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">1、下载mysql-proxy</span></span><br><span class="line">https://downloads.mysql.com/archives/proxy/#downloads</span><br><span class="line"><span class="meta">#</span><span class="bash">2、上传软件到proxy的机器</span></span><br><span class="line">直接通过xftp进行上传</span><br><span class="line"><span class="meta">#</span><span class="bash">3、解压安装包</span></span><br><span class="line">tar -zxvf mysql-proxy-0.8.5-linux-glibc2.3-x86-64bit.tar.gz</span><br><span class="line"><span class="meta">#</span><span class="bash">4、修改解压后的目录</span></span><br><span class="line">mv mysql-proxy-0.8.5-linux-glibc2.3-x86-64bit mysql-proxy</span><br><span class="line"><span class="meta">#</span><span class="bash">5、进入mysql-proxy的目录</span></span><br><span class="line">cd mysql-proxy</span><br><span class="line"><span class="meta">#</span><span class="bash">6、创建目录</span></span><br><span class="line">mkdir conf</span><br><span class="line">mkdir logs</span><br><span class="line"><span class="meta">#</span><span class="bash">7、添加环境变量</span></span><br><span class="line"><span class="meta">#</span><span class="bash">打开/etc/profile文件</span></span><br><span class="line">vi /etc/profile</span><br><span class="line"><span class="meta">#</span><span class="bash">在文件的最后面添加一下命令</span></span><br><span class="line">export PATH=$PATH:/root/mysql-proxy/bin</span><br><span class="line"><span class="meta">#</span><span class="bash">8、执行命令让环境变量生效</span></span><br><span class="line">source /etc/profile</span><br><span class="line"><span class="meta">#</span><span class="bash">9、进入conf目录，创建文件并添加一下内容</span></span><br><span class="line">vi mysql-proxy.conf</span><br><span class="line">添加内容</span><br><span class="line">[mysql-proxy]</span><br><span class="line">user=root</span><br><span class="line">proxy-address=192.168.85.14:4040</span><br><span class="line">proxy-backend-addresses=192.168.85.11:3306</span><br><span class="line">proxy-read-only-backend-addresses=192.168.85.12:3306</span><br><span class="line">proxy-lua-script=/root/mysql-proxy/share/doc/mysql-proxy/rw-splitting.lua</span><br><span class="line">log-file=/root/mysql-proxy/logs/mysql-proxy.log</span><br><span class="line">log-level=debug</span><br><span class="line">daemon=true</span><br><span class="line"><span class="meta">#</span><span class="bash">10、开启mysql-proxy</span></span><br><span class="line">mysql-proxy --defaults-file=/root/mysql-proxy/conf/mysql-proxy.conf</span><br><span class="line"><span class="meta">#</span><span class="bash">11、查看是否安装成功，打开日志文件</span></span><br><span class="line">cd /root/mysql-proxy/logs</span><br><span class="line">tail -100 mysql-proxy.log</span><br><span class="line"><span class="meta">#</span><span class="bash">内容如下：表示安装成功</span></span><br><span class="line">2019-10-11 21:49:41: (debug) max open file-descriptors = 1024</span><br><span class="line">2019-10-11 21:49:41: (message) proxy listening on port 192.168.85.14:4040</span><br><span class="line">2019-10-11 21:49:41: (message) added read/write backend: 192.168.85.11:3306</span><br><span class="line">2019-10-11 21:49:41: (message) added read-only backend: 192.168.85.12:3306</span><br><span class="line">2019-10-11 21:49:41: (debug) now running as user: root (0/0)</span><br></pre></td></tr></table></figure><h5 id="4、进行连接"><a href="#4、进行连接" class="headerlink" title="4、进行连接"></a>4、进行连接</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">mysql的命令行会出现无法连接的情况，所以建议使用客户端</span></span><br><span class="line">mysql -uroot -p123 -h192.168.85.14 -P 4040</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL的锁机制</title>
      <link href="/2020/08/03/MySQL%E7%9A%84%E9%94%81%E6%9C%BA%E5%88%B6/"/>
      <url>/2020/08/03/MySQL%E7%9A%84%E9%94%81%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL的锁机制"><a href="#MySQL的锁机制" class="headerlink" title="MySQL的锁机制"></a>MySQL的锁机制</h1><h3 id="1、MySQL锁"><a href="#1、MySQL锁" class="headerlink" title="1、MySQL锁"></a>1、MySQL锁</h3><p>​        <strong>锁是计算机协调多个进程或线程并发访问某一资源的机制。</strong>在数据库中，除传统的 计算资源（如CPU、RAM、I/O等）的争用以外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一 个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个角度来说，锁对数据库而言显得尤其重要，也更加复杂。</p><p>​        相对其他数据库而言，MySQL的锁机制比较简单，其最 显著的特点是不同的<strong>存储引擎</strong>支持不同的锁机制。比如，MyISAM和MEMORY存储引擎采用的是表级锁（table-level locking）；InnoDB存储引擎既支持行级锁（row-level locking），也支持表级锁，但默认情况下是采用行级锁。 </p><p>​        <strong>表级锁：</strong>开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。<br>​        <strong>行级锁：</strong>开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。  </p><p>​        从上述特点可见，很难笼统地说哪种锁更好，只能就具体应用的特点来说哪种锁更合适！仅从锁的角度 来说：表级锁更适合于以查询为主，只有少量按索引条件更新数据的应用，如Web应用；而行级锁则更适合于有大量按索引条件并发更新少量不同数据，同时又有 并发查询的应用，如一些在线事务处理（OLTP）系统。 </p><h3 id="2、MyISAM表锁"><a href="#2、MyISAM表锁" class="headerlink" title="2、MyISAM表锁"></a>2、MyISAM表锁</h3><p>MySQL的表级锁有两种模式：<strong>表共享读锁（Table Read Lock）</strong>和<strong>表独占写锁（Table Write Lock）</strong>。  </p><p>对MyISAM表的读操作，不会阻塞其他用户对同一表的读请求，但会阻塞对同一表的写请求；对 MyISAM表的写操作，则会阻塞其他用户对同一表的读和写操作；MyISAM表的读操作与写操作之间，以及写操作之间是串行的！ </p><p>建表语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`mylock`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`NAME`</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=MyISAM <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`mylock`</span> (<span class="string">`id`</span>, <span class="string">`NAME`</span>) <span class="keyword">VALUES</span> (<span class="string">'1'</span>, <span class="string">'a'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`mylock`</span> (<span class="string">`id`</span>, <span class="string">`NAME`</span>) <span class="keyword">VALUES</span> (<span class="string">'2'</span>, <span class="string">'b'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`mylock`</span> (<span class="string">`id`</span>, <span class="string">`NAME`</span>) <span class="keyword">VALUES</span> (<span class="string">'3'</span>, <span class="string">'c'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`mylock`</span> (<span class="string">`id`</span>, <span class="string">`NAME`</span>) <span class="keyword">VALUES</span> (<span class="string">'4'</span>, <span class="string">'d'</span>);</span><br></pre></td></tr></table></figure><p><strong>MyISAM写锁阻塞读的案例：</strong></p><p>​        当一个线程获得对一个表的写锁之后，只有持有锁的线程可以对表进行更新操作。其他线程的读写操作都会等待，直到锁释放为止。</p><table><thead><tr><th align="center">session1</th><th align="center">session2</th></tr></thead><tbody><tr><td align="center">获取表的write锁定<br>lock table mylock write;</td><td align="center"></td></tr><tr><td align="center">当前session对表的查询，插入，更新操作都可以执行<br>select * from mylock;<br>insert into mylock values(5,’e’);</td><td align="center">当前session对表的查询会被阻塞<br>select * from mylock；</td></tr><tr><td align="center">释放锁：<br>unlock tables；</td><td align="center">当前session能够立刻执行，并返回对应结果</td></tr></tbody></table><p><strong>MyISAM读阻塞写的案例：</strong></p><p>​        一个session使用lock table给表加读锁，这个session可以锁定表中的记录，但更新和访问其他表都会提示错误，同时，另一个session可以查询表中的记录，但更新就会出现锁等待。</p><table><thead><tr><th align="center">session1</th><th align="center">session2</th></tr></thead><tbody><tr><td align="center">获得表的read锁定<br>lock table mylock read;</td><td align="center"></td></tr><tr><td align="center">当前session可以查询该表记录：<br>select * from mylock;</td><td align="center">当前session可以查询该表记录：<br>select * from mylock;</td></tr><tr><td align="center">当前session不能查询没有锁定的表<br>select * from person<br>Table ‘person’ was not locked with LOCK TABLES</td><td align="center">当前session可以查询或者更新未锁定的表<br>select * from mylock<br>insert into person values(1,’zhangsan’);</td></tr><tr><td align="center">当前session插入或者更新表会提示错误<br>insert into mylock values(6,’f’)<br>Table ‘mylock’ was locked with a READ lock and can’t be updated<br>update mylock set name=’aa’ where id = 1;<br>Table ‘mylock’ was locked with a READ lock and can’t be updated</td><td align="center">当前session插入数据会等待获得锁<br>insert into mylock values(6,’f’);</td></tr><tr><td align="center">释放锁<br>unlock tables;</td><td align="center">获得锁，更新成功</td></tr></tbody></table><p><strong>注意:</strong></p><p><strong>MyISAM在执行查询语句之前，会自动给涉及的所有表加读锁，在执行更新操作前，会自动给涉及的表加写锁，这个过程并不需要用户干预，因此用户一般不需要使用命令来显式加锁，上例中的加锁时为了演示效果。</strong></p><p><strong>MyISAM的并发插入问题</strong></p><p>MyISAM表的读和写是串行的，这是就总体而言的，在一定条件下，MyISAM也支持查询和插入操作的并发执行</p><table><thead><tr><th align="center">session1</th><th align="center">session2</th></tr></thead><tbody><tr><td align="center">获取表的read local锁定<br>lock table mylock read local</td><td align="center"></td></tr><tr><td align="center">当前session不能对表进行更新或者插入操作<br>insert into mylock values(6,’f’)<br>Table ‘mylock’ was locked with a READ lock and can’t be updated<br>update mylock set name=’aa’ where id = 1;<br>Table ‘mylock’ was locked with a READ lock and can’t be updated</td><td align="center">其他session可以查询该表的记录<br>select* from mylock</td></tr><tr><td align="center">当前session不能查询没有锁定的表<br>select * from person<br>Table ‘person’ was not locked with LOCK TABLES</td><td align="center">其他session可以进行插入操作，但是更新会阻塞<br>update mylock set name = ‘aa’ where id = 1;</td></tr><tr><td align="center">当前session不能访问其他session插入的记录；</td><td align="center"></td></tr><tr><td align="center">释放锁资源：unlock tables</td><td align="center">当前session获取锁，更新操作完成</td></tr><tr><td align="center">当前session可以查看其他session插入的记录</td><td align="center"></td></tr></tbody></table><p> 可以通过检查table_locks_waited和table_locks_immediate状态变量来分析系统上的表锁定争夺： </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show status like 'table%';</span><br><span class="line">+<span class="comment">-----------------------+-------+</span></span><br><span class="line">| Variable_name         | Value |</span><br><span class="line">+<span class="comment">-----------------------+-------+</span></span><br><span class="line">| Table_locks_immediate | 352   |</span><br><span class="line">| Table_locks_waited    | 2     |</span><br><span class="line">+<span class="comment">-----------------------+-------+</span></span><br><span class="line"><span class="comment">--如果Table_locks_waited的值比较高，则说明存在着较严重的表级锁争用情况。</span></span><br></pre></td></tr></table></figure><h3 id="3、InnoDB锁"><a href="#3、InnoDB锁" class="headerlink" title="3、InnoDB锁"></a>3、InnoDB锁</h3><p><strong>1、事务及其ACID属性</strong></p><p>事务是由一组SQL语句组成的逻辑处理单元，事务具有4属性，通常称为事务的ACID属性。</p><p>原子性（Actomicity）：事务是一个原子操作单元，其对数据的修改，要么全都执行，要么全都不执行。<br>一致性（Consistent）：在事务开始和完成时，数据都必须保持一致状态。<br>隔离性（Isolation）：数据库系统提供一定的隔离机制，保证事务在不受外部并发操作影响的“独立”环境执行。<br>持久性（Durable）：事务完成之后，它对于数据的修改是永久性的，即使出现系统故障也能够保持。</p><p><strong>2、并发事务带来的问题</strong></p><p>相对于串行处理来说，并发事务处理能大大增加数据库资源的利用率，提高数据库系统的事务吞吐量，从而可以支持更多用户的并发操作，但与此同时，会带来一下问题：</p><p><strong>脏读</strong>： 一个事务正在对一条记录做修改，在这个事务并提交前，这条记录的数据就处于不一致状态；这时，另一个事务也来读取同一条记录，如果不加控制，第二个事务读取了这些“脏”的数据，并据此做进一步的处理，就会产生未提交的数据依赖关系。这种现象被形象地叫做“脏读” </p><p><strong>不可重复读</strong>：一个事务在读取某些数据已经发生了改变、或某些记录已经被删除了！这种现象叫做“不可重复读”。 </p><p><strong>幻读</strong>： 一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，这种现象就称为“幻读” </p><p>上述出现的问题都是数据库读一致性的问题，可以通过事务的隔离机制来进行保证。</p><p>数据库的事务隔离越严格，并发副作用就越小，但付出的代价也就越大，因为事务隔离本质上就是使事务在一定程度上串行化，需要根据具体的业务需求来决定使用哪种隔离级别</p><table><thead><tr><th align="center"></th><th align="center">脏读</th><th align="center">不可重复读</th><th align="center">幻读</th></tr></thead><tbody><tr><td align="center">read uncommitted</td><td align="center">√</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="center">read committed</td><td align="center"></td><td align="center">√</td><td align="center">√</td></tr><tr><td align="center">repeatable read</td><td align="center"></td><td align="center"></td><td align="center">√</td></tr><tr><td align="center">serializable</td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><p> 可以通过检查InnoDB_row_lock状态变量来分析系统上的行锁的争夺情况： </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show status like 'innodb_row_lock%';</span><br><span class="line">+<span class="comment">-------------------------------+-------+</span></span><br><span class="line">| Variable_name                 | Value |</span><br><span class="line">+<span class="comment">-------------------------------+-------+</span></span><br><span class="line">| Innodb_row_lock_current_waits | 0     |</span><br><span class="line">| Innodb_row_lock_time          | 18702 |</span><br><span class="line">| Innodb_row_lock_time_avg      | 18702 |</span><br><span class="line">| Innodb_row_lock_time_max      | 18702 |</span><br><span class="line">| Innodb_row_lock_waits         | 1     |</span><br><span class="line">+<span class="comment">-------------------------------+-------+</span></span><br><span class="line"><span class="comment">--如果发现锁争用比较严重，如InnoDB_row_lock_waits和InnoDB_row_lock_time_avg的值比较高</span></span><br></pre></td></tr></table></figure><p><strong>3、InnoDB的行锁模式及加锁方法</strong></p><p>​        <strong>共享锁（s）</strong>：又称读锁。允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。若事务T对数据对象A加上S锁，则事务T可以读A但不能修改A，其他事务只能再对A加S锁，而不能加X锁，直到T释放A上的S锁。这保证了其他事务可以读A，但在T释放A上的S锁之前不能对A做任何修改。<br>​        <strong>排他锁（x）</strong>：又称写锁。允许获取排他锁的事务更新数据，阻止其他事务取得相同的数据集共享读锁和排他写锁。若事务T对数据对象A加上X锁，事务T可以读A也可以修改A，其他事务不能再对A加任何锁，直到T释放A上的锁。</p><p>​        mysql InnoDB引擎默认的修改数据语句：<strong>update,delete,insert都会自动给涉及到的数据加上排他锁，select语句默认不会加任何锁类型</strong>，如果加排他锁可以使用select …for update语句，加共享锁可以使用select … lock in share mode语句。<strong>所以加过排他锁的数据行在其他事务种是不能修改数据的，也不能通过for update和lock in share mode锁的方式查询数据，但可以直接通过select …from…查询数据，因为普通查询没有任何锁机制。</strong> </p><p><strong>InnoDB行锁实现方式</strong></p><p>​        InnoDB行锁是通过给<strong>索引</strong>上的索引项加锁来实现的，这一点MySQL与Oracle不同，后者是通过在数据块中对相应数据行加锁来实现的。InnoDB这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB才使用行级锁，<strong>否则，InnoDB将使用表锁！</strong>  </p><p>1、在不通过索引条件查询的时候，innodb使用的是表锁而不是行锁</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tab_no_index(<span class="keyword">id</span> <span class="built_in">int</span>,<span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">10</span>)) <span class="keyword">engine</span>=<span class="keyword">innodb</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tab_no_index <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'1'</span>),(<span class="number">2</span>,<span class="string">'2'</span>),(<span class="number">3</span>,<span class="string">'3'</span>),(<span class="number">4</span>,<span class="string">'4'</span>);</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">session1</th><th align="center">session2</th></tr></thead><tbody><tr><td align="center">set autocommit=0<br>select * from tab_no_index where id = 1;</td><td align="center">set autocommit=0<br>select * from tab_no_index where id =2</td></tr><tr><td align="center">select * from tab_no_index where id = 1 for update</td><td align="center"></td></tr><tr><td align="center"></td><td align="center">select * from tab_no_index where id = 2 for update;</td></tr></tbody></table><p>session1只给一行加了排他锁，但是session2在请求其他行的排他锁的时候，会出现锁等待。原因是在没有索引的情况下，innodb只能使用表锁。</p><p>2、创建带索引的表进行条件查询，innodb使用的是行锁</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tab_with_index(<span class="keyword">id</span> <span class="built_in">int</span>,<span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">10</span>)) <span class="keyword">engine</span>=<span class="keyword">innodb</span>;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> tab_with_index <span class="keyword">add</span> <span class="keyword">index</span> <span class="keyword">id</span>(<span class="keyword">id</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tab_with_index <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'1'</span>),(<span class="number">2</span>,<span class="string">'2'</span>),(<span class="number">3</span>,<span class="string">'3'</span>),(<span class="number">4</span>,<span class="string">'4'</span>);</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">session1</th><th align="center">session2</th></tr></thead><tbody><tr><td align="center">set autocommit=0<br>select * from tab_with_indexwhere id = 1;</td><td align="center">set autocommit=0<br>select * from tab_with_indexwhere id =2</td></tr><tr><td align="center">select * from tab_with_indexwhere id = 1 for update</td><td align="center"></td></tr><tr><td align="center"></td><td align="center">select * from tab_with_indexwhere id = 2 for update;</td></tr></tbody></table><p>3、由于mysql的行锁是针对索引加的锁，不是针对记录加的锁，所以虽然是访问不同行的记录，但是如果是使用相同的索引键，是会出现冲突的。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> tab_with_index <span class="keyword">drop</span> <span class="keyword">index</span> <span class="keyword">id</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tab_with_index  <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'4'</span>);</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">session1</th><th align="center">session2</th></tr></thead><tbody><tr><td align="center">set autocommit=0</td><td align="center">set autocommit=0</td></tr><tr><td align="center">select * from tab_with_index where id = 1 and name=’1’ for update</td><td align="center"></td></tr><tr><td align="center"></td><td align="center">select * from tab_with_index where id = 1 and name=’4’ for update<br>虽然session2访问的是和session1不同的记录，但是因为使用了相同的索引，所以需要等待锁</td></tr></tbody></table><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>对于MyISAM的表锁，主要讨论了以下几点：</strong><br>（1）共享读锁（S）之间是兼容的，但共享读锁（S）与排他写锁（X）之间，以及排他写锁（X）之间是互斥的，也就是说读和写是串行的。<br>（2）在一定条件下，MyISAM允许查询和插入并发执行，我们可以利用这一点来解决应用中对同一表查询和插入的锁争用问题。<br>（3）MyISAM默认的锁调度机制是写优先，这并不一定适合所有应用，用户可以通过设置LOW_PRIORITY_UPDATES参数，或在INSERT、UPDATE、DELETE语句中指定LOW_PRIORITY选项来调节读写锁的争用。<br>（4）由于表锁的锁定粒度大，读写之间又是串行的，因此，如果更新操作较多，MyISAM表可能会出现严重的锁等待，可以考虑采用InnoDB表来减少锁冲突。</p><p><strong>对于InnoDB表，本文主要讨论了以下几项内容：</strong><br>（1）InnoDB的行锁是基于索引实现的，如果不通过索引访问数据，InnoDB会使用表锁。<br>（2）在不同的隔离级别下，InnoDB的锁机制和一致性读策略不同。</p><p>在了解InnoDB锁特性后，用户可以通过设计和SQL调整等措施减少锁冲突和死锁，包括：</p><ul><li>尽量使用较低的隔离级别； 精心设计索引，并尽量使用索引访问数据，使加锁更精确，从而减少锁冲突的机会；</li><li>选择合理的事务大小，小事务发生锁冲突的几率也更小；</li><li>给记录集显式加锁时，最好一次性请求足够级别的锁。比如要修改数据的话，最好直接申请排他锁，而不是先申请共享锁，修改时再请求排他锁，这样容易产生死锁；</li><li>不同的程序访问一组表时，应尽量约定以相同的顺序访问各表，对一个表而言，尽可能以固定的顺序存取表中的行。这样可以大大减少死锁的机会；</li><li>尽量用相等条件访问数据，这样可以避免间隙锁对并发插入的影响； 不要申请超过实际需要的锁级别；除非必须，查询时不要显示加锁；</li><li>对于一些特定的事务，可以使用表锁来提高处理速度或减少死锁的可能。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL的MVCC原理及使用</title>
      <link href="/2020/08/03/MySQL%E7%9A%84MVCC%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BD%BF%E7%94%A8/"/>
      <url>/2020/08/03/MySQL%E7%9A%84MVCC%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="Mysql中MVCC的使用及原理"><a href="#Mysql中MVCC的使用及原理" class="headerlink" title="Mysql中MVCC的使用及原理"></a>Mysql中MVCC的使用及原理</h2><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>数据库默认隔离级别：<strong>RR（Repeatable Read，可重复读），MVCC主要适用于Mysql的RC,RR隔离级别</strong></p><p>创建一张存储引擎为testmvcc的表，sql为:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE testmvcc (</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> id int(11) DEFAULT NULL,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> name varchar(11) DEFAULT NULL</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure><h3 id="什么是MVCC"><a href="#什么是MVCC" class="headerlink" title="什么是MVCC?"></a>什么是MVCC?</h3><p>英文全称为Multi-Version Concurrency Control,翻译为中文即 多版本并发控制。在小编看来，他无非就是乐观锁的一种实现方式。在Java编程中，如果把乐观锁看成一个接口，MVCC便是这个接口的一个实现类而已。</p><p><img src="/2020/08/03/MySQL%E7%9A%84MVCC%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BD%BF%E7%94%A8/aHR0cDovL3A5LnBzdGF0cC5jb20vbGFyZ2UvcGdjLWltYWdlLzE1MzYyODkwMzA5MDRjMGRmMzFkYjM2" alt="Mysql中MVCC的使用及原理详解"></p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>1.MVCC其实广泛应用于数据库技术，像Oracle,PostgreSQL等也引入了该技术，即适用范围广</p><p>2.MVCC并没有简单的使用数据库的行锁，而是使用了行级锁，row_level_lock,而非InnoDB中的innodb_row_lock.</p><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p>MVCC的实现，通过保存数据在某个时间点的快照来实现的。这意味着一个事务无论运行多长时间，在同一个事务里能够看到数据一致的视图。根据事务开始的时间不同，同时也意味着在同一个时刻不同事务看到的相同表里的数据可能是不同的。</p><h3 id="基本特征"><a href="#基本特征" class="headerlink" title="基本特征"></a>基本特征</h3><ul><li>每行数据都存在一个版本，每次数据更新时都更新该版本。</li><li>修改时Copy出当前版本随意修改，各个事务之间无干扰。</li><li>保存时比较版本号，如果成功（commit），则覆盖原记录；失败则放弃copy（rollback）</li></ul><h3 id="InnoDB存储引擎MVCC的实现策略"><a href="#InnoDB存储引擎MVCC的实现策略" class="headerlink" title="InnoDB存储引擎MVCC的实现策略"></a>InnoDB存储引擎MVCC的实现策略</h3><p>在每一行数据中额外保存两个隐藏的列：当前行创建时的版本号和删除时的版本号（可能为空，其实还有一列称为回滚指针，用于事务回滚，不在本文范畴）。这里的版本号并不是实际的时间值，而是系统版本号。每开始新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询每行记录的版本号进行比较。</p><p>每个事务又有自己的版本号，这样事务内执行CRUD操作时，就通过版本号的比较来达到数据版本控制的目的。</p><h3 id="MVCC下InnoDB的增删查改是怎么work的"><a href="#MVCC下InnoDB的增删查改是怎么work的" class="headerlink" title="MVCC下InnoDB的增删查改是怎么work的"></a>MVCC下InnoDB的增删查改是怎么work的</h3><p>1、插入数据（insert）:记录的版本号即当前事务的版本号</p><p>执行一条数据语句：insert into testmvcc values(1,”test”);</p><p>假设事务id为1，那么插入后的数据行如下：</p><p><img src="/2020/08/03/MySQL%E7%9A%84MVCC%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BD%BF%E7%94%A8/aHR0cDovL3A5OC5wc3RhdHAuY29tL2xhcmdlL3BnYy1pbWFnZS8xNTM2Mjg2MzkyMDExMzMyZGM3OTk4MA" alt="Mysql中MVCC的使用及原理详解"></p><p>2、在更新操作的时候，采用的是先标记旧的那行记录为已删除，并且删除版本号是事务版本号，然后插入一行新的记录的方式。</p><p>比如，针对上面那行记录，事务Id为2 要把name字段更新</p><p>update table set name= ‘new_value’ where id=1;</p><p><img src="/2020/08/03/MySQL%E7%9A%84MVCC%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BD%BF%E7%94%A8/aHR0cDovL3A5OC5wc3RhdHAuY29tL2xhcmdlL3BnYy1pbWFnZS8xNTM2Mjg2NDc5MDI2MmE4NTg5NmU1NQ" alt="Mysql中MVCC的使用及原理详解"></p><p>3、删除操作的时候，就把事务版本号作为删除版本号。比如</p><p>delete from table where id=1;</p><p><img src="/2020/08/03/MySQL%E7%9A%84MVCC%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BD%BF%E7%94%A8/aHR0cDovL3A5LnBzdGF0cC5jb20vbGFyZ2UvcGdjLWltYWdlLzE1MzYyODY1MzI0MTUwZGZiYzdiZjY2" alt="Mysql中MVCC的使用及原理详解"></p><p>4、查询操作：</p><p>从上面的描述可以看到，在查询时要符合以下两个条件的记录才能被事务查询出来：</p><p>1) 删除版本号未指定或者大于当前事务版本号，即查询事务开启后确保读取的行未被删除。(即上述事务id为2的事务查询时，依然能读取到事务id为3所删除的数据行)</p><p>2) 创建版本号 小于或者等于 当前事务版本号 ，就是说记录创建是在当前事务中（等于的情况）或者在当前事务启动之前的其他事物进行的insert。</p><p>（即事务id为2的事务只能读取到create version&lt;=2的已提交的事务的数据集）</p><blockquote><p>补充：</p><p>1.MVCC手段只适用于Msyql隔离级别中的读已提交（Read committed）和可重复读（Repeatable Read）.</p><p>2.Read uncimmitted由于存在脏读，即能读到未提交事务的数据行，所以不适用MVCC.</p><p>原因是MVCC的创建版本和删除版本只要在事务提交后才会产生。</p><p>3.串行化由于是会对所涉及到的表加锁，并非行锁，自然也就不存在行的版本控制问题。</p><p>4.通过以上总结，可知，MVCC主要作用于事务性的，有行锁控制的数据库模型。</p></blockquote><h3 id="关于Mysql中MVCC的总结"><a href="#关于Mysql中MVCC的总结" class="headerlink" title="关于Mysql中MVCC的总结"></a>关于Mysql中MVCC的总结</h3><p>客观上，我们认为他就是乐观锁的一整实现方式，就是每行都有版本号，保存时根据版本号决定是否成功。</p><p>了解乐观锁的小伙伴们都知道，其主要依靠版本控制，即消除锁定，二者相互矛盾，so从某种意义上来说，Mysql的MVCC并非真正的MVCC，他只是借用MVCC的名号实现了读的非阻塞而已。</p>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>异常及常用类知识点</title>
      <link href="/2020/08/03/%E5%BC%82%E5%B8%B8%E5%8F%8A%E5%B8%B8%E7%94%A8%E7%B1%BB%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
      <url>/2020/08/03/%E5%BC%82%E5%B8%B8%E5%8F%8A%E5%B8%B8%E7%94%A8%E7%B1%BB%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">throws:声明异常</span></span><br><span class="line"><span class="comment">* 在异常情况出现的时候，可以使用try...catch...finally的方式对异常进行处理，除此之外，可以将异常向外跑出，由外部的进行处理</span></span><br><span class="line"><span class="comment">*   1、在方法调用过程中，可以存在N多个方法之间的调用，此时假如每个方法中都包含了异常情况</span></span><br><span class="line"><span class="comment">*       那么就需要在每个方法中都进行try。。catch，另外一种比较简单的方式，就是在方法的最外层调用处理一次即可</span></span><br><span class="line"><span class="comment">*       使用throws的方法，对所有执行过程中的所有方法出现的异常进行统一集中处理</span></span><br><span class="line"><span class="comment">*   2、如何判断是使用throws还是使用try...catch..</span></span><br><span class="line"><span class="comment">*       最稳妥的方式是在每个方法中都进行异常的处理</span></span><br><span class="line"><span class="comment">*       偷懒的方式是判断在整个调用的过程中，外层的调用方法是否有对异常的处理，如果有，直接使用throws,如果没有</span></span><br><span class="line"><span class="comment">*           那么就要使用try...catch...</span></span><br><span class="line"><span class="comment">* throw：抛出异常</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* */</span></span><br></pre></td></tr></table></figure><p><img src="/2020/08/03/%E5%BC%82%E5%B8%B8%E5%8F%8A%E5%B8%B8%E7%94%A8%E7%B1%BB%E7%9F%A5%E8%AF%86%E7%82%B9/image-20200513140433429.png" alt="image-20200513140433429"></p><p><img src="/2020/08/03/%E5%BC%82%E5%B8%B8%E5%8F%8A%E5%B8%B8%E7%94%A8%E7%B1%BB%E7%9F%A5%E8%AF%86%E7%82%B9/image-20200513140502888.png" alt="image-20200513140502888"></p><p><img src="/2020/08/03/%E5%BC%82%E5%B8%B8%E5%8F%8A%E5%B8%B8%E7%94%A8%E7%B1%BB%E7%9F%A5%E8%AF%86%E7%82%B9/image-20200513140553620.png" alt="image-20200513140553620"></p><p><img src="/2020/08/03/%E5%BC%82%E5%B8%B8%E5%8F%8A%E5%B8%B8%E7%94%A8%E7%B1%BB%E7%9F%A5%E8%AF%86%E7%82%B9/image-20200513140731558.png" alt="image-20200513140731558"></p><p><img src="/2020/08/03/%E5%BC%82%E5%B8%B8%E5%8F%8A%E5%B8%B8%E7%94%A8%E7%B1%BB%E7%9F%A5%E8%AF%86%E7%82%B9/image-20200513140744790.png" alt="image-20200513140744790"></p><h6 id="常用类"><a href="#常用类" class="headerlink" title="常用类"></a>常用类</h6><p><img src="/2020/08/03/%E5%BC%82%E5%B8%B8%E5%8F%8A%E5%B8%B8%E7%94%A8%E7%B1%BB%E7%9F%A5%E8%AF%86%E7%82%B9/image-20200513140825045.png" alt="image-20200513140825045"></p><p><img src="/2020/08/03/%E5%BC%82%E5%B8%B8%E5%8F%8A%E5%B8%B8%E7%94%A8%E7%B1%BB%E7%9F%A5%E8%AF%86%E7%82%B9/image-20200513140834429.png" alt="image-20200513140834429"></p><p><img src="/2020/08/03/%E5%BC%82%E5%B8%B8%E5%8F%8A%E5%B8%B8%E7%94%A8%E7%B1%BB%E7%9F%A5%E8%AF%86%E7%82%B9/image-20200513140904488.png" alt="image-20200513140904488"></p><h5 id="String"><a href="#String" class="headerlink" title="String"></a>String</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 注意：常量池在1.7之后放置在了堆空间之中</span></span><br><span class="line"><span class="comment">*       字符串的使用：</span></span><br><span class="line"><span class="comment">*           1、创建</span></span><br><span class="line"><span class="comment">*               String str = "abc";</span></span><br><span class="line"><span class="comment">*               String str2 = new String("abc");</span></span><br><span class="line"><span class="comment">*               两种方式都可以用，只不过第一种使用比较多</span></span><br><span class="line"><span class="comment">*           2、字符串的本质</span></span><br><span class="line"><span class="comment">*               字符串的本质是字符数组或者叫做字符序列</span></span><br><span class="line"><span class="comment">*               String类使用final修饰，不可以被继承</span></span><br><span class="line"><span class="comment">*               使用equals方法比较的是字符数组的每一个位置的值</span></span><br><span class="line"><span class="comment">*               String是一个不可变对象</span></span><br><span class="line"><span class="comment">* */</span></span><br></pre></td></tr></table></figure><p><img src="/2020/08/03/%E5%BC%82%E5%B8%B8%E5%8F%8A%E5%B8%B8%E7%94%A8%E7%B1%BB%E7%9F%A5%E8%AF%86%E7%82%B9/image-20200513140925492.png" alt="image-20200513140925492"></p><p><img src="/2020/08/03/%E5%BC%82%E5%B8%B8%E5%8F%8A%E5%B8%B8%E7%94%A8%E7%B1%BB%E7%9F%A5%E8%AF%86%E7%82%B9/image-20200513140955701.png" alt="image-20200513140955701"></p><p><img src="/2020/08/03/%E5%BC%82%E5%B8%B8%E5%8F%8A%E5%B8%B8%E7%94%A8%E7%B1%BB%E7%9F%A5%E8%AF%86%E7%82%B9/image-20200513141008463.png" alt="image-20200513141008463"></p><p><img src="/2020/08/03/%E5%BC%82%E5%B8%B8%E5%8F%8A%E5%B8%B8%E7%94%A8%E7%B1%BB%E7%9F%A5%E8%AF%86%E7%82%B9/image-20200513141134567.png" alt="image-20200513141134567"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 可变字符串</span></span><br><span class="line"><span class="comment">*   StringBuffer：线程安全，效率低</span></span><br><span class="line"><span class="comment">*   StringBuilder: 线程不安全，效率高</span></span><br><span class="line"><span class="comment">* */</span></span><br></pre></td></tr></table></figure><p><img src="/2020/08/03/%E5%BC%82%E5%B8%B8%E5%8F%8A%E5%B8%B8%E7%94%A8%E7%B1%BB%E7%9F%A5%E8%AF%86%E7%82%B9/image-20200513141153565.png" alt="image-20200513141153565"></p><p><img src="/2020/08/03/%E5%BC%82%E5%B8%B8%E5%8F%8A%E5%B8%B8%E7%94%A8%E7%B1%BB%E7%9F%A5%E8%AF%86%E7%82%B9/image-20200513141202381.png" alt="image-20200513141202381"></p><p><img src="/2020/08/03/%E5%BC%82%E5%B8%B8%E5%8F%8A%E5%B8%B8%E7%94%A8%E7%B1%BB%E7%9F%A5%E8%AF%86%E7%82%B9/image-20200513141242100.png" alt="image-20200513141242100"></p><p><img src="/2020/08/03/%E5%BC%82%E5%B8%B8%E5%8F%8A%E5%B8%B8%E7%94%A8%E7%B1%BB%E7%9F%A5%E8%AF%86%E7%82%B9/image-20200513141249790.png" alt="image-20200513141249790"></p><p><img src="/2020/08/03/%E5%BC%82%E5%B8%B8%E5%8F%8A%E5%B8%B8%E7%94%A8%E7%B1%BB%E7%9F%A5%E8%AF%86%E7%82%B9/image-20200513141258922.png" alt="image-20200513141258922"></p><h5 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h5><p><img src="/2020/08/03/%E5%BC%82%E5%B8%B8%E5%8F%8A%E5%B8%B8%E7%94%A8%E7%B1%BB%E7%9F%A5%E8%AF%86%E7%82%B9/image-20200513141313248.png" alt="image-20200513141313248"></p><p><img src="/2020/08/03/%E5%BC%82%E5%B8%B8%E5%8F%8A%E5%B8%B8%E7%94%A8%E7%B1%BB%E7%9F%A5%E8%AF%86%E7%82%B9/image-20200513141321073.png" alt="image-20200513141321073"></p><p><img src="/2020/08/03/%E5%BC%82%E5%B8%B8%E5%8F%8A%E5%B8%B8%E7%94%A8%E7%B1%BB%E7%9F%A5%E8%AF%86%E7%82%B9/image-20200513141328008.png" alt="image-20200513141328008"></p><p><img src="/2020/08/03/%E5%BC%82%E5%B8%B8%E5%8F%8A%E5%B8%B8%E7%94%A8%E7%B1%BB%E7%9F%A5%E8%AF%86%E7%82%B9/image-20200513141333994.png" alt="image-20200513141333994"></p><p><img src="/2020/08/03/%E5%BC%82%E5%B8%B8%E5%8F%8A%E5%B8%B8%E7%94%A8%E7%B1%BB%E7%9F%A5%E8%AF%86%E7%82%B9/image-20200513141353294.png" alt="image-20200513141353294"></p><p><img src="/2020/08/03/%E5%BC%82%E5%B8%B8%E5%8F%8A%E5%B8%B8%E7%94%A8%E7%B1%BB%E7%9F%A5%E8%AF%86%E7%82%B9/image/%E5%BC%82%E5%B8%B8%E5%92%8C%E5%B8%B8%E7%94%A8%E7%B1%BB/image-20200513141358822.png" alt="image-20200513141358822"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java SE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>集合框架知识点整理</title>
      <link href="/2020/08/03/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
      <url>/2020/08/03/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h5 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* java集合框架：</span></span><br><span class="line"><span class="comment">*   Collection：存放的是单一值</span></span><br><span class="line"><span class="comment">*       特点：</span></span><br><span class="line"><span class="comment">*           1、可以存放不同类型的数据，而数组只能存放固定类型的数据</span></span><br><span class="line"><span class="comment">*           2、当使用arraylist子类实现的时候，初始化的长度是10，当长度不够的时候会自动进行扩容操作</span></span><br><span class="line"><span class="comment">*       api方法：</span></span><br><span class="line"><span class="comment">*           增加数据的方法</span></span><br><span class="line"><span class="comment">*           add：要求必须传入的参数是Object对象，因此当写入基本数据类型的时候，包含了自动拆箱和自动装箱的过程</span></span><br><span class="line"><span class="comment">*           addAll:添加另一个集合的元素到此集合中</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*           删除数据的方法</span></span><br><span class="line"><span class="comment">*           clear:只是清空集合中的元素，但是此集合对象并没有被回收</span></span><br><span class="line"><span class="comment">*           remove:删除指定元素</span></span><br><span class="line"><span class="comment">*           removeAll：删除集合元素</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*           查询数据的方法</span></span><br><span class="line"><span class="comment">*           contains:判断集合中是否包含指定的元素值</span></span><br><span class="line"><span class="comment">*           containsAll:判断此集合中是否包含另一个集合</span></span><br><span class="line"><span class="comment">*           isEmpty:判断集合是否等于空</span></span><br><span class="line"><span class="comment">*           retainAll:若集合中拥有另一个集合的所有元素，返回true，否则返回false</span></span><br><span class="line"><span class="comment">*           size:返回当前集合的大小</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*           //集合转数组的操作</span></span><br><span class="line"><span class="comment">*           toArray:将集合转换成数组</span></span><br><span class="line"><span class="comment">* */</span></span><br></pre></td></tr></table></figure><p><img src="/2020/08/03/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E7%9F%A5%E8%AF%86%E7%82%B9/image-20200514121720326.png" alt="image-20200514121720326"></p><p><img src="/2020/08/03/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E7%9F%A5%E8%AF%86%E7%82%B9/image-20200514121734482.png" alt="image-20200514121734482"></p><p><img src="/2020/08/03/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E7%9F%A5%E8%AF%86%E7%82%B9/image-20200514121747635.png" alt="image-20200514121747635"></p><h5 id="List"><a href="#List" class="headerlink" title="List"></a>List</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* java集合框架：</span></span><br><span class="line"><span class="comment">*   List：存放的是单一值</span></span><br><span class="line"><span class="comment">*       特点：</span></span><br><span class="line"><span class="comment">*           1、可以存放不同类型的数据，而数组只能存放固定类型的数据</span></span><br><span class="line"><span class="comment">*           2、当使用arraylist子类实现的时候，初始化的长度是10，当长度不够的时候会自动进行扩容操作</span></span><br><span class="line"><span class="comment">*       api方法：</span></span><br><span class="line"><span class="comment">*           增加数据的方法</span></span><br><span class="line"><span class="comment">*           add：要求必须传入的参数是Object对象，因此当写入基本数据类型的时候，包含了自动拆箱和自动装箱的过程</span></span><br><span class="line"><span class="comment">*           addAll:添加另一个集合的元素到此集合中</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*           删除数据的方法</span></span><br><span class="line"><span class="comment">*           clear:只是清空集合中的元素，但是此集合对象并没有被回收</span></span><br><span class="line"><span class="comment">*           remove:删除指定元素</span></span><br><span class="line"><span class="comment">*           removeAll：删除集合元素</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*           查询数据的方法</span></span><br><span class="line"><span class="comment">*           contains:判断集合中是否包含指定的元素值</span></span><br><span class="line"><span class="comment">*           containsAll:判断此集合中是否包含另一个集合</span></span><br><span class="line"><span class="comment">*           isEmpty:判断集合是否等于空</span></span><br><span class="line"><span class="comment">*           retainAll:若集合中拥有另一个集合的所有元素，返回true，否则返回false</span></span><br><span class="line"><span class="comment">*           size:返回当前集合的大小</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*           //集合转数组的操作</span></span><br><span class="line"><span class="comment">*           toArray:将集合转换成数组</span></span><br><span class="line"><span class="comment">* */</span></span><br></pre></td></tr></table></figure><p><img src="/2020/08/03/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E7%9F%A5%E8%AF%86%E7%82%B9/image-20200514121809284.png" alt="image-20200514121809284"></p><p><img src="/2020/08/03/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E7%9F%A5%E8%AF%86%E7%82%B9/image-20200514121818097.png" alt="image-20200514121818097"></p><h6 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 在java代码中包含三种循环的方式</span></span><br><span class="line"><span class="comment">*   do...while</span></span><br><span class="line"><span class="comment">*   while</span></span><br><span class="line"><span class="comment">*   for</span></span><br><span class="line"><span class="comment">* 还有一种增强for循环的方式，可以简化循环的编写</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*   所有的集合类都默认实现了Iterable的接口，实现此接口意味着具备了增强for循环的能力，也就是for-each</span></span><br><span class="line"><span class="comment">*      增强for循环本质上使用的也是iterator的功能</span></span><br><span class="line"><span class="comment">*      方法：</span></span><br><span class="line"><span class="comment">*               iterator()</span></span><br><span class="line"><span class="comment">*               foreach()</span></span><br><span class="line"><span class="comment">*   在iterator的方法中，要求返回一个Iterator的接口子类实例对象</span></span><br><span class="line"><span class="comment">*       此接口中包含了</span></span><br><span class="line"><span class="comment">*               hasNext()</span></span><br><span class="line"><span class="comment">*               next()</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*   在使用iterator进行迭代的过程中如果删除其中的某个元素会报错，并发操作异常，因此</span></span><br><span class="line"><span class="comment">*       如果遍历的同时需要修改元素，建议使用listIterator（），</span></span><br><span class="line"><span class="comment">*   ListIterator迭代器提供了向前和向后两种遍历的方式</span></span><br><span class="line"><span class="comment">*       始终是通过cursor和lastret的指针来获取元素值及向下的遍历索引</span></span><br><span class="line"><span class="comment">*       当使用向前遍历的时候必须要保证指针在迭代器的结果，否则无法获取结果值</span></span><br><span class="line"><span class="comment">* */</span></span><br></pre></td></tr></table></figure><p><img src="/2020/08/03/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E7%9F%A5%E8%AF%86%E7%82%B9/image-20200514121910889.png" alt="image-20200514121910889"></p><p><img src="/2020/08/03/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E7%9F%A5%E8%AF%86%E7%82%B9/image-20200514121922127.png" alt="image-20200514121922127"></p><p><img src="/2020/08/03/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E7%9F%A5%E8%AF%86%E7%82%B9/image-20200514122001163.png" alt="image-20200514122001163"></p><h6 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h6><p><img src="/2020/08/03/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E7%9F%A5%E8%AF%86%E7%82%B9/image-20200514122038056.png" alt="image-20200514122038056"></p><p><img src="/2020/08/03/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E7%9F%A5%E8%AF%86%E7%82%B9/image-20200514122050646.png" alt="image-20200514122050646"></p><h6 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *      1、Vector也是List接口的一个子类实现</span></span><br><span class="line"><span class="comment"> *      2、Vector跟ArrayList一样，底层都是使用数组进行实现的</span></span><br><span class="line"><span class="comment"> *      3、面试经常问区别：</span></span><br><span class="line"><span class="comment"> *          （1）ArrayList是线程不安全的，效率高，Vector是线程安全的效率低</span></span><br><span class="line"><span class="comment"> *          （2）ArrayList在进行扩容的时候，是扩容1.5倍，Vector扩容的时候扩容原来的2倍</span></span><br><span class="line"><span class="comment"> *</span></span><br></pre></td></tr></table></figure><h5 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*   1、set中存放的是无序，唯一的数据</span></span><br><span class="line"><span class="comment">*   2、set不可以通过下标获取对应位置的元素的值，因为无序的特点</span></span><br><span class="line"><span class="comment">*   3、使用treeset底层的实现是treemap,利用红黑树来进行实现</span></span><br><span class="line"><span class="comment">*   4、设置元素的时候，如果是自定义对象，会查找对象中的equals和hashcode的方法，如果没有，比较的是地址</span></span><br><span class="line"><span class="comment">*   5、树中的元素是要默认进行排序操作的，如果是基本数据类型，自动比较，如果是引用类型的话，需要自定义比较器</span></span><br><span class="line"><span class="comment">*       比较器分类：</span></span><br><span class="line"><span class="comment">*         内部比较器</span></span><br><span class="line"><span class="comment">*               定义在元素的类中，通过实现comparable接口来进行实现</span></span><br><span class="line"><span class="comment">*         外部比较器</span></span><br><span class="line"><span class="comment">*               定义在当前类中，通过实现comparator接口来实现，但是要将该比较器传递到集合中</span></span><br><span class="line"><span class="comment">*         注意：外部比较器可以定义成一个工具类，此时所有需要比较的规则如果一致的话，可以复用，而</span></span><br><span class="line"><span class="comment">*               内部比较器只有在存储当前对象的时候才可以使用</span></span><br><span class="line"><span class="comment">*               如果两者同时存在，使用外部比较器</span></span><br><span class="line"><span class="comment">*               当使用比较器的时候，不会调用equals方法</span></span><br><span class="line"><span class="comment">* */</span></span><br></pre></td></tr></table></figure><p><img src="/2020/08/03/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E7%9F%A5%E8%AF%86%E7%82%B9/image-20200514122123267.png" alt="image-20200514122123267"></p><h6 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h6><p><img src="/2020/08/03/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E7%9F%A5%E8%AF%86%E7%82%B9/image-20200514122143284.png" alt="image-20200514122143284"></p><p><img src="/2020/08/03/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E7%9F%A5%E8%AF%86%E7%82%B9/image-20200514122235681.png" alt="image-20200514122235681"></p><p><img src="/2020/08/03/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E7%9F%A5%E8%AF%86%E7%82%B9/image-20200514122252795.png" alt="image-20200514122252795"></p><p><img src="/2020/08/03/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E7%9F%A5%E8%AF%86%E7%82%B9/image-20200514122334514.png" alt="image-20200514122334514"></p><h6 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h6><p><img src="/2020/08/03/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E7%9F%A5%E8%AF%86%E7%82%B9/image-20200514122417659.png" alt="image-20200514122417659"></p><h6 id="比较器"><a href="#比较器" class="headerlink" title="比较器"></a>比较器</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*         内部比较器</span></span><br><span class="line"><span class="comment">*               定义在元素的类中，通过实现comparable接口来进行实现</span></span><br><span class="line"><span class="comment">*         外部比较器</span></span><br><span class="line"><span class="comment">*               定义在当前类中，通过实现comparator接口来实现，但是要将该比较器传递到集合中</span></span><br><span class="line"><span class="comment">*         注意：外部比较器可以定义成一个工具类，此时所有需要比较的规则如果一致的话，可以复用，而</span></span><br><span class="line"><span class="comment">*               内部比较器只有在存储当前对象的时候才可以使用</span></span><br><span class="line"><span class="comment">*               如果两者同时存在，使用外部比较器</span></span><br><span class="line"><span class="comment">*               当使用比较器的时候，不会调用equals方法</span></span><br><span class="line"><span class="comment">* */</span></span><br></pre></td></tr></table></figure><p><img src="/2020/08/03/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E7%9F%A5%E8%AF%86%E7%82%B9/image-20200514122527240.png" alt="image-20200514122527240"></p><p><img src="/2020/08/03/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E7%9F%A5%E8%AF%86%E7%82%B9/image-20200514122557122.png" alt="image-20200514122557122"></p><h6 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h6><p><img src="/2020/08/03/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E7%9F%A5%E8%AF%86%E7%82%B9/image-20200514125045624.png" alt="image-20200514125045624"></p><h6 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h6><img src="/2020/08/03/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E7%9F%A5%E8%AF%86%E7%82%B9/../../../只要学不死 就往死里学/note/Collection/image/集合/image-20200514125258424.png" alt="image-20200514125258424" style="zoom:80%;"><h6 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h6><p>牺牲完全平衡的特点，部分平衡，换区插入和删除的效率</p><p><img src="/2020/08/03/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E7%9F%A5%E8%AF%86%E7%82%B9/image-20200514134304988.png" alt="image-20200514134304988"></p><h5 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当做一些集合的统一操作的时候，需要保证集合的类型是统一的，此时需要泛型来进行限制</span></span><br><span class="line"><span class="comment"> *      优点：</span></span><br><span class="line"><span class="comment"> *          1、数据安全</span></span><br><span class="line"><span class="comment"> *          2、获取数据时效率比较高</span></span><br><span class="line"><span class="comment"> *      给集合中的元素设置相同的类型就是泛型的基本需求</span></span><br><span class="line"><span class="comment"> *       使用：</span></span><br><span class="line"><span class="comment"> *          在定义对象的时候，通过&lt;&gt;中设置合理的类型来进行实现</span></span><br><span class="line"><span class="comment"> *  泛型的高阶应用：</span></span><br><span class="line"><span class="comment"> *      1、泛型类</span></span><br><span class="line"><span class="comment"> *          在定义类的时候在类名的后面添加&lt;E,K,V,A,B&gt;,起到占位的作用，类中的方法的返回值类型和属性的类型都可以使用</span></span><br><span class="line"><span class="comment"> *      2、泛型接口</span></span><br><span class="line"><span class="comment"> *          在定义接口的时候，在接口的名称后添加&lt;E,K,V,A,B&gt;,</span></span><br><span class="line"><span class="comment"> *          1、子类在进行实现的时候，可以不填写泛型的类型，此时在创建具体的子类对象的时候才决定使用什么类型</span></span><br><span class="line"><span class="comment"> *          2、子类在实现泛型接口的时候，只在实现父类的接口的时候指定父类的泛型类型即可，此时，测试方法中的泛型类型必须要跟子类保持一致</span></span><br><span class="line"><span class="comment"> *      3、泛型方法</span></span><br><span class="line"><span class="comment"> *          在定义方法的时候，指定方法的返回值和参数是自定义的占位符，可以是类名中的T,也可以是自定义的Q，只不过在使用Q的时候需要使用&lt;</span></span><br><span class="line"><span class="comment"> *          Q&gt;定义在返回值的前面</span></span><br><span class="line"><span class="comment"> *      4、泛型的上限（工作中不用）</span></span><br><span class="line"><span class="comment"> *          如果父类确定了，所有的子类都可以直接使用</span></span><br><span class="line"><span class="comment"> *      5、泛型的下限（工作中不用）</span></span><br><span class="line"><span class="comment"> *          如果子类确定了，子类的所有父类都可以直接传递参数使用</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p><img src="/2020/08/03/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E7%9F%A5%E8%AF%86%E7%82%B9/image-20200514134340093.png" alt="image-20200514134340093"></p><p><img src="/2020/08/03/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E7%9F%A5%E8%AF%86%E7%82%B9/image-20200514134358177.png" alt="image-20200514134358177"></p><h6 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h6><p><img src="/2020/08/03/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E7%9F%A5%E8%AF%86%E7%82%B9/image-20200514134659227.png" alt="image-20200514134659227"></p><h6 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h6><p><img src="/2020/08/03/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E7%9F%A5%E8%AF%86%E7%82%B9/image-20200514140620622.png" alt="image-20200514140620622"></p><p><img src="/2020/08/03/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E7%9F%A5%E8%AF%86%E7%82%B9/image-20200514140636471.png" alt="image-20200514140636471"></p><h5 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h5><h6 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h6><img src="/2020/08/03/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E7%9F%A5%E8%AF%86%E7%82%B9/../../../只要学不死 就往死里学/note/Collection/image/集合/image-20200514173113121.png" alt="image-20200514173113121" style="zoom:67%;"><img src="/2020/08/03/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E7%9F%A5%E8%AF%86%E7%82%B9/../../../只要学不死 就往死里学/note/Collection/image/集合/image-20200514173130393.png" alt="image-20200514173130393" style="zoom:67%;"><img src="/2020/08/03/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E7%9F%A5%E8%AF%86%E7%82%B9/../../../只要学不死 就往死里学/note/Collection/image/集合/image-20200514173144162.png" alt="image-20200514173144162" style="zoom:67%;">]]></content>
      
      
      
        <tags>
            
            <tag> Java SE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode题解--括号配对</title>
      <link href="/2020/07/26/LeetCode%E9%A2%98%E8%A7%A3-%E6%8B%AC%E5%8F%B7%E9%85%8D%E5%AF%B9/"/>
      <url>/2020/07/26/LeetCode%E9%A2%98%E8%A7%A3-%E6%8B%AC%E5%8F%B7%E9%85%8D%E5%AF%B9/</url>
      
        <content type="html"><![CDATA[<h4 id="括号配对"><a href="#括号配对" class="headerlink" title="括号配对"></a>括号配对</h4><p>括号有效配对是指：<br>1）任何一个左括号都能找到和其正确配对的右括号<br>2）任何一个右括号都能找到和其正确配对的左括号<br>有效的：    (())  ()()   (()())  等<br>无效的：     (()   )(     等</p><h5 id="问题1-怎么判断一个括号字符串有效？"><a href="#问题1-怎么判断一个括号字符串有效？" class="headerlink" title="问题1: 怎么判断一个括号字符串有效？"></a>问题1: 怎么判断一个括号字符串有效？</h5><p>思路:</p><ol><li>用栈: 麻烦</li><li>用单一变量, 遇到左括号count++, 遇到右括号count–, count&lt;0,返回false, 最后count==0, 返回true</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">valid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] str = s.tocharArray();</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 注意字符用单引号'('</span></span><br><span class="line">        count += str[i] == <span class="string">'('</span> ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (count &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="问题2-如果一个括号字符串无效，返回至少填几个字符能让其整体有效-LeetCode-921"><a href="#问题2-如果一个括号字符串无效，返回至少填几个字符能让其整体有效-LeetCode-921" class="headerlink" title="问题2: 如果一个括号字符串无效，返回至少填几个字符能让其整体有效 (LeetCode 921)"></a>问题2: 如果一个括号字符串无效，返回至少填几个字符能让其整体有效 (LeetCode 921)</h5><p>思路: </p><ol><li>遇到左括号, count++, 遇到右括号, count–</li><li>如果count == -1, need++, count恢复成0</li><li>返回count + need</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">needParenthese</span> <span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] str = s.toCharArray();</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> need = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(str[i] == <span class="string">'('</span>) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 遇到')'</span></span><br><span class="line">            <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">                need++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                count--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count + need; </span><br><span class="line">&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minAddToMakeValid</span><span class="params">(String S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> L = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> R = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;S.length(); i++) &#123;</span><br><span class="line">            R += S.charAt(i) == <span class="string">'('</span> ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (R == -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 缺左括号, 左右都要+1, 把R归0</span></span><br><span class="line">                L++;</span><br><span class="line">                R++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> L + R;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="问题3-返回一个括号字符串中，最长的括号有效子串的长度-动态规划-LeetCode-32"><a href="#问题3-返回一个括号字符串中，最长的括号有效子串的长度-动态规划-LeetCode-32" class="headerlink" title="问题3: 返回一个括号字符串中，最长的括号有效子串的长度 (动态规划) (LeetCode 32)"></a>问题3: 返回一个括号字符串中，最长的括号有效子串的长度 (动态规划) (LeetCode 32)</h5><p>思路:</p><ol><li><p>i位置是左括号, dp[i] = 0</p></li><li><p>i位置是右括号, dp[i] = dp[i - 1] + 2 + (pre &gt; 0 ? dp[pre -1] : 0);</p></li><li><p>i位置往前推dp[i-1]个数, 的前一个数</p><p><img src="/2020/07/26/LeetCode%E9%A2%98%E8%A7%A3-%E6%8B%AC%E5%8F%B7%E9%85%8D%E5%AF%B9/image-20200624125914653.png" alt="image-20200624125914653"></p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxLength</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(s == <span class="keyword">null</span> || s.length() &lt; <span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">char</span>[] str = s.toCharArray();</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[str.length];</span><br><span class="line">    <span class="keyword">int</span> pre = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 默认dp[0] = 0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; str.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 左括号不管</span></span><br><span class="line">        <span class="keyword">if</span>(str[i] == <span class="string">')'</span>) &#123;</span><br><span class="line">            <span class="comment">// 与str[i] 配对的左括号位置pre</span></span><br><span class="line">            pre = i - dp[i - <span class="number">1</span>] -<span class="number">1</span>;</span><br><span class="line">            <span class="comment">// pre是有效的, 并且是左括号</span></span><br><span class="line">            <span class="keyword">if</span> (pre &gt;= <span class="number">0</span> &amp;&amp; str[pre] == <span class="string">'('</span>) &#123;</span><br><span class="line">                <span class="comment">// dp[i] = 前一个有效值 + 2 + 再前一个有效值(pre - 1要有效)</span></span><br><span class="line">                dp[i] = dp[i - <span class="number">1</span>] + <span class="number">2</span> + (pre &gt; <span class="number">0</span> ? dp[pre -<span class="number">1</span>] : <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res = Math.max(res, dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="问题4-给定括号字符串-返回该字符串最大嵌套层数"><a href="#问题4-给定括号字符串-返回该字符串最大嵌套层数" class="headerlink" title="问题4: 给定括号字符串, 返回该字符串最大嵌套层数"></a>问题4: 给定括号字符串, 返回该字符串最大嵌套层数</h5><p>思路: 遇到左括号count++, 遇到右括号count–, 返回count最大值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s == <span class="keyword">null</span> || s.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span>[] str = s.toCharArray();</span><br><span class="line">    <span class="comment">// 辅助变量</span></span><br><span class="line">    <span class="keyword">int</span> status = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (str[i] != <span class="string">')'</span> &amp;&amp; str[i] != <span class="string">'('</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (str[i] == <span class="string">')'</span> &amp;&amp; --status &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (str[i] == <span class="string">'('</span>) &#123;</span><br><span class="line">            status++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> status == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">deep</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!isValid(s)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span>[] str = s.toCharArray();</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (str[i] == <span class="string">'('</span>) &#123;</span><br><span class="line">            max = Math.max(max, ++count);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            count--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id><a href="#" class="headerlink" title></a></h4>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于Redis的分布式锁实现原理</title>
      <link href="/2020/07/23/%E5%9F%BA%E4%BA%8ERedis%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
      <url>/2020/07/23/%E5%9F%BA%E4%BA%8ERedis%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>为了防止分布式系统中的多个进程之间相互干扰，我们需要一种分布式协调技术来对这些进程进行调度。而这个分布式协调技术的核心就是来实现这个<strong>分布式锁</strong>。</p><h2 id="为什么要使用分布式锁"><a href="#为什么要使用分布式锁" class="headerlink" title="为什么要使用分布式锁"></a>为什么要使用分布式锁</h2><p><img src="https:////upload-images.jianshu.io/upload_images/7986413-7cc8f57c65d81728.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/874/format/webp" alt="img"></p><ul><li>成员变量 A 存在 JVM1、JVM2、JVM3 三个 JVM 内存中</li><li>成员变量 A 同时都会在 JVM 分配一块内存，三个请求发过来同时对这个变量操作，显然结果是不对的</li><li>不是同时发过来，三个请求分别操作三个不同 JVM 内存区域的数据，变量 A 之间不存在共享，也不具有可见性，处理的结果也是不对的<br>注：该成员变量 A 是一个有状态的对象</li></ul><p>如果我们业务中确实存在这个场景的话，我们就需要一种方法解决这个问题，<strong>这就是分布式锁要解决的问题</strong></p><h2 id="分布式锁应该具备哪些条件"><a href="#分布式锁应该具备哪些条件" class="headerlink" title="分布式锁应该具备哪些条件"></a>分布式锁应该具备哪些条件</h2><ul><li>在分布式系统环境下，一个方法在同一时间只能被一个机器的一个线程执行</li><li>高可用的获取锁与释放锁</li><li>高性能的获取锁与释放锁</li><li>具备可重入特性（可理解为重新进入，由多于一个任务并发使用，而不必担心数据错误）</li><li>具备锁失效机制，防止死锁</li><li>具备非阻塞锁特性，即没有获取到锁将直接返回获取锁失败</li></ul><h2 id="分布式锁的实现有哪些"><a href="#分布式锁的实现有哪些" class="headerlink" title="分布式锁的实现有哪些"></a>分布式锁的实现有哪些</h2><ul><li>Memcached：利用 Memcached 的 <code>add</code> 命令。此命令是原子性操作，只有在 <code>key</code> 不存在的情况下，才能 <code>add</code> 成功，也就意味着线程得到了锁。</li><li>Redis：和 Memcached 的方式类似，利用 Redis 的 <code>setnx</code> 命令。此命令同样是原子性操作，只有在 <code>key</code> 不存在的情况下，才能 <code>set</code> 成功。</li><li><strong>Zookeeper</strong>：利用 Zookeeper 的顺序临时节点，来实现分布式锁和等待队列。Zookeeper 设计的初衷，就是为了实现分布式锁服务的。</li><li>Chubby：Google 公司实现的粗粒度分布式锁服务，底层利用了 Paxos 一致性算法。</li></ul><h2 id="通过-Redis-分布式锁的实现理解基本概念"><a href="#通过-Redis-分布式锁的实现理解基本概念" class="headerlink" title="通过 Redis 分布式锁的实现理解基本概念"></a>通过 Redis 分布式锁的实现理解基本概念</h2><p>分布式锁实现的三个核心要素：</p><h3 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h3><p>最简单的方法是使用 <code>setnx</code> 命令。<code>key</code> 是锁的唯一标识，按业务来决定命名。比如想要给一种商品的秒杀活动加锁，可以给 <code>key</code> 命名为 “lock_sale_商品ID” 。而 <code>value</code> 设置成什么呢？我们可以姑且设置成 <code>1</code>。加锁的伪代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setnx（lock_sale_商品ID，1）</span><br></pre></td></tr></table></figure><p>当一个线程执行 <code>setnx</code> 返回 <code>1</code>，说明 <code>key</code> 原本不存在，该线程成功得到了锁；当一个线程执行 <code>setnx</code> 返回 <code>0</code>，说明 <code>key</code> 已经存在，该线程抢锁失败。</p><h3 id="解锁"><a href="#解锁" class="headerlink" title="解锁"></a>解锁</h3><p>有加锁就得有解锁。当得到锁的线程执行完任务，需要释放锁，以便其他线程可以进入。释放锁的最简单方式是执行 <code>del</code> 指令，伪代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">del</span>（lock_sale_商品ID）</span><br></pre></td></tr></table></figure><p>释放锁之后，其他线程就可以继续执行 <code>setnx</code> 命令来获得锁。</p><h3 id="锁超时"><a href="#锁超时" class="headerlink" title="锁超时"></a>锁超时</h3><p>锁超时是什么意思呢？如果一个得到锁的线程在执行任务的过程中挂掉，来不及显式地释放锁，这块资源将会永远被锁住（<strong>死锁</strong>），别的线程再也别想进来。所以，<code>setnx</code> 的 <code>key</code> 必须设置一个超时时间，以保证即使没有被显式释放，这把锁也要在一定时间后自动释放。<code>setnx</code> 不支持超时参数，所以需要额外的指令，伪代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expire（lock_sale_商品ID， 30）</span><br></pre></td></tr></table></figure><p>综合伪代码如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>（setnx（lock_sale_商品ID，<span class="number">1</span>） == <span class="number">1</span>）&#123;</span><br><span class="line">    expire（lock_sale_商品ID，<span class="number">30</span>）</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">do</span> something ......</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        del（lock_sale_商品ID）</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="存在什么问题"><a href="#存在什么问题" class="headerlink" title="存在什么问题"></a>存在什么问题</h3><p>以上伪代码中存在三个致命问题</p><h4 id="setnx-和-expire-的非原子性"><a href="#setnx-和-expire-的非原子性" class="headerlink" title="setnx 和 expire 的非原子性"></a><code>setnx</code> 和 <code>expire</code> 的非原子性</h4><p>设想一个极端场景，当某线程执行 <code>setnx</code>，成功得到了锁：</p><p><img src="https:////upload-images.jianshu.io/upload_images/7986413-153ca0fbc59af246.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/470/format/webp" alt="img"></p><p><code>setnx</code> 刚执行成功，还未来得及执行 <code>expire</code> 指令，节点 1 挂掉了。</p><p><img src="https:////upload-images.jianshu.io/upload_images/7986413-616a3d3f9f42b60d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/520/format/webp" alt="img"></p><p>这样一来，这把锁就没有设置过期时间，变成<strong>死锁</strong>，别的线程再也无法获得锁了。</p><p>怎么解决呢？<code>setnx</code> 指令本身是不支持传入超时时间的，<code>set</code> 指令增加了可选参数，伪代码如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span>（lock_sale_商品ID，1，30，NX）</span><br></pre></td></tr></table></figure><p>这样就可以取代 <code>setnx</code> 指令。</p><h4 id="del-导致误删"><a href="#del-导致误删" class="headerlink" title="del 导致误删"></a><code>del</code> 导致误删</h4><p>又是一个极端场景，假如某线程成功得到了锁，并且设置的超时时间是 30 秒。</p><p><img src="https:////upload-images.jianshu.io/upload_images/7986413-9c744a0adacf3591.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/470/format/webp" alt="img"></p><p>如果某些原因导致线程 A 执行的很慢很慢，过了 30 秒都没执行完，这时候锁过期自动释放，线程 B 得到了锁。</p><p><img src="https:////upload-images.jianshu.io/upload_images/7986413-aff00874eea4ffb2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/470/format/webp" alt="img"></p><p>随后，线程 A 执行完了任务，线程 A 接着执行 <code>del</code> 指令来释放锁。但这时候线程 B 还没执行完，线程A实际上 <code>删除的是线程 B 加的锁</code>。</p><p><img src="https:////upload-images.jianshu.io/upload_images/7986413-d641463ea89da638.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/470/format/webp" alt="img"></p><p>怎么避免这种情况呢？可以在 <code>del</code> 释放锁之前做一个判断，验证当前的锁是不是自己加的锁。至于具体的实现，可以在加锁的时候把当前的线程 ID 当做 <code>value</code>，并在删除之前验证 <code>key</code> 对应的 <code>value</code> 是不是自己线程的 ID。</p><p>加锁：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> threadId = Thread.currentThread().getId()</span><br><span class="line"><span class="keyword">set</span>（key，threadId ，<span class="number">30</span>，NX）</span><br></pre></td></tr></table></figure><p>解锁：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>（threadId .<span class="keyword">equals</span>(redisClient.<span class="keyword">get</span>(key))）&#123;</span><br><span class="line">    del(key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，这样做又隐含了一个新的问题，判断和释放锁是两个独立操作，不是原子性。</p><h4 id="出现并发的可能性"><a href="#出现并发的可能性" class="headerlink" title="出现并发的可能性"></a>出现并发的可能性</h4><p>还是刚才第二点所描述的场景，虽然我们避免了线程 A 误删掉 <code>key</code> 的情况，但是同一时间有 A，B 两个线程在访问代码块，仍然是不完美的。怎么办呢？我们可以让获得锁的线程开启一个<strong>守护线程</strong>，用来给快要过期的锁“续航”。</p><p><img src="https:////upload-images.jianshu.io/upload_images/7986413-e6e284f3c6a07a85.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/470/format/webp" alt="img"></p><p>当过去了 29 秒，线程 A 还没执行完，这时候守护线程会执行 <code>expire</code> 指令，为这把锁“续命”20 秒。守护线程从第 29 秒开始执行，每 20 秒执行一次。</p><p><img src="https:////upload-images.jianshu.io/upload_images/7986413-723b942f08f9304b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/470/format/webp" alt="img"></p><p>当线程 A 执行完任务，会显式关掉守护线程。</p><p><img src="https:////upload-images.jianshu.io/upload_images/7986413-316383d4d0af2be6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/470/format/webp" alt="img"></p><p>另一种情况，如果节点 1 忽然断电，由于线程 A 和守护线程在同一个进程，守护线程也会停下。这把锁到了超时的时候，没人给它续命，也就自动释放了。</p><p><img src="https:////upload-images.jianshu.io/upload_images/7986413-e41eb41db50fa1b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/510/format/webp" alt="img"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL索引数据结构分析</title>
      <link href="/2020/07/12/MySQL%E7%B4%A2%E5%BC%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/"/>
      <url>/2020/07/12/MySQL%E7%B4%A2%E5%BC%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="二叉树、B-Tree、B-Tree、红黑树、平衡二叉树（AVL-Trees）"><a href="#二叉树、B-Tree、B-Tree、红黑树、平衡二叉树（AVL-Trees）" class="headerlink" title="二叉树、B-Tree、B+Tree、红黑树、平衡二叉树（AVL Trees）"></a>二叉树、B-Tree、B+Tree、红黑树、平衡二叉树（AVL Trees）</h2><h3 id="平衡二叉树-AVL-Trees"><a href="#平衡二叉树-AVL-Trees" class="headerlink" title="平衡二叉树 (AVL Trees)"></a>平衡二叉树 (AVL Trees)</h3><p>  平衡二叉树是一种特殊的二叉树，所以他也满足前面说到的二叉树的两个特性，同时还有一个特性：</p><p>​        它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。</p><p>  大家也看到了前面[35 27 48 12 29 38 55]插入完成后的图，其实就已经是一颗平衡二叉树。</p><p>  那如果按照[12 27 29 35 38 48 55]的顺序插入一颗平衡二叉树，会怎么样呢？我们看看插入以及平衡的过程：</p><img src="http://cdn.17coding.info/WeChat%20Screenshot_20190616165744.png" alt="img" style="zoom:80%;"><img src="http://cdn.17coding.info/WeChat%20Screenshot_20190616165806.png" alt="img" style="zoom:80%;">![img](MySQL索引数据结构分析/WeChat Screenshot_20190616165835.png)![img](MySQL索引数据结构分析/WeChat Screenshot_20190616165909.png)![img](MySQL索引数据结构分析/WeChat Screenshot_20190616165924.png)![img](MySQL索引数据结构分析/WeChat Screenshot_20190616165936.png)![img](MySQL索引数据结构分析/WeChat Screenshot_20190616165954.png)<p>  这棵树始终满足平衡二叉树的几个特性而保持平衡！这样我们的树也不会退化为线性链表了！我们需要查找一个数的时候就能沿着树根一直往下找，这样的查找效率和二分法查找是一样的呢！</p><p>  一颗平衡二叉树能容纳多少的结点呢？这跟树的高度是有关系的，假设树的高度为h，那每一层最多容纳的结点数量为2^(n-1)，整棵树最多容纳节点数为2^0+2^1+2^2+…+2^(h-1)。这样计算，100w数据树的高度大概在20左右，那也就是说从有着100w条数据的平衡二叉树中找一个数据，最坏的情况下需要20次查找。如果是内存操作，效率也是很高的！但是我们数据库中的数据基本都是放在磁盘中的，每读取一个二叉树的结点就是一次磁盘IO，这样我们找一条数据如果要经过20次磁盘的IO？那性能就成了一个很大的问题了！那我们是不是可以把这棵树压缩一下，让每一层能够容纳更多的节点呢？虽然我矮，但是我胖啊…</p><h3 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B-Tree"></a>B-Tree</h3><p>  这颗矮胖的树就是B-Tree，注意中间是杠精的杠而不是减，所以也不要读成B减Tree了~</p><p>  那B-Tree有哪些特性呢？一棵m阶的B-Tree有如下特性：</p><blockquote><p>1、每个结点最多m个子结点。<br>2、除了根结点和叶子结点外，每个结点最少有m/2（向上取整）个子结点。<br>3、如果根结点不是叶子结点，那根结点至少包含两个子结点。<br>4、所有的叶子结点都位于同一层。<br>5、每个结点都包含k个元素（关键字），这里m/2≤k&lt;m，这里m/2向下取整。<br>6、每个节点中的元素（关键字）从小到大排列。<br>7、每个元素（关键字）字左结点的值，都小于或等于该元素（关键字）。右结点的值都大于或等于该元素（关键字）。</p></blockquote><p>  是不是感觉跟丈母娘张口问你要彩礼一样，列一堆的条件，而且每一条都让你很懵逼！下面我们以一个[0,1,2,3,4,5,6,7]的数组插入一颗3阶的B-Tree为例，将所有的条件都串起来，你就明白了！</p><p>![img](MySQL索引数据结构分析/WeChat Screenshot_20190619204220.png)<br>![img](MySQL索引数据结构分析/WeChat Screenshot_20190619204227.png)<br>![img](MySQL索引数据结构分析/WeChat Screenshot_20190619204243.png)<br>![img](MySQL索引数据结构分析/WeChat Screenshot_20190619204302.png)<br>![img](MySQL索引数据结构分析/WeChat Screenshot_20190619204311.png)<br>![img](MySQL索引数据结构分析/WeChat Screenshot_20190619204327.png)<br>![img](MySQL索引数据结构分析/WeChat Screenshot_20190619204336.png)</p><p>  那么，你是否对B-Tree的几点特性都清晰了呢？在二叉树中，每个结点只有一个元素。但是在B-Tree中，每个结点都可能包含多个元素，并且非叶子结点在元素的左右都有指向子结点的指针。</p><p>  如果需要查找一个元素，那流程是怎么样的呢？我们看下图，如果我们要在下面的B-Tree中找到关键字24，那流程如下<br>![img](MySQL索引数据结构分析/WeChat Screenshot_20190619210818.png)<br>![img](MySQL索引数据结构分析/WeChat Screenshot_20190619210824.png)<br>![img](MySQL索引数据结构分析/WeChat Screenshot_20190619210831.png)<br>![img](MySQL索引数据结构分析/WeChat Screenshot_20190619210838.png)</p><p>  从这个流程我们能看出，B-Tree的查询效率好像也并不比平衡二叉树高。但是查询所经过的结点数量要少很多，也就意味着要少很多次的磁盘IO，这对<br>性能的提升是很大的。</p><p>  前面对B-Tree操作的图我们能看出来，元素就是类似1、2、3这样的数值，但是数据库的数据都是一条条的数据，如果某个数据库以B-Tree的数据结构存储数据，那数据怎么存放的呢？我们看下一张图</p><p>![img](MySQL索引数据结构分析/WeChat Screenshot_20190620221029.png)</p><p>  普通的B-Tree的结点中，元素就是一个个的数字。但是上图中，我们把元素部分拆分成了key-data的形式，key就是数据的主键，data就是具体的数据。这样我们在找一条数的时候，就沿着根结点往下找就ok了，效率是比较高的。</p><h3 id="B-Tree-1"><a href="#B-Tree-1" class="headerlink" title="B+Tree"></a>B+Tree</h3><p>  B+Tree是在B-Tree基础上的一种优化，使其更适合实现外存储索引结构。B+Tree与B-Tree的结构很像，但是也有几个自己的特性：</p><blockquote><p>1、所有的非叶子节点只存储关键字信息。<br>2、所有卫星数据（具体数据）都存在叶子结点中。<br>3、所有的叶子结点中包含了全部元素的信息。<br>4、所有叶子节点之间都有一个链指针。</p></blockquote><p>  如果上面B-Tree的图变成B+Tree，那应该如下：<br>![img](MySQL索引数据结构分析/WeChat Screenshot_20190621220003.png)</p><p>  大家仔细对比于B-Tree的图能发现什么不同？<br>  1、非叶子结点上已经只有key信息了，满足上面第1点特性！<br>  2、所有叶子结点下面都有一个data区域，满足上面第2点特性！<br>  3、非叶子结点的数据在叶子结点上都能找到，如根结点的元素4、8在最底层的叶子结点上也能找到，满足上面第3点特性！<br>  4、注意图中叶子结点之间的箭头，满足满足上面第4点特性！</p><h3 id="B-Tree-or-B-Tree？"><a href="#B-Tree-or-B-Tree？" class="headerlink" title="B-Tree or B+Tree？"></a>B-Tree or B+Tree？</h3><p>  在讲这两种数据结构在数据库中的选择之前，我们还需要了解的一个知识点是操作系统从磁盘读取数据到内存是以磁盘块（block）为基本单位的，<strong>位于同一个磁盘块中的数据会被一次性读取出来，而不是需要什么取什么</strong>。即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。这样做的理论依据是计算机科学中著名的<strong>局部性原理</strong>： 当一个数据被用到时，其附近的数据也通常会马上被使用。<br>  预读的长度一般为页（page）的整倍数。页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页得大小通常为4k）。</p><p>  B-Tree和B+Tree该如何选择呢？都有哪些优劣呢？<br>  1、B-Tree因为非叶子结点也保存具体数据，所以在查找某个关键字的时候找到即可返回。而B+Tree所有的数据都在叶子结点，每次查找都得到叶子结点。所以在同样高度的B-Tree和B+Tree中，B-Tree查找某个关键字的效率更高。<br>  2、由于B+Tree所有的数据都在叶子结点，并且结点之间有指针连接，在找大于某个关键字或者小于某个关键字的数据的时候，B+Tree只需要找到该关键字然后沿着链表遍历就可以了，而B-Tree还需要遍历该关键字结点的根结点去搜索。<br>  3、由于B-Tree的每个结点（这里的结点可以理解为一个数据页）都存储主键+实际数据，而B+Tree非叶子结点只存储关键字信息，而每个页的大小有限是有限的，所以同一页能存储的B-Tree的数据会比B+Tree存储的更少。这样同样总量的数据，B-Tree的深度会更大，增大查询时的磁盘I/O次数，进而影响查询效率。<br>  鉴于以上的比较，所以在常用的关系型数据库中，都是选择B+Tree的数据结构来存储数据！下面我们以mysql的innodb存储引擎为例讲解，其他类似sqlserver、oracle的原理类似！</p><h4 id="innodb引擎数据存储"><a href="#innodb引擎数据存储" class="headerlink" title="innodb引擎数据存储"></a>innodb引擎数据存储</h4><p>  在InnoDB存储引擎中，也有页的概念，默认每个页的大小为16K，也就是每次读取数据时都是读取4*4k的大小！假设我们现在有一个用户表，我们往里面写数据</p><p>![img](MySQL索引数据结构分析/WeChat Screenshot_20190623130137.png)</p><p>  这里需要注意的一点是，在某个页内插入新行时，为了不减少数据的移动，通常是插入到当前行的后面或者是已删除行留下来的空间，所以在<strong>某一个页内</strong>的数据并<strong>不是完全有序</strong>的（后面页结构部分有细讲），但是为了为了数据访问顺序性，在每个记录中都有一个指向下一条记录的指针，以此构成了一条单向有序链表，不过在这里为了方便演示我是按顺序排列的！</p><p>  由于数据还比较少，一个页就能容下，所以只有一个根结点，主键和数据也都是保存在根结点（左边的数字代表主键，右边名字、性别代表具体的数据）。假设我们写入10条数据之后，Page1满了，再写入新的数据会怎么存放呢？我们继续看下图</p><p>![img](MySQL索引数据结构分析/WeChat Screenshot_20190623130144.png)</p><p>  有个叫“秦寿生”的朋友来了，但是Page1已经放不下数据了，这时候就需要进行页分裂，产生一个新的Page。在innodb中的流程是怎么样的呢？</p><blockquote><p>1、产生新的Page2，然后将Page1的内容复制到Page2。<br>2、产生新的Page3，“秦寿生”的数据放入Page3。<br>3、原来的Page1依然作为根结点，但是变成了一个不存放数据只存放索引的页，并且有两个子结点Page2、Page3。</p></blockquote><p>  这里有两个问题需要注意的是<br>  1、为什么要复制Page1为Page2而不是创建一个新的页作为根结点，这样就少了一步复制的开销了？<br>  如果是重新创建根结点，那根结点存储的物理地址可能经常会变，不利于查找。并且在<strong>innodb中根结点是会预读到内存中</strong>的，所以结点的物理地址固定会比较好！</p><p>  2、原来Page1有10条数据，在插入第11条数据的时候进行裂变，根据前面对B-Tree、B+Tree特性的了解，那这至少是一颗11阶的树，裂变之后每个结点的元素至少为11/2=5个，那是不是应该页裂变之后主键1-5的数据还是在原来的页，主键6-11的数据会放到新的页，根结点存放主键6？<br>  如果是这样的话新的页空间利用率只有50%，并且会导致更为频繁的页分裂。所以innodb对这一点做了优化，新的数据放入新创建的页，不移动原有页面的任何记录。</p><p>  随着数据的不断写入，这棵树也逐渐枝繁叶茂，如下图<br>![img](MySQL索引数据结构分析/WeChat Screenshot_20190623131149.png)</p><p>  每次新增数据，都是将一个页写满，然后新创建一个页继续写，这里其实是有个隐含条件的，那就是<strong>主键自增</strong>！主键自增写入时新插入的数据不会影响到原有页，插入效率高！且页的利用率高！但是如果主键是无序的或者随机的，那每次的插入可能会导致原有页频繁的分裂，影响插入效率！降低页的利用率！<strong>这也是为什么在innodb中建议设置主键自增的原因！</strong></p><p>  这棵树的非叶子结点上存的都是主键，那如果一个表没有主键会怎么样？在innodb中，如果一个表没有主键，那默认会找建了唯一索引的列，如果也没有，则会生成一个隐形的字段作为主键！</p><p>  有数据插入那就有删除，如果这个用户表频繁的插入和删除，那会导致数据页产生碎片，页的空间利用率低，还会导致树变的“虚高”，降低查询效率！这可以通过<strong>索引重建</strong>来消除碎片提高查询效率！</p><h4 id="innodb引擎数据查找"><a href="#innodb引擎数据查找" class="headerlink" title="innodb引擎数据查找"></a>innodb引擎数据查找</h4><p>  数据插入了怎么查找呢？</p><blockquote><p>1、找到数据所在的页。这个查找过程就跟前面说到的B+Tree的搜索过程是一样的，从根结点开始查找一直到叶子结点。<br>2、在页内找具体的数据。读取第1步找到的叶子结点数据到内存中，然后通过<strong>分块查找</strong>的方法找到具体的数据。</p></blockquote><p>  这跟我们在新华字典中找某个汉字是一样的，先通过字典的索引定位到该汉字拼音所在的页，然后到指定的页找到具体的汉字。innodb中定位到页后用了哪种策略快速查找某个主键呢？这我们就需要从页结构开始了解。</p><p>![img](MySQL索引数据结构分析/WeChat Screenshot_20190623225950.png)</p><p>  左边蓝色区域称为Page Directory，这块区域由多个slot组成，是一个稀疏索引结构，即一个槽中可能属于多个记录，最少属于4条记录，最多属于8条记录。槽内的数据是有序存放的，所以当我们寻找一条数据的时候可以先在槽中通过二分法查找到一个大致的位置。</p><p>  右边区域为数据区域，每一个数据页中都包含多条行数据。注意看图中最上面和最下面的两条特殊的行记录Infimum和Supremum，这是两个虚拟的行记录。在没有其他用户数据的时候Infimum的下一条记录的指针指向Supremum，当有用户数据的时候，Infimum的下一条记录的指针指向当前页中最小的用户记录，当前页中最大的用户记录的下一条记录的指针指向Supremum，至此整个页内的所有行记录形成一个单向链表。</p><p>  行记录被Page Directory逻辑的分成了多个块，块与块之间是有序的，也就是说“4”这个槽指向的数据块内最大的行记录的主键都要比“8”这个槽指向的数据块内最小的行记录的主键要小。但是块内部的行记录不一定有序。</p><p>  每个行记录的都有一个n_owned的区域（图中粉红色区域），n_owned标识这个这个块有多少条数据，伪记录Infimum的n_owned值总是1，记录Supremum的n_owned的取值范围为[1,8]，其他用户记录n_owned的取值范围[4,8]，并且只有每个块中最大的那条记录的n_owned才会有值，其他的用户记录的n_owned为0。</p><p>  所以当我们要找主键为6的记录时，先通过<strong>二分法</strong>在<strong>稀疏索引</strong>中找到对应的槽，也就是Page Directory中“8”这个槽，“8”这个槽指向的是该数据块中最大的记录，而数据是单向链表结构所以无法逆向查找，所以需要找到上一个槽即“4”这个槽，然后通过“4”这个槽中最大的用户记录的指针沿着链表<strong>顺序查找</strong>到目标记录。</p><h4 id="聚集索引-amp-非聚集索引"><a href="#聚集索引-amp-非聚集索引" class="headerlink" title="聚集索引&amp;非聚集索引"></a>聚集索引&amp;非聚集索引</h4><p>  前面关于数据存储的都是演示的聚集索引的实现，如果上面的用户表需要以“用户名字”建立一个非聚集索引，是怎么实现的呢？我们看下图：</p><p>![img](MySQL索引数据结构分析/WeChat Screenshot_20190623152229.png)</p><p>  非聚集索引的存储结构与前面是一样的，不同的是在叶子结点的数据部分存的不再是具体的数据，而数据的聚集索引的key。所以通过非聚集索引查找的过程是先找到该索引key对应的聚集索引的key，然后再拿聚集索引的key到主键索引树上查找对应的数据，这个过程称为<strong>回表</strong>！</p><p>  图中的这些名字均来源于网络，希望没有误伤正在看这篇文章的你~^_^</p><h4 id="innodb与MyISAM两种存储引擎对比"><a href="#innodb与MyISAM两种存储引擎对比" class="headerlink" title="innodb与MyISAM两种存储引擎对比"></a>innodb与MyISAM两种存储引擎对比</h4><p>  上面包括存储和搜索都是拿的innodb引擎为例，那MyISAM与innodb在存储上有啥不同呢？憋缩话，看图：</p><p>![img](MySQL索引数据结构分析/WeChat Screenshot_20190623161414.png)</p><p>  上图为MyISAM主键索引的存储结构，我们能看到的不同是</p><blockquote><p>1、主键索引树的叶子结点的数据区域没有存放实际的数据，存放的是数据记录的地址。<br>2、数据的存储不是按主键顺序存放的，按写入的顺序存放。</p></blockquote><p>  也就是说innodb引擎数据在物理上是按主键顺序存放，而MyISAM引擎数据在物理上按插入的顺序存放。并且MyISAM的叶子结点不存放数据，所以非聚集索引的存储结构与聚集索引类似，在使用非聚集索引查找数据的时候通过非聚集索引树就能直接找到数据的地址了，不需要<strong>回表</strong>，这比innodb的搜索效率会更高呢！</p><h4 id="索引优化建议？"><a href="#索引优化建议？" class="headerlink" title="索引优化建议？"></a>索引优化建议？</h4><p>  大家经常会在很多的文章或书中能看到一些索引的使用建议，比如说</p><blockquote><p>1、like的模糊查询以%开头，会导致索引失效。<br>2、一个表建的索引尽量不要超过5个。<br>3、尽量使用覆盖索引。<br>4、尽量不要在重复数据多的列上建索引。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL调优</title>
      <link href="/2020/07/03/MySQL%E8%B0%83%E4%BC%98/"/>
      <url>/2020/07/03/MySQL%E8%B0%83%E4%BC%98/</url>
      
        <content type="html"><![CDATA[<h2 id="MySQL调优"><a href="#MySQL调优" class="headerlink" title="MySQL调优"></a>MySQL调优</h2><h4 id="1-性能监控"><a href="#1-性能监控" class="headerlink" title="1. 性能监控"></a>1. 性能监控</h4><p>show profile</p><p>此工具默认是禁用的，可以通过服务器变量在绘画级别动态的修改</p><p><strong>set profiling=1;</strong></p><p>当设置完成之后，在服务器上执行的所有语句，都会测量其耗费的时间和其他一些查询执行状态变更相关的数据。</p><p><strong>select * from emp;</strong></p><p>在mysql的命令行模式下只能显示两位小数的时间，可以使用如下命令查看具体的执行时间</p><p><strong>show profiles;</strong></p><p>执行如下命令可以查看详细的每个步骤的时间：</p><p><strong>show profile for query 1;</strong></p><p><img src="/2020/07/03/MySQL%E8%B0%83%E4%BC%98/image-20200412073731890.png" alt="image-20200412073731890"></p><p>show profiles 查看执行时间<br><img src="/2020/07/03/MySQL%E8%B0%83%E4%BC%98/image-20200412074008668.png" alt="image-20200412074008668"></p><p>只精确到后两位</p><p>show profile 最近执行的sql , 每个步骤多长时间<br><img src="/2020/07/03/MySQL%E8%B0%83%E4%BC%98/image-20200412074108964.png" alt="image-20200412074108964"></p><p>show profile for query 2 查第二个<br><img src="/2020/07/03/MySQL%E8%B0%83%E4%BC%98/image-20200412074312622.png" alt="image-20200412074312622"></p><p>show profile cpu<br><img src="/2020/07/03/MySQL%E8%B0%83%E4%BC%98/image-20200412074403265.png" alt="image-20200412074403265"></p><p><img src="/2020/07/03/MySQL%E8%B0%83%E4%BC%98/image-20200412075426618.png" alt="image-20200412075426618"></p><p><img src="/2020/07/03/MySQL%E8%B0%83%E4%BC%98/image-20200412075506666.png" alt="image-20200412075506666"></p><p><strong>各连接池性能</strong></p><p><img src="/2020/07/03/MySQL%E8%B0%83%E4%BC%98/image-20200412081803049.png" alt="image-20200412081803049"></p><h4 id="2-表结构优化"><a href="#2-表结构优化" class="headerlink" title="2. 表结构优化"></a>2. 表结构优化</h4><p><img src="/2020/07/03/MySQL%E8%B0%83%E4%BC%98/image-20200412082617475.png" alt="image-20200412082617475"></p><p>应该尽量使用可以正确存储数据的最小数据类型，更小的数据类型通常更快，因为它们占用更少的磁盘、内存和CPU缓存，并且处理时需要的CPU周期更少，但是要确保没有低估需要存储的值的范围，如果无法确认哪个数据类型，就选择你认为不会超过范围的最小类型</p><p>案例：</p><p>设计两张表，设计不同的数据类型，查看表的容量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.PreparedStatement;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line">        Connection conn = DriverManager.getConnection(<span class="string">"jdbc:mysql://localhost:3306/db1"</span>,<span class="string">"root"</span>,<span class="string">"123456"</span>);</span><br><span class="line">        PreparedStatement pstmt = conn.prepareStatement(<span class="string">"insert into psn2 values(?,?)"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20000</span>; i++) &#123;</span><br><span class="line">            pstmt.setInt(<span class="number">1</span>,i);</span><br><span class="line">            pstmt.setString(<span class="number">2</span>,i+<span class="string">""</span>);</span><br><span class="line">            pstmt.addBatch();</span><br><span class="line">        &#125;</span><br><span class="line">        pstmt.executeBatch();</span><br><span class="line">        conn.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/07/03/MySQL%E8%B0%83%E4%BC%98/image-20200412082918434.png" alt="image-20200412082918434"></p><p><img src="/2020/07/03/MySQL%E8%B0%83%E4%BC%98/image-20200412083305650.png" alt="image-20200412083305650"></p><p><img src="/2020/07/03/MySQL%E8%B0%83%E4%BC%98/image-20200412083622460.png" alt="image-20200412083622460"></p><p>bigint tinyint 占用空间不同  查询时间也不同</p><p><img src="/2020/07/03/MySQL%E8%B0%83%E4%BC%98/image-20200412083557968.png" alt="image-20200412083557968"></p><p>ip地址转数值 INET_ATON/NTOA</p><p><img src="/2020/07/03/MySQL%E8%B0%83%E4%BC%98/image-20200412083813449.png" alt="image-20200412083813449"></p><p>简单数据类型的操作通常需要更少的CPU周期，例如，</p><p>1、整型比字符操作代价更低，因为字符集和校对规则是字符比较比整型比较更复杂，</p><p>2、使用mysql自建类型而不是字符串来存储日期和时间</p><p>3、用整型存储IP地址</p><p>案例：</p><p>创建两张相同的表，改变日期的数据类型，查看SQL语句执行的速度</p><p><img src="/2020/07/03/MySQL%E8%B0%83%E4%BC%98/image-20200412084513504.png" alt="image-20200412084513504"></p><p>如果查询中包含可为NULL的列，对mysql来说很难优化，因为可为null的列使得索引、索引统计和值比较都更加复杂，坦白来说，通常情况下null的列改为not null带来的性能提升比较小，所有没有必要将所有的表的schema进行修改，但是应该尽量避免设计成可为null的列</p><p><img src="/2020/07/03/MySQL%E8%B0%83%E4%BC%98/image-20200412095640260.png" alt="image-20200412095640260"></p><p>可以使用的几种整数类型：TINYINT，SMALLINT，MEDIUMINT，INT，BIGINT分别使用8，16，24，32，64位存储空间。</p><p>尽量使用满足需求的最小数据类型</p><p><img src="/2020/07/03/MySQL%E8%B0%83%E4%BC%98/image-20200412095744196.png" alt="image-20200412095744196"></p><p>1、char长度固定，即每条数据占用等长字节空间；最大长度是255个字符，适合用在身份证号、手机号等定长字符串</p><p>2、varchar可变程度，可以设置最大长度；最大空间是65535个字节，适合用在长度可变的属性</p><p>3、text不设置长度，当不知道属性的最大长度时，适合用text</p><p>按照查询速度：char&gt;varchar&gt;text</p><p><img src="/2020/07/03/MySQL%E8%B0%83%E4%BC%98/image-20200412095833983.png" alt="image-20200412095833983"></p><p>4k对齐</p><p><img src="/2020/07/03/MySQL%E8%B0%83%E4%BC%98/image-20200412100159575.png" alt="image-20200412100159575"></p><p><img src="/2020/07/03/MySQL%E8%B0%83%E4%BC%98/image-20200412100534927.png" alt="image-20200412100534927"></p><p>MySQL 把每个 BLOB 和 TEXT 值当作一个独立的对象处理。</p><p>两者都是为了存储很大数据而设计的字符串类型，分别采用二进制和字符方式存储。</p><p><img src="/2020/07/03/MySQL%E8%B0%83%E4%BC%98/image-20200412100615434.png" alt="image-20200412100615434"></p><p>1、不要使用字符串类型来存储日期时间数据</p><p>2、日期时间类型通常比字符串占用的存储空间小</p><p>3、日期时间类型在进行查找过滤时可以利用日期来进行比对</p><p>4、日期时间类型还有着丰富的处理函数，可以方便的对时间类型进行日期计算</p><p>5、使用int存储日期时间不如使用timestamp类型</p><p><img src="/2020/07/03/MySQL%E8%B0%83%E4%BC%98/image-20200412101944180.png" alt="image-20200412101944180"></p><p>有时可以使用枚举类代替常用的字符串类型，mysql存储枚举类型会非常紧凑，会根据列表值的数据压缩到一个或两个字节中，mysql在内部会将每个值在列表中的位置保存为整数，并且在表的.frm文件中保存“数字-字符串”映射关系的查找表</p><p> create table enum_test(e enum(‘fish’,’apple’,’dog’) not null);</p><p> insert into enum_test(e) values(‘fish’),(‘dog’),(‘apple’);</p><p> select e+0 from enum_test;</p><p><img src="/2020/07/03/MySQL%E8%B0%83%E4%BC%98/image-20200412101924672.png" alt="image-20200412101924672"></p><p><img src="/2020/07/03/MySQL%E8%B0%83%E4%BC%98/image-20200412102018401.png" alt="image-20200412102018401"></p><p>人们经常使用varchar(15)来存储ip地址，然而，它的本质是32位无符号整数不是字符串，可以使用INET_ATON()和INET_NTOA函数在这两种表示方法之间转换</p><p>案例：</p><p>select inet_aton(‘1.1.1.1’)</p><p>select inet_ntoa(16843009)</p><p><img src="/2020/07/03/MySQL%E8%B0%83%E4%BC%98/image-20200412103739902.png" alt="image-20200412103739902"></p><p><img src="/2020/07/03/MySQL%E8%B0%83%E4%BC%98/image-20200412103806772.png" alt="image-20200412103806772"></p><p><img src="/2020/07/03/MySQL%E8%B0%83%E4%BC%98/image-20200412103858011.png" alt="image-20200412103858011"></p><p><img src="/2020/07/03/MySQL%E8%B0%83%E4%BC%98/image-20200412103937013.png" alt="image-20200412103937013"></p><p><img src="/2020/07/03/MySQL%E8%B0%83%E4%BC%98/image-20200412104012606.png" alt="image-20200412104012606"></p><p><img src="/2020/07/03/MySQL%E8%B0%83%E4%BC%98/image-20200412104627017.png" alt="image-20200412104627017"></p><p><img src="/2020/07/03/MySQL%E8%B0%83%E4%BC%98/image-20200412104731433.png" alt="image-20200412104731433"></p><p>字符集直接决定了数据在MySQL中的存储编码方式，由于同样的内容使用不同字符集表示所占用的空间大小会有较大的差异，所以通过使用合适的字符集，可以帮助我们尽可能减少数据量，进而减少IO操作次数。</p><p><img src="/2020/07/03/MySQL%E8%B0%83%E4%BC%98/image-20200412104755130.png" alt="image-20200412104755130"></p><p>存储引擎的对比</p><p><img src="/2020/07/03/MySQL%E8%B0%83%E4%BC%98/image-20200412104826553.png" alt="image-20200412104826553"></p><p><img src="/2020/07/03/MySQL%E8%B0%83%E4%BC%98/image-20200412104905220.png" alt="image-20200412104905220"></p><p><img src="/2020/07/03/MySQL%E8%B0%83%E4%BC%98/image-20200412104953485.png" alt="image-20200412104953485"></p><p>当我们的表中存在类似于 TEXT 或者是很大的 VARCHAR类型的大字段的时候，如果我们大部分访问这张表的时候都不需要这个字段，我们就该义无反顾的将其拆分到另外的独立表中，以减少常用数据所占用的存储空间。这样做的一个明显好处就是每个数据块中可以存储的数据条数可以大大增加，既减少物理 IO 次数，也能大大提高内存中的缓存命中率。</p><h4 id="3-执行计划及索引优化"><a href="#3-执行计划及索引优化" class="headerlink" title="3. 执行计划及索引优化"></a>3. 执行计划及索引优化</h4><p><img src="/2020/07/03/MySQL%E8%B0%83%E4%BC%98/image-20200412105016620.png" alt="image-20200412105016620"></p><p><img src="/2020/07/03/MySQL%E8%B0%83%E4%BC%98/image-20200412105756164.png" alt="image-20200412105756164"></p><p><img src="/2020/07/03/MySQL%E8%B0%83%E4%BC%98/image-20200412112211639.png" alt="image-20200412112211639"></p><p>想要了解索引的优化方式，必须要对索引的底层原理有所了解</p><p><img src="/2020/07/03/MySQL%E8%B0%83%E4%BC%98/image-20200412112234939.png" alt="image-20200412112234939"></p><p><img src="/2020/07/03/MySQL%E8%B0%83%E4%BC%98/image-20200412112248241.png" alt="image-20200412112248241"></p><p><img src="/2020/07/03/MySQL%E8%B0%83%E4%BC%98/image-20200412112303993.png" alt="image-20200412112303993"></p><p>主键索引不能为null, 唯一键索引可以为空</p><p><img src="/2020/07/03/MySQL%E8%B0%83%E4%BC%98/image-20200412114724008.png" alt="image-20200412114724008"></p><p>回表: where name = ? 通过非主键索引查到主键之后, 回到主键B+树查整行数据</p><p>覆盖索引: select id from where name = ?, 已经有了, 不用回表, 能用尽量用</p><p>最左匹配: name = ? and age = ?  name = ? age = ?<br>                索引name,age, 只能匹配上name,才能用age<br>                更优解 name,age + age ,age占用小</p><p>索引下推: 必须组合索引, name,age , 查name的时候过滤age, 再放到server层, 减少I/O<br>                老版本去除全部name匹配, 在server层匹配age</p><p><img src="/2020/07/03/MySQL%E8%B0%83%E4%BC%98/image-20200412114626563.png" alt="image-20200412114626563"></p><p><img src="/2020/07/03/MySQL%E8%B0%83%E4%BC%98/image-20200412112536777.png" alt="image-20200412112536777"></p><p><img src="/2020/07/03/MySQL%E8%B0%83%E4%BC%98/image-20200412112612390.png" alt="image-20200412112612390"></p><p><img src="/2020/07/03/MySQL%E8%B0%83%E4%BC%98/image-20200412113253441.png" alt="image-20200412113253441"></p><p><img src="/2020/07/03/MySQL%E8%B0%83%E4%BC%98/image-20200412113426265.png" alt="image-20200412113426265"></p><p><img src="/2020/07/03/MySQL%E8%B0%83%E4%BC%98/image-20200412113509952.png" alt="image-20200412113509952"></p><p><img src="/2020/07/03/MySQL%E8%B0%83%E4%BC%98/image-20200412114023050.png" alt="image-20200412114023050"></p><p><img src="/2020/07/03/MySQL%E8%B0%83%E4%BC%98/image-20200412112303993.png" alt="image-20200412112303993"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span><span class="string">` `</span><span class="keyword">table</span><span class="string">` `</span>staffs(</span><br><span class="line">  <span class="string">``</span><span class="keyword">id</span> <span class="string">``</span><span class="built_in">int</span><span class="string">` `</span>primary<span class="string">` `</span><span class="keyword">key</span><span class="string">` `</span>auto_increment,</span><br><span class="line">  <span class="string">``</span><span class="keyword">name</span><span class="string">` `</span><span class="built_in">varchar</span><span class="string">``</span>(<span class="number">24</span>) <span class="string">``</span><span class="keyword">not</span><span class="string">` `</span><span class="literal">null</span><span class="string">` `</span><span class="keyword">default</span><span class="string">` `</span><span class="string">''</span><span class="string">` `</span><span class="keyword">comment</span> <span class="string">``</span><span class="string">'姓名'</span><span class="string">``</span>,</span><br><span class="line">  <span class="string">``</span>age <span class="string">``</span><span class="built_in">int</span><span class="string">` `</span><span class="keyword">not</span><span class="string">` `</span><span class="literal">null</span><span class="string">` `</span><span class="keyword">default</span><span class="string">` `</span><span class="number">0</span> <span class="keyword">comment</span> <span class="string">``</span><span class="string">'年龄'</span><span class="string">``</span>,</span><br><span class="line">  <span class="string">``</span>pos <span class="string">``</span><span class="built_in">varchar</span><span class="string">``</span>(<span class="number">20</span>) <span class="string">``</span><span class="keyword">not</span><span class="string">` `</span><span class="literal">null</span><span class="string">` `</span><span class="keyword">default</span><span class="string">` `</span><span class="string">''</span><span class="string">` `</span><span class="keyword">comment</span> <span class="string">``</span><span class="string">'职位'</span><span class="string">``</span>,</span><br><span class="line">  <span class="string">``</span>add_time <span class="string">``</span><span class="built_in">timestamp</span><span class="string">` `</span><span class="keyword">not</span><span class="string">` `</span><span class="literal">null</span><span class="string">` `</span><span class="keyword">default</span><span class="string">` `</span><span class="keyword">current_timestamp</span><span class="string">` `</span><span class="keyword">comment</span> <span class="string">``</span><span class="string">'入职时间'</span></span><br><span class="line"> <span class="string">``</span>) <span class="keyword">charset</span> utf8 <span class="keyword">comment</span> <span class="string">``</span><span class="string">'员工记录表'</span><span class="string">``</span>;</span><br></pre></td></tr></table></figure><p>———–<code>alter</code> <code>table</code> <code>staffs ``add</code> <code>index</code> <code>idx_nap(``name``, age, pos);</code></p><p><img src="/2020/07/03/MySQL%E8%B0%83%E4%BC%98/image-20200412122811227.png" alt="image-20200412122811227"></p><p><img src="/2020/07/03/MySQL%E8%B0%83%E4%BC%98/image-20200412122909739.png" alt="image-20200412122909739"></p><p><img src="/2020/07/03/MySQL%E8%B0%83%E4%BC%98/image-20200412122954509.png" alt="image-20200412122954509"></p><p><img src="/2020/07/03/MySQL%E8%B0%83%E4%BC%98/image-20200412123132925.png" alt="image-20200412123132925"></p><p>顺序可变</p><p><img src="/2020/07/03/MySQL%E8%B0%83%E4%BC%98/image-20200412123310351.png" alt="image-20200412123310351"></p><p>只访问索引的查询, 索引覆盖, Extra = Using index</p><p><img src="/2020/07/03/MySQL%E8%B0%83%E4%BC%98/image-20200412123430977.png" alt="image-20200412123430977"></p><p><img src="/2020/07/03/MySQL%E8%B0%83%E4%BC%98/image-20200412123618924.png" alt="image-20200412123618924"></p><p>当需要存储大量的URL，并且根据URL进行搜索查找，如果使用B+树，存储的内容就会很大</p><p>select id from url where url=””</p><p>也可以利用将url使用CRC32做哈希，可以使用以下查询方式：</p><p>select id fom url where url=”” and url_crc=CRC32(“”)</p><p>此查询性能较高原因是使用体积很小的索引来完成查找</p><p><img src="/2020/07/03/MySQL%E8%B0%83%E4%BC%98/image-20200412123645897.png" alt="image-20200412123645897"></p><p><img src="/2020/07/03/MySQL%E8%B0%83%E4%BC%98/image-20200412124343123.png" alt="image-20200412124343123"></p><p><img src="/2020/07/03/MySQL%E8%B0%83%E4%BC%98/image-20200412124438272.png" alt="image-20200412124438272"></p><p><img src="/2020/07/03/MySQL%E8%B0%83%E4%BC%98/image-20200412133605454.png" alt="image-20200412133605454"></p><p><img src="/2020/07/03/MySQL%E8%B0%83%E4%BC%98/image-20200412133241914.png" alt="image-20200412133241914"></p><p><img src="/2020/07/03/MySQL%E8%B0%83%E4%BC%98/image-20200412133756408.png" alt="image-20200412133756408"></p><p><img src="/2020/07/03/MySQL%E8%B0%83%E4%BC%98/image-20200412133853963.png" alt="image-20200412133853963"></p><p><img src="/2020/07/03/MySQL%E8%B0%83%E4%BC%98/image-20200412134358329.png" alt="image-20200412134358329"></p><p>explain执行计划, 看type : system -&gt; const -&gt; ref -&gt; range -&gt; index -&gt; all</p><p><img src="/2020/07/03/MySQL%E8%B0%83%E4%BC%98/image-20200412134254381.png" alt="image-20200412134254381"></p><p><img src="/2020/07/03/MySQL%E8%B0%83%E4%BC%98/image-20200412134421719.png" alt="image-20200412134421719"></p><p>前缀索引, 较少索引占用, 较少磁盘I/O, 提高效率<br><img src="/2020/07/03/MySQL%E8%B0%83%E4%BC%98/image-20200412163826959.png" alt="image-20200412163826959"></p><p><img src="/2020/07/03/MySQL%E8%B0%83%E4%BC%98/image-20200412163701662.png" alt="image-20200412163701662"></p><p><img src="/2020/07/03/MySQL%E8%B0%83%E4%BC%98/image-20200412163947324.png" alt="image-20200412163947324"></p><p><img src="/2020/07/03/MySQL%E8%B0%83%E4%BC%98/image-20200412164838168.png" alt="image-20200412164838168"></p><p>Cardinality 近似值596 实际599<br>Cardinality 基数  Hyperloglog算法</p><p><img src="/2020/07/03/MySQL%E8%B0%83%E4%BC%98/image-20200412164524956.png" alt="image-20200412164524956"></p><p>Redis, Kylin , 都用到基数</p><p>使用索引扫描排序 , 使用索引列排序, 默认asc升序</p><p><img src="/2020/07/03/MySQL%E8%B0%83%E4%BC%98/image-20200412165909966.png" alt="image-20200412165909966"></p><p>in, or , union all 比较, 最好用in</p><p><img src="/2020/07/03/MySQL%E8%B0%83%E4%BC%98/image-20200412171044627.png" alt="image-20200412171044627"></p><p>exist</p><p><img src="/2020/07/03/MySQL%E8%B0%83%E4%BC%98/image-20200412171743853.png" alt="image-20200412171743853"></p><p><img src="/2020/07/03/MySQL%E8%B0%83%E4%BC%98/image-20200412165211929.png" alt="image-20200412165211929"></p><p>join</p><p><img src="/2020/07/03/MySQL%E8%B0%83%E4%BC%98/image-20200412220944555.png" alt="image-20200412220944555"></p><p><img src="/2020/07/03/MySQL%E8%B0%83%E4%BC%98/image-20200412174505199.png" alt="image-20200412174505199"></p><p><img src="/2020/07/03/MySQL%E8%B0%83%E4%BC%98/image-20200412221229021.png" alt="image-20200412221229021"></p><p><img src="/2020/07/03/MySQL%E8%B0%83%E4%BC%98/image-20200413062608592.png" alt="image-20200413062608592"></p><h4 id="4-查询优化"><a href="#4-查询优化" class="headerlink" title="4. 查询优化"></a>4. 查询优化</h4><p><img src="/2020/07/03/MySQL%E8%B0%83%E4%BC%98/image-20200413063315696.png" alt="image-20200413063315696"></p><p>在编写快速的查询之前，需要清楚一点，真正重要的是响应时间，而且要知道在整个SQL语句的执行过程中每个步骤都花费了多长时间，要知道哪些步骤是拖垮执行效率的关键步骤，想要做到这点，必须要知道查询的生命周期，然后进行优化，不同的应用场景有不同的优化方式，不要一概而论，具体情况具体分析，</p><p><img src="/2020/07/03/MySQL%E8%B0%83%E4%BC%98/image-20200413063524755.png" alt="image-20200413063524755"></p><p><img src="/2020/07/03/MySQL%E8%B0%83%E4%BC%98/image-20200413063539648.png" alt="image-20200413063539648"></p><p><img src="/2020/07/03/MySQL%E8%B0%83%E4%BC%98/image-20200413063640036.png" alt="image-20200413063640036"></p><p>数据量大, 不会用索引排序, 阈值约30%</p><p><img src="/2020/07/03/MySQL%E8%B0%83%E4%BC%98/image-20200413064517705.png" alt="image-20200413064517705"></p><p><img src="/2020/07/03/MySQL%E8%B0%83%E4%BC%98/image-20200413064751910.png" alt="image-20200413064751910"></p><p>我们常常会误以为mysql会只返回需要的数据，实际上mysql却是先返回全部结果再进行计算，在日常的开发习惯中，经常是先用select语句查询大量的结果，然后获取前面的N行后关闭结果集。<br>优化方式是在查询后面添加limit</p><p><img src="/2020/07/03/MySQL%E8%B0%83%E4%BC%98/image-20200413064826769.png" alt="image-20200413064826769"></p><p>select * from actor inner join film_actor using(actor_id) inner join film using(film_id) where film.title=’Academy Dinosaur’;</p><p>select actor.* from actor…;</p><p><img src="/2020/07/03/MySQL%E8%B0%83%E4%BC%98/image-20200413064946925.png" alt="image-20200413064946925"></p><p>在公司的企业需求中，禁止使用select *,虽然这种方式能够简化开发，但是会影响查询的性能，所以尽量不要使用</p><p><img src="/2020/07/03/MySQL%E8%B0%83%E4%BC%98/image-20200413065009204.png" alt="image-20200413065009204"></p><p>如果需要不断的重复执行相同的查询，且每次返回完全相同的数据，因此，基于这样的应用场景，我们可以将这部分数据缓存起来，这样的话能够提高查询效率</p><p><img src="/2020/07/03/MySQL%E8%B0%83%E4%BC%98/image-20200413070428641.png" alt="image-20200413070428641"></p><p><strong>查询缓存:</strong><br>在解析一个查询语句之前，如果查询缓存是打开的，那么mysql会优先检查这个查询是否命中查询缓存中的数据，如果查询恰好命中了查询缓存，那么会在返回结果之前会检查用户权限，如果权限没有问题，那么mysql会跳过所有的阶段，就直接从缓存中拿到结果并返回给客户端</p><p><strong>查询优化处理:</strong><br>mysql查询完缓存之后会经过以下几个步骤：解析SQL、预处理、优化SQL执行计划，这几个步骤出现任何的错误，都可能会终止查询</p><p><strong>语法解析器和预处理:</strong><br>mysql通过关键字将SQL语句进行解析，并生成一颗解析树，mysql解析器将使用mysql语法规则验证和解析查询，例如验证使用使用了错误的关键字或者顺序是否正确等等，预处理器会进一步检查解析树是否合法，例如表名和列名是否存在，是否有歧义，还会验证权限等等</p><p><strong>查询优化器:</strong><br>当语法树没有问题之后，相应的要由优化器将其转成执行计划，一条查询语句可以使用非常多的执行方式，最后都可以得到对应的结果，但是不同的执行方式带来的效率是不同的，优化器的最主要目的就是要选择最有效的执行计划<br>mysql使用的是基于成本的优化器，在优化的时候会尝试预测一个查询使用某种查询计划时候的成本，并选择其中成本最小的一个<br>CBU: 基于成本优化 (MySQL)<br>RBU: 基于规则优化</p><p><img src="/2020/07/03/MySQL%E8%B0%83%E4%BC%98/image-20200413070948481.png" alt="image-20200413070948481"></p><p><img src="/2020/07/03/MySQL%E8%B0%83%E4%BC%98/image-20200413071002617.png" alt="image-20200413071002617"></p><p><img src="/2020/07/03/MySQL%E8%B0%83%E4%BC%98/image-20200413071029245.png" alt="image-20200413071029245"></p><p>Context 上下文, 某一次会话中, 之前执行的操作对当前SQL语句的影响</p><p><img src="/2020/07/03/MySQL%E8%B0%83%E4%BC%98/image-20200413072014177.png" alt="image-20200413072014177"></p><p>优化limmit10000,5</p><p><img src="/2020/07/03/MySQL%E8%B0%83%E4%BC%98/image-20200413174813937.png" alt="image-20200413174813937"></p><p><img src="/2020/07/03/MySQL%E8%B0%83%E4%BC%98/image-20200413073459587.png" alt="image-20200413073459587"></p><p><img src="/2020/07/03/MySQL%E8%B0%83%E4%BC%98/image-20200413071113682.png" alt="image-20200413071113682"></p><p>两次传输排序:<br>第一次数据读取是将需要排序的字段读取出来，然后进行排序，第二次是将排好序的结果按照需要去读取数据行。<br>这种方式效率比较低，原因是第二次读取数据的时候因为已经排好序，需要去读取所有记录而此时更多的是随机IO，读取数据成本会比较高<br>两次传输的优势，在排序的时候存储尽可能少的数据，让排序缓冲区可以尽可能多的容纳行数来进行排序操作</p><p>单次传输排序:<br>先读取查询所需要的所有列，然后再根据给定列进行排序，最后直接返回排序结果，此方式只需要一次顺序IO读取所有的数据，而无须任何的随机IO，问题在于查询的列特别多的时候，会占用大量的存储空间，无法存储大量的数据</p><p><img src="/2020/07/03/MySQL%E8%B0%83%E4%BC%98/image-20200413074455178.png" alt="image-20200413074455178"></p><p>count(1)和count(*)一样</p><p>count(field)不包含字段值为NULL的记录。count(<em>)包含NULL记录。select(</em>)与select(1) 在InnoDB中性能没有任何区别，处理方式相同。官方文档描述如下：InnoDB handles SELECT COUNT(*) and SELECT COUNT(1) operations in the same way. There is no performance difference.</p><p><img src="/2020/07/03/MySQL%E8%B0%83%E4%BC%98/image-20200413175829196.png" alt="image-20200413175829196"></p><p><img src="/2020/07/03/MySQL%E8%B0%83%E4%BC%98/image-20200413175910030.png" alt="image-20200413175910030"></p><p><img src="/2020/07/03/MySQL%E8%B0%83%E4%BC%98/image-20200413175928842.png" alt="image-20200413175928842"></p><p><img src="/2020/07/03/MySQL%E8%B0%83%E4%BC%98/image-20200413180003988.png" alt="image-20200413180003988"></p><p>自定义变量, 加一列排序</p><p><img src="/2020/07/03/MySQL%E8%B0%83%E4%BC%98/image-20200413180538800.png" alt="image-20200413180538800"></p><p>时间变量</p><p><img src="/2020/07/03/MySQL%E8%B0%83%E4%BC%98/image-20200413181235174.png" alt="image-20200413181235174"></p><p><img src="/2020/07/03/MySQL%E8%B0%83%E4%BC%98/image-20200413181310576.png" alt="image-20200413181310576"></p><p>用变量, 出错, order by 可能会先与where执行</p><p><img src="/2020/07/03/MySQL%E8%B0%83%E4%BC%98/image-20200413181838016.png" alt="image-20200413181838016"></p><p><img src="/2020/07/03/MySQL%E8%B0%83%E4%BC%98/image-20200413180038569.png" alt="image-20200413180038569"></p><p><img src="/2020/07/03/MySQL%E8%B0%83%E4%BC%98/image-20200413182856790.png" alt="image-20200413182856790"></p><p><img src="/2020/07/03/MySQL%E8%B0%83%E4%BC%98/image-20200413190620431.png" alt="image-20200413190620431"><br>5.5最多分1024ge<br>5.7  8196</p><p><img src="/2020/07/03/MySQL%E8%B0%83%E4%BC%98/image-20200413183316150.png" alt="image-20200413183316150"></p><p>range分区</p><p><img src="/2020/07/03/MySQL%E8%B0%83%E4%BC%98/image-20200413183545258.png" alt="image-20200413183545258"></p><p><img src="/2020/07/03/MySQL%E8%B0%83%E4%BC%98/image-20200413183954569.png" alt="image-20200413183954569"></p><p><img src="/2020/07/03/MySQL%E8%B0%83%E4%BC%98/image-20200414072046877.png" alt="image-20200414072046877"></p><p><img src="/2020/07/03/MySQL%E8%B0%83%E4%BC%98/image-20200414072111984.png" alt="image-20200414072111984"></p><h4 id="5-服务器参数优化"><a href="#5-服务器参数优化" class="headerlink" title="5. 服务器参数优化"></a>5. 服务器参数优化</h4><p><img src="/2020/07/03/MySQL%E8%B0%83%E4%BC%98/image-20200414072233347.png" alt="image-20200414072233347"></p><p><img src="/2020/07/03/MySQL%E8%B0%83%E4%BC%98/image-20200414072319805.png" alt="image-20200414072319805"></p><p><img src="/2020/07/03/MySQL%E8%B0%83%E4%BC%98/image-20200414072434007.png" alt="image-20200414072434007"></p><p><img src="/2020/07/03/MySQL%E8%B0%83%E4%BC%98/image-20200414073456938.png" alt="image-20200414073456938"></p><p><img src="/2020/07/03/MySQL%E8%B0%83%E4%BC%98/image-20200414072507555.png" alt="image-20200414072507555"></p><p><img src="/2020/07/03/MySQL%E8%B0%83%E4%BC%98/image-20200414073531928.png" alt="image-20200414073531928"></p><p><strong>Redo log (InnoDB存储引擎中)</strong></p><p>Redo log Undo log 都属于InnoDB<br>Bin log 属于MySQL server<br>四种特性<br>A原子性, undo log<br>C最重要, 一致性是根本追求 通过AID实现<br>I 隔离级别 通过锁实现<br>D 持久性通过redo log<br>Redo log 循环写</p><p><img src="/2020/07/03/MySQL%E8%B0%83%E4%BC%98/image-20200414074327779.png" alt="image-20200414074327779"></p><p>fsync() 系统调用<br><img src="/2020/07/03/MySQL%E8%B0%83%E4%BC%98/image-20200414074932501.png" alt="image-20200414074932501"></p><p>DML增删改<br>持久化三种方式<br>第二种最安全<br>性能,安全权衡</p><p><img src="/2020/07/03/MySQL%E8%B0%83%E4%BC%98/image-20200414075057350.png" alt="image-20200414075057350"></p><p><strong>Undo log 实现原子原子性 (InnoDB存储引擎中)</strong></p><p><img src="/2020/07/03/MySQL%E8%B0%83%E4%BC%98/image-20200414080020674.png" alt="image-20200414080020674"></p><p>*<em>Bin log *</em></p><p>MyISAM不支持事务, 只能用bin log</p><p><img src="/2020/07/03/MySQL%E8%B0%83%E4%BC%98/image-20200414080406899.png" alt="image-20200414080406899"></p><p><img src="/2020/07/03/MySQL%E8%B0%83%E4%BC%98/image-20200414080806807.png" alt="image-20200414080806807"></p><p><img src="/2020/07/03/MySQL%E8%B0%83%E4%BC%98/image-20200414082007433.png" alt="image-20200414082007433"></p><p>数据和日志分开, 保证两个日志数据一致再从内存写到磁盘</p><p><img src="/2020/07/03/MySQL%E8%B0%83%E4%BC%98/image-20200414082026834.png" alt="image-20200414082026834"></p><p>数据安全问题<br><img src="/2020/07/03/MySQL%E8%B0%83%E4%BC%98/image-20200414082906217.png" alt="image-20200414082906217"></p><p><img src="/2020/07/03/MySQL%E8%B0%83%E4%BC%98/image-20200415182856782.png" alt="image-20200415182856782"></p><p><img src="/2020/07/03/MySQL%E8%B0%83%E4%BC%98/image-20200415184934017.png" alt="image-20200415184934017"></p><p><img src="/2020/07/03/MySQL%E8%B0%83%E4%BC%98/image/MySQL%E8%B0%83%E4%BC%98/image-20200415184957598.png" alt="image-20200415184957598"></p>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL索引优化案例分析</title>
      <link href="/2020/06/13/MySQL%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/"/>
      <url>/2020/06/13/MySQL%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL之覆盖索引、最左前缀、索引下推案例"><a href="#MySQL之覆盖索引、最左前缀、索引下推案例" class="headerlink" title="MySQL之覆盖索引、最左前缀、索引下推案例"></a>MySQL之覆盖索引、最左前缀、索引下推案例</h1><h4 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h4><p>mysql的innodb引擎通过搜索树方式实现索引，索引类型分为主键索引和二级索引（非主键索引），主键索引树中，叶子结点保存着主键即对应行的全部数据；而二级索引树中，叶子结点保存着索引值和主键值，当使用二级索引进行查询时，需要进行回表操作。假如我们现在有如下表结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE &#96;user_table&#96; (</span><br><span class="line">  &#96;id&#96; int(11) unsigned NOT NULL AUTO_INCREMENT,</span><br><span class="line">  &#96;username&#96; varchar(255) NOT NULL,</span><br><span class="line">  &#96;password&#96; varchar(255) DEFAULT NULL,</span><br><span class="line">  &#96;age&#96; int(11) unsigned Not NULL,</span><br><span class="line">  PRIMARY KEY (&#96;id&#96;),</span><br><span class="line">  key (&#96;username&#96;)</span><br><span class="line">) ENGINE&#x3D;InnoDB  DEFAULT CHARSET&#x3D;utf8</span><br></pre></td></tr></table></figure><p>执行语句(A) select id from user_table where username = ‘lzs’时，因为username索引树的叶子结点上保存有username和id的值，所以通过username索引树查找到id后，我们就已经得到所需的数据了，这时候就不需要再去主键索引上继续查找了。<br>执行语句(B) select password from user_table where username = ‘lzs’时，流程如下</p><blockquote><p>1、username索引树上找到username=lzs对应的主键id<br>2、通过回表在主键索引树上找到满足条件的数据</p></blockquote><p>由上面可知，当sql语句的所求查询字段（select列）和查询条件字段（where子句）全都包含在一个索引中，可以直接使用索引查询而不需要回表。这就是覆盖索引，通过使用覆盖索引，可以减少搜索树的次数，是常用的性能优化手段。<br>例如上面的语句B是一个高频查询的语句，我们可以建立(username,password)的联合索引，这样，查询的时候就不需要再去回表操作了，可以提高查询效率。当然，添加索引是有维护代价的，所以添加时也要权衡一下。</p><h4 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h4><p>mysql的b+树索引遵循“最左前缀”原则，继续以上面的例子来说明，为了提高语句B的执行速度，我们添加了一个联合索引（username,password）,特别注意这个联合索引的顺序，如果我们颠倒下顺序改成（password,username),这样查询能使用这个索引吗？答案是不能的！这是最左前缀的第一层含义：<strong>联合索引的多个字段中，只有当查询条件为联合索引的一个字段时，查询才能使用该索引。</strong><br>现在，假设我们有一下三种查询情景：<br>1、查出用户名的第一个字是“张”开头的人的密码。即查询条件子句为”where username like ‘张%’”<br>2、查处用户名中含有“张”字的人的密码。即查询条件子句为”where username like ‘%张%’”<br>3、查出用户名以“张”字结尾的人的密码。即查询条件子句为”where username like ‘%张’”</p><p>以上三种情况下，只有第1种能够使用（username,password）联合索引来加快查询速度。这就是最左前缀的第二层含义：<strong>索引可以用于查询条件字段为索引字段，根据字段值最左若干个字符进行的模糊查询。</strong></p><p>维护索引需要代价，所以有时候我们可以利用“最左前缀”原则减少索引数量，上面的（username,password）索引，也可用于根据username查询age的情况。当然，使用这个索引去查询age的时候是需要进行回表的，当这个需求（根据username查询age）也是高频请求时，我们可以创建（username,password,age）联合索引，这样，我们需要维护的索引数量不变。</p><p>创建索引时，我们也要考虑空间代价，使用较少的空间来创建索引<br>假设我们现在不需要通过username查询password了，相反，经常需要通过username查询age或通过age查询username,这时候，删掉（username,password）索引后，我们需要创建新的索引，我们有两种选择<br>1、（username,age）联合索引+age字段索引<br>2、（age,username）联合索引+username单字段索引<br>一般来说，username字段比age字段大的多，所以，我们应选择第一种，索引占用空间较小。</p><h4 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h4><p>对于user_table表，我们现在有（username,age）联合索引<br>如果现在有一个需求，查出名称中以“张”开头且年龄小于等于10的用户信息，语句C如下：”select * from user_table where username like ‘张%’ and age &gt; 10”.<br>语句C有两种执行可能：<br>1、根据（username,age）联合索引查询所有满足名称以“张”开头的索引，然后回表查询出相应的全行数据，然后再筛选出满足年龄小于等于10的用户数据。过程如下图。</p><p><img src="/2020/06/13/MySQL%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/5148507-1684dba15ec6fb78.png" alt="img"></p><p>2、根据（username,age）联合索引查询所有满足名称以“张”开头的索引，然后直接再筛选出年龄小于等于10的索引，之后再回表查询全行数据。过程如下图。</p><p><img src="/2020/06/13/MySQL%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/5148507-6179190f8409cf3b.png" alt="img"></p><p>明显的，第二种方式需要回表查询的全行数据比较少，这就是mysql的索引下推。mysql默认启用索引下推，我们也可以通过修改系统变量optimizer_switch的index_condition_pushdown标志来控制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET optimizer_switch &#x3D; &#39;index_condition_pushdown&#x3D;off&#39;;</span><br></pre></td></tr></table></figure><ul><li><p>注意点：<br>1、innodb引擎的表，索引下推只能用于二级索引。</p><blockquote><p>就像之前提到的，innodb的主键索引树叶子结点上保存的是全行数据，所以这个时候索引下推并不会起到减少查询全行数据的效果。</p></blockquote><p>2、索引下推一般可用于所求查询字段（select列）不是/不全是联合索引的字段，查询条件为多条件查询且查询条件子句（where/order by）字段全是联合索引。</p><blockquote><p>假设表t有联合索引（a,b）,下面语句可以使用索引下推提高效率<br>select * from t where a &gt; 2 and b &gt; 10;</p></blockquote></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL事务测试用例</title>
      <link href="/2020/05/03/MySQL%E4%BA%8B%E5%8A%A1%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B/"/>
      <url>/2020/05/03/MySQL%E4%BA%8B%E5%8A%A1%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="mysql事务测试"><a href="#mysql事务测试" class="headerlink" title="mysql事务测试"></a>mysql事务测试</h1><p>1、打开mysql的命令行，将自动提交事务给关闭</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--查看是否是自动提交 1表示开启，0表示关闭</span></span><br><span class="line"><span class="keyword">select</span> @@autocommit;</span><br><span class="line"><span class="comment">--设置关闭</span></span><br><span class="line"><span class="keyword">set</span> autocommit = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>2、数据准备</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--创建数据库</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> tran;</span><br><span class="line"><span class="comment">--切换数据库 两个窗口都执行</span></span><br><span class="line"><span class="keyword">use</span> tran;</span><br><span class="line"><span class="comment">--准备数据</span></span><br><span class="line"> <span class="keyword">create</span> <span class="keyword">table</span> psn(<span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span>,<span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">10</span>)) <span class="keyword">engine</span>=<span class="keyword">innodb</span>;</span><br><span class="line"><span class="comment">--插入数据</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> psn <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'zhangsan'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> psn <span class="keyword">values</span>(<span class="number">2</span>,<span class="string">'lisi'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> psn <span class="keyword">values</span>(<span class="number">3</span>,<span class="string">'wangwu'</span>);</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure><p>3、测试事务</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--事务包含四个隔离级别：从上往下，隔离级别越来越高，意味着数据越来越安全</span></span><br><span class="line">read uncommitted; <span class="comment">--读未提交</span></span><br><span class="line">read commited;<span class="comment">--读已提交</span></span><br><span class="line">repeatable read;<span class="comment">--可重复读</span></span><br><span class="line">(seariable)<span class="comment">--序列化执行，串行执行</span></span><br><span class="line"><span class="comment">--产生数据不一致的情况：</span></span><br><span class="line">脏读</span><br><span class="line">不可重复读</span><br><span class="line">幻读</span><br></pre></td></tr></table></figure><table><thead><tr><th>隔离级别</th><th>异常情况</th><th></th><th>异常情况</th></tr></thead><tbody><tr><td>读未提交</td><td>脏读</td><td>不可重复读</td><td>幻读</td></tr><tr><td>读已提交</td><td></td><td>不可重复读</td><td>幻读</td></tr><tr><td>可重复读</td><td></td><td></td><td>幻读</td></tr><tr><td>序列化</td><td></td><td></td><td></td></tr></tbody></table><p>4、测试1：脏读 read uncommitted</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">session</span> <span class="keyword">transaction</span> <span class="keyword">isolation</span> <span class="keyword">level</span> <span class="keyword">read</span> uncommitted;</span><br><span class="line">A:<span class="keyword">start</span> <span class="keyword">transaction</span>;</span><br><span class="line">A:<span class="keyword">select</span> * <span class="keyword">from</span> psn;</span><br><span class="line">B:<span class="keyword">start</span> <span class="keyword">transaction</span>;</span><br><span class="line">B:<span class="keyword">select</span> * <span class="keyword">from</span> psn;</span><br><span class="line">A:<span class="keyword">update</span> psn <span class="keyword">set</span> <span class="keyword">name</span>=<span class="string">'msb'</span>;</span><br><span class="line">A:selecet * from psn</span><br><span class="line">B:<span class="keyword">select</span> * <span class="keyword">from</span> psn;  <span class="comment">--读取的结果msb。产生脏读，因为A事务并没有commit，读取到了不存在的数据</span></span><br><span class="line">A:<span class="keyword">commit</span>;</span><br><span class="line">B:<span class="keyword">select</span> * <span class="keyword">from</span> psn; <span class="comment">--读取的数据是msb,因为A事务已经commit，数据永久的被修改</span></span><br></pre></td></tr></table></figure><p>5、测试2：当使用read committed的时候，就不会出现脏读的情况了，当时会出现不可重复读的问题</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">session</span> <span class="keyword">transaction</span> <span class="keyword">isolation</span> <span class="keyword">level</span> <span class="keyword">read</span> committed;</span><br><span class="line">A:<span class="keyword">start</span> <span class="keyword">transaction</span>;</span><br><span class="line">A:<span class="keyword">select</span> * <span class="keyword">from</span> psn;</span><br><span class="line">B:<span class="keyword">start</span> <span class="keyword">transaction</span>;</span><br><span class="line">B:<span class="keyword">select</span> * <span class="keyword">from</span> psn;</span><br><span class="line"><span class="comment">--执行到此处的时候发现，两个窗口读取的数据是一致的</span></span><br><span class="line">A:<span class="keyword">update</span> psn <span class="keyword">set</span> <span class="keyword">name</span> =<span class="string">'zhangsan'</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span>;</span><br><span class="line">A:<span class="keyword">select</span> * <span class="keyword">from</span> psn;</span><br><span class="line">B:<span class="keyword">select</span> * <span class="keyword">from</span> psn;</span><br><span class="line"><span class="comment">--执行到此处发现两个窗口读取的数据不一致，B窗口中读取不到更新的数据</span></span><br><span class="line">A:<span class="keyword">commit</span>;</span><br><span class="line">A:<span class="keyword">select</span> * <span class="keyword">from</span> psn;<span class="comment">--读取到更新的数据</span></span><br><span class="line">B:<span class="keyword">select</span> * <span class="keyword">from</span> psn;<span class="comment">--也读取到更新的数据</span></span><br><span class="line"><span class="comment">--发现同一个事务中多次读取数据出现不一致的情况</span></span><br></pre></td></tr></table></figure><p>6、测试3：当使用repeatable read的时候(按照上面的步骤操作)，就不会出现不可重复读的问题，但是会出现幻读的问题</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">session</span> <span class="keyword">transaction</span> <span class="keyword">isolation</span> <span class="keyword">level</span> repeatable <span class="keyword">read</span>;</span><br><span class="line">A:<span class="keyword">start</span> <span class="keyword">transaction</span>;</span><br><span class="line">A:<span class="keyword">select</span> * <span class="keyword">from</span> psn;</span><br><span class="line">B:<span class="keyword">start</span> <span class="keyword">transaction</span>;</span><br><span class="line">B:<span class="keyword">select</span> * <span class="keyword">from</span> psn;</span><br><span class="line"><span class="comment">--此时两个窗口读取的数据是一致的</span></span><br><span class="line">A:<span class="keyword">insert</span> <span class="keyword">into</span> psn <span class="keyword">values</span>(<span class="number">4</span>,<span class="string">'sisi'</span>);</span><br><span class="line">A:<span class="keyword">commit</span>;</span><br><span class="line">A:<span class="keyword">select</span> * <span class="keyword">from</span> psn;<span class="comment">--读取到添加的数据</span></span><br><span class="line">B:<span class="keyword">select</span> * <span class="keyword">from</span> psn;<span class="comment">--读取不到添加的数据</span></span><br><span class="line">B:<span class="keyword">insert</span> <span class="keyword">into</span> psn <span class="keyword">values</span>(<span class="number">4</span>,<span class="string">'sisi'</span>);<span class="comment">--报错，无法插入数据</span></span><br><span class="line"><span class="comment">--此时发现读取不到数据，但是在插入的时候不允许插入，出现了幻读，设置更高级别的隔离级别即可解决</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初识Spring</title>
      <link href="/2020/04/05/%E5%88%9D%E8%AF%86Spring/"/>
      <url>/2020/04/05/%E5%88%9D%E8%AF%86Spring/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring初识"><a href="#Spring初识" class="headerlink" title="Spring初识"></a>Spring初识</h1><h3 id="1、框架"><a href="#1、框架" class="headerlink" title="1、框架"></a>1、框架</h3><p>​        框架就是一些类和接口的集合，通过这些类和接口协调来完成一系列的程序实现。JAVA框架可以分为三层：表示层，业务层和物理层。框架又叫做开发中的半成品，它不能提供整个WEB应用程序的所有东西，但是有了框架，我们就可以集中精力进行业务逻辑的开发而不用去关心它的技术实现以及一些辅助的业务逻辑。大家熟知的Structs和Spring就是表示层和业务层框架的强力代表。（官方）</p><p>​        白话：</p><p>​        框架就是某些个人或者组织定义了一系列的类或者接口，提前定义好了一些实现，用户可以在这些类和接口的基础之上，使用这些类来迅速的形成某个领域或者某个行业的解决方案，简化开发的过程，提高开发的效率。就好比：你要盖一座房子，先把柱子，房梁等先建设好，然后只需要向房子中填充就可以了，可以按照自己的需求进行设计，其实我们做的项目、系统都是类似的方式，如果所有的代码全部都需要自己实现，那么这个工程就太庞大了，所以可以先创建出一些基础的模板框架，开发人员只需要按照自己的需求向架子中填充内容，完成自己独特需求即可，这就是框架存在的意义。其实我们之前定义的简单的工具类这些东西也是类似的原理，只不过比较单一简单而已，因此，在现在的很多项目系统开发的过程中都是利用框架进行开发。</p><h3 id="2、spring（春天）"><a href="#2、spring（春天）" class="headerlink" title="2、spring（春天）"></a>2、spring（春天）</h3><p><strong>架构设计</strong></p><p>​        随着互联网的发展，网站应用的规模不断扩大，常规的垂直应用架构已无法应对，分布式服务架构以及流动计算架构势在必行，亟需一个治理系统确保架构有条不紊的演进。</p><p><img src="/2020/04/05/%E5%88%9D%E8%AF%86Spring/dubbo-architecture-roadmap-1596445585761.jpg" alt="image"></p><p>​        单一应用架构</p><p>​        当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。此时，用于简化增删改查工作量的数据访问框架(ORM)是关键。</p><p>​        垂直应用架构</p><p>​        当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，提升效率的方法之一是将应用拆成互不相干的几个应用，以提升效率。此时，用于加速前端页面开发的Web框架(MVC)是关键。</p><p>​        分布式服务架构</p><p>​        当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的分布式服务框架(RPC)是关键。</p><p>​        流动计算架构</p><p>​        当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于提高机器利用率的资源调度和治理中心(SOA)是关键。</p><p><strong>Java主流框架演变之路</strong></p><p>​        1、JSP+Servlet+JavaBean</p><p>​        2、MVC三层架构</p><p><img src="/2020/04/05/%E5%88%9D%E8%AF%86Spring/mvc-1596445585762.png" alt="mvc"></p><p>​        3、使用EJB进行应用的开发，但是EJB是重量级框架（在使用的时候，过多的接口和依赖，侵入性强），在使用上比较麻烦</p><p>​        4、Struts1/Struts2+Hibernate+Spring</p><p>​        5、SpringMVC+Mybatis+Spring</p><p>​        6、SpringBoot开发，约定大于配置</p><p><strong>Spring官网</strong></p><p>官网地址：<a href="https://spring.io/projects/spring-framework#overview" target="_blank" rel="noopener">https://spring.io/projects/spring-framework#overview</a></p><p>压缩包下载地址：<a href="https://repo.spring.io/release/org/springframework/spring/" target="_blank" rel="noopener">https://repo.spring.io/release/org/springframework/spring/</a></p><p>源码地址：<a href="https://github.com/spring-projects/spring-framework" target="_blank" rel="noopener">https://github.com/spring-projects/spring-framework</a></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Spring makes it easy to create Java enterprise applications. It provides everything you need to embrace the Java language in an enterprise environment, with support for Groovy and Kotlin as alternative languages on the JVM, and with the flexibility to create many kinds of architectures depending on an application’s needs. As of Spring Framework 5.1, Spring requires JDK 8+ (Java SE 8+) and provides out-of-the-box support for JDK 11 LTS. Java SE 8 update 60 is suggested as the minimum patch release for Java 8, but it is generally recommended to use a recent patch release.</span><br><span class="line"></span><br><span class="line">Spring supports a wide range of application scenarios. In a large enterprise, applications often exist for a long time and have to run on a JDK and application server whose upgrade cycle is beyond developer control. Others may run as a single jar with the server embedded, possibly in a cloud environment. Yet others may be standalone applications (such as batch or integration workloads) that do not need a server.</span><br><span class="line"></span><br><span class="line">Spring is open source. It has a large and active community that provides continuous feedback based on a diverse range of real-world use cases. This has helped Spring to successfully evolve over a very long time.</span><br><span class="line"></span><br><span class="line">Spring 使创建 Java 企业应用程序变得更加容易。它提供了在企业环境中接受 Java 语言所需的一切,，并支持 Groovy 和 Kotlin 作为 JVM 上的替代语言，并可根据应用程序的需要灵活地创建多种体系结构。 从 Spring Framework 5.0 开始，Spring 需要 JDK 8(Java SE 8+)，并且已经为 JDK 9 提供了现成的支持。</span><br><span class="line"></span><br><span class="line">Spring支持各种应用场景， 在大型企业中, 应用程序通常需要运行很长时间，而且必须运行在 jdk 和应用服务器上，这种场景开发人员无法控制其升级周期。 其他可能作为一个单独的jar嵌入到服务器去运行，也有可能在云环境中。还有一些可能是不需要服务器的独立应用程序(如批处理或集成的工作任务)。</span><br><span class="line"></span><br><span class="line">Spring 是开源的。它拥有一个庞大而且活跃的社区，提供不同范围的，真实用户的持续反馈。这也帮助Spring不断地改进,不断发展。</span><br></pre></td></tr></table></figure><p><strong>核心解释</strong></p><p>​        spring是一个开源框架。</p><p>​        spring是为了简化企业开发而生的，使得开发变得更加优雅和简洁。</p><p>​        spring是一个<strong>IOC</strong>和<strong>AOP</strong>的容器框架。</p><p>​                IOC：控制反转</p><p>​                AOP：面向切面编程</p><p>​                容器：包含并管理应用对象的生命周期，就好比用桶装水一样，spring就是桶，而对象就是水</p><p><strong>使用spring的优点</strong></p><p>​        1、Spring通过DI、AOP和消除样板式代码来简化企业级Java开发</p><p>​        2、Spring框架之外还存在一个构建在核心框架之上的庞大生态圈，它将Spring扩展到不同的领域，如Web服务、REST、移动开发以及NoSQL</p><p>​        3、低侵入式设计，代码的污染极低</p><p>​        4、独立于各种应用服务器，基于Spring框架的应用，可以真正实现Write Once,Run Anywhere的承诺</p><p>​        5、Spring的IoC容器降低了业务对象替换的复杂性，提高了组件之间的解耦</p><p>​        6、Spring的AOP支持允许将一些通用任务如安全、事务、日志等进行集中式处理，从而提供了更好的复用</p><p>​        7、Spring的ORM和DAO提供了与第三方持久层框架的的良好整合，并简化了底层的数据库访问</p><p>​        8、Spring的高度开放性，并不强制应用完全依赖于Spring，开发者可自由选用Spring框架的部分或全部</p><p><strong>如何简化开发</strong></p><p>​        基于POJO的轻量级和最小侵入性编程</p><p>​        通过依赖注入和面向接口实现松耦合</p><p>​        基于切面和惯例进行声明式编程</p><p>​        通过切面和模板减少样板式代码</p><p><strong>spring的模块划分图</strong></p><p><img src="/2020/04/05/%E5%88%9D%E8%AF%86Spring/spring-overview-1596445585762.png" alt="overview"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">模块解释：</span><br><span class="line">Test:Spring的单元测试模块</span><br><span class="line">Core Container:核心容器模块</span><br><span class="line">AOP+Aspects:面向切面编程模块</span><br><span class="line">Instrumentation:提供了class instrumentation支持和类加载器的实现来在特定的应用服务器上使用,几乎不用</span><br><span class="line">Messaging:包括一系列的用来映射消息到方法的注解,几乎不用</span><br><span class="line">Data Access&#x2F;Integration:数据的获取&#x2F;整合模块，包括了JDBC,ORM,OXM,JMS和事务模块</span><br><span class="line">Web:提供面向web整合特性</span><br></pre></td></tr></table></figure><h3 id="3、IOC（Inversion-of-Control）-控制反转"><a href="#3、IOC（Inversion-of-Control）-控制反转" class="headerlink" title="3、IOC（Inversion of Control）:控制反转"></a>3、IOC（Inversion of Control）:控制反转</h3><p><strong>为什么要引入IOC</strong></p><p>创建一个普通的java项目，完成下述功能</p><p>UserDao.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mashibing.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUser</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UserDaoImpl.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mashibing.dao.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.mashibing.dao.UserDao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span>  <span class="keyword">implements</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"获取用户数据"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UserService.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mashibing.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUser</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UserServiceImpl.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mashibing.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.mashibing.dao.UserDao;</span><br><span class="line"><span class="keyword">import</span> com.mashibing.dao.impl.UserDaoImpl;</span><br><span class="line"><span class="keyword">import</span> com.mashibing.dao.impl.UserDaoMysqlImpl;</span><br><span class="line"><span class="keyword">import</span> com.mashibing.service.UserService;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao = <span class="keyword">new</span> UserDaoImpl();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        userDao.getUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SpringDemoTest.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mashibing.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.mashibing.service.UserService;</span><br><span class="line"><span class="keyword">import</span> com.mashibing.service.impl.UserServiceImpl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringDemoTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       UserService service = <span class="keyword">new</span> UserServiceImpl();</span><br><span class="line">       service.getUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在之前的代码编写过程中，我们都是这么完成我们的功能的，但是如果增加一个UserDao的实现类呢？</p><p>UserDaoMysqlImpl.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mashibing.dao.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.mashibing.dao.UserDao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoMysqlImpl</span> <span class="keyword">implements</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"mysql"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们想要使用mysql的话，那么就必须要修改UserServiceImpl.java的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mashibing.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.mashibing.dao.UserDao;</span><br><span class="line"><span class="keyword">import</span> com.mashibing.dao.impl.UserDaoImpl;</span><br><span class="line"><span class="keyword">import</span> com.mashibing.dao.impl.UserDaoMysqlImpl;</span><br><span class="line"><span class="keyword">import</span> com.mashibing.service.UserService;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao = <span class="keyword">new</span> UserDaoImpl();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        userDao.getUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是如果我们再增加一个oracle的类呢？</p><p>UserDaoOracleImpl.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mashibing.dao.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.mashibing.dao.UserDao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoOracleImpl</span> <span class="keyword">implements</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"oracle"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时UserService还是要继续修改，很显然这样的方式已经不适用于我们的需求了，那么怎么解决呢，可以使用如下的方式</p><p>UserServiceImpl.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mashibing.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.mashibing.dao.UserDao;</span><br><span class="line"><span class="keyword">import</span> com.mashibing.dao.impl.UserDaoImpl;</span><br><span class="line"><span class="keyword">import</span> com.mashibing.service.UserService;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserDao</span><span class="params">(UserDao userDao)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        userDao.getUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类SpringDemoTest.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mashibing.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.mashibing.dao.impl.UserDaoMysqlImpl;</span><br><span class="line"><span class="keyword">import</span> com.mashibing.dao.impl.UserDaoOracleImpl;</span><br><span class="line"><span class="keyword">import</span> com.mashibing.service.UserService;</span><br><span class="line"><span class="keyword">import</span> com.mashibing.service.impl.UserServiceImpl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringDemoTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        UserServiceImpl userService = <span class="keyword">new</span> UserServiceImpl();</span><br><span class="line">        userService.setUserDao(<span class="keyword">new</span> UserDaoMysqlImpl());</span><br><span class="line">        userService.getUser();</span><br><span class="line"></span><br><span class="line">        userService.setUserDao(<span class="keyword">new</span> UserDaoOracleImpl());</span><br><span class="line">        userService.getUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实从刚刚的代码中，大家应该能体会解耦的重要性了，下面我们就开始学习Spring的IOC。</p><p><strong>IOC初始</strong></p><p>​        想要搞明白IOC，那么需要搞清楚如下几个问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1、谁控制谁</span><br><span class="line">2、控制什么</span><br><span class="line">3、什么是反转</span><br><span class="line">4、哪些方面被反转</span><br></pre></td></tr></table></figure><p><strong>基本概念</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IoC is also known as dependency injection (DI). It is a process whereby objects define their dependencies (that is, the other objects they work with) only through constructor arguments, arguments to a factory method, or properties that are set on the object instance after it is constructed or returned from a factory method. The container then injects those dependencies when it creates the bean. This process is fundamentally the inverse (hence the name, Inversion of Control) of the bean itself controlling the instantiation or location of its dependencies by using direct construction of classes or a mechanism such as the Service Locator pattern.</span><br><span class="line">IOC与大家熟知的依赖注入同理，. 这是一个通过依赖注入对象的过程 也就是说，它们所使用的对象，是通过构造函数参数，工厂方法的参数或这是从工厂方法的构造函数或返回值的对象实例设置的属性，然后容器在创建bean时注入这些需要的依赖。 这个过程相对普通创建对象的过程是反向的（因此称之为IoC），bean本身通过直接构造类来控制依赖关系的实例化或位置，或提供诸如服务定位器模式之类的机制。</span><br></pre></td></tr></table></figure><p>如果这个过程比较难理解的话，那么可以想象自己找女朋友和婚介公司找女朋友的过程。如果这个过程能够想明白的话，那么我们现在回答上面的问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1、谁控制谁：在之前的编码过程中，都是需要什么对象自己去创建什么对象，有程序员自己来控制对象，而有了IOC容器之后，就会变成由IOC容器来控制对象，</span><br><span class="line">2、控制什么：在实现过程中所需要的对象及需要依赖的对象</span><br><span class="line">3、什么是反转：在没有IOC容器之前我们都是在对象中主动去创建依赖的对象，这是正转的，而有了IOC之后，依赖的对象直接由IOC容器创建后注入到对象中，由主动创建变成了被动接受，这是反转</span><br><span class="line">4、哪些方面被反转：依赖的对象</span><br></pre></td></tr></table></figure><p><strong>DI与IOC</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">很多人把IOC和DI说成一个东西，笼统来说的话是没有问题的，但是本质上还是有所区别的,希望大家能够严谨一点，IOC和DI是从不同的角度描述的同一件事，IOC是从容器的角度描述，而DI是从应用程序的角度来描述，也可以这样说，IOC是设计思想，而DI是具体的实现方式</span><br></pre></td></tr></table></figure><h3 id="4、总结"><a href="#4、总结" class="headerlink" title="4、总结"></a>4、总结</h3><p>​        总结一下Spring主要做的两件事：</p><p>​        <strong>1、解耦</strong></p><p>​        在面向对象设计的软件系统中，底层的实现都是由N个对象组成的，所有的对象通过彼此的合作，最终实现系统的业务逻辑。</p><p><img src="/2020/04/05/%E5%88%9D%E8%AF%86Spring/%E8%80%A6%E5%90%88%E5%AF%B9%E8%B1%A1-1596445585763.jpg" alt></p><p>​        需要注意的是，在这样的组合关系中，一旦某一个对象出现了问题，那么其他对象肯定回有所影响，这就是耦合性太高的缘故，但是对象的耦合关系是无法避免的，也是必要的。随着应用程序越来越庞大，对象的耦合关系可能越来越复杂，经常需要多重依赖关系，因此，无论是架构师还是程序员，在面临这样的场景的时候，都需要减少这些对象的耦合性。</p><p><img src="/2020/04/05/%E5%88%9D%E8%AF%86Spring/2011052709390013-1596445585763.jpg" alt></p><p>​        耦合的关系不仅仅是对象与对象之间，也会出现在软件系统的各个模块之间，是我们需要重点解决的问题。而为了解决对象之间的耦合度过高的问题，我们就可以通过IOC来实现对象之间的解耦，spring框架就是IOC理论最最广泛的应用。</p><p><img src="/2020/04/05/%E5%88%9D%E8%AF%86Spring/ioc-1596445585763.jpg" alt></p><p>​        从上图中可以看到，当引入了第三方的容器之后，几个对象之间就没有了耦合关系，全部对象都交由容器来控制，这个容器就相当于粘合剂，将系统的对象粘合在一起发挥作用。</p><p>​        <strong>2、生态</strong></p><p>​        任何一个语言或者任何一个框架想要立于不败之地，那么很重要的就是它的生态。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
